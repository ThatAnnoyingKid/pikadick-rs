/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const BCM_HOST_BOARD_TYPE_MODELA: u32 = 0;
pub const BCM_HOST_BOARD_TYPE_MODELB: u32 = 1;
pub const BCM_HOST_BOARD_TYPE_MODELAPLUS: u32 = 2;
pub const BCM_HOST_BOARD_TYPE_MODELBPLUS: u32 = 3;
pub const BCM_HOST_BOARD_TYPE_PI2MODELB: u32 = 4;
pub const BCM_HOST_BOARD_TYPE_ALPHA: u32 = 5;
pub const BCM_HOST_BOARD_TYPE_CM: u32 = 6;
pub const BCM_HOST_BOARD_TYPE_CM2: u32 = 7;
pub const BCM_HOST_BOARD_TYPE_PI3MODELB: u32 = 8;
pub const BCM_HOST_BOARD_TYPE_PI0: u32 = 9;
pub const BCM_HOST_BOARD_TYPE_CM3: u32 = 10;
pub const BCM_HOST_BOARD_TYPE_CUSTOM: u32 = 11;
pub const BCM_HOST_BOARD_TYPE_PI0W: u32 = 12;
pub const BCM_HOST_BOARD_TYPE_PI3MODELBPLUS: u32 = 13;
pub const BCM_HOST_BOARD_TYPE_PI3MODELAPLUS: u32 = 14;
pub const BCM_HOST_BOARD_TYPE_FPGA: u32 = 15;
pub const BCM_HOST_BOARD_TYPE_CM3PLUS: u32 = 16;
pub const BCM_HOST_BOARD_TYPE_PI4MODELB: u32 = 17;
pub const BCM_HOST_BOARD_TYPE_PI400: u32 = 19;
pub const BCM_HOST_BOARD_TYPE_CM4: u32 = 20;
pub const BCM_HOST_PROCESSOR_BCM2835: u32 = 0;
pub const BCM_HOST_PROCESSOR_BCM2836: u32 = 1;
pub const BCM_HOST_PROCESSOR_BCM2837: u32 = 2;
pub const BCM_HOST_PROCESSOR_BCM2838: u32 = 3;
pub const BCM_HOST_PROCESSOR_BCM2711: u32 = 3;
pub const GENCMDSERVICE_MSGFIFO_SIZE: u32 = 4092;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_ulong;
pub type VCOS_THREAD_ENTRY_FN_T = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub const VCOS_STATUS_T_VCOS_SUCCESS: VCOS_STATUS_T = 0;
pub const VCOS_STATUS_T_VCOS_EAGAIN: VCOS_STATUS_T = 1;
pub const VCOS_STATUS_T_VCOS_ENOENT: VCOS_STATUS_T = 2;
pub const VCOS_STATUS_T_VCOS_ENOSPC: VCOS_STATUS_T = 3;
pub const VCOS_STATUS_T_VCOS_EINVAL: VCOS_STATUS_T = 4;
pub const VCOS_STATUS_T_VCOS_EACCESS: VCOS_STATUS_T = 5;
pub const VCOS_STATUS_T_VCOS_ENOMEM: VCOS_STATUS_T = 6;
pub const VCOS_STATUS_T_VCOS_ENOSYS: VCOS_STATUS_T = 7;
pub const VCOS_STATUS_T_VCOS_EEXIST: VCOS_STATUS_T = 8;
pub const VCOS_STATUS_T_VCOS_ENXIO: VCOS_STATUS_T = 9;
pub const VCOS_STATUS_T_VCOS_EINTR: VCOS_STATUS_T = 10;
pub type VCOS_STATUS_T = ::std::os::raw::c_uint;
pub type vcos_bool_t = i32;
pub type vcos_fourcc_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        32usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        8usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type VCOS_SEMAPHORE_T = sem_t;
pub type VCOS_UNSIGNED = u32;
pub type VCOS_OPTION = u32;
pub type VCOS_ONCE_T = pthread_once_t;
pub type VCOS_MUTEX_T = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_TIMER_T {
    pub thread: pthread_t,
    pub lock: pthread_mutex_t,
    pub settings_changed: pthread_cond_t,
    pub quit: ::std::os::raw::c_int,
    pub expires: timespec,
    pub orig_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_TIMER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_TIMER_T>(),
        144usize,
        concat!("Size of: ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_TIMER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).settings_changed as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(settings_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).quit as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).expires as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_expiration_routine as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_context as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_ATTR_T {
    pub ta_stackaddr: *mut ::std::os::raw::c_void,
    pub ta_stacksz: VCOS_UNSIGNED,
    pub ta_priority: VCOS_UNSIGNED,
    pub ta_affinity: VCOS_UNSIGNED,
    pub ta_timeslice: VCOS_UNSIGNED,
    pub legacy: VCOS_UNSIGNED,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_ATTR_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_ATTR_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_ATTR_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stackaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stacksz as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stacksz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_priority as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_affinity as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_timeslice as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_timeslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).legacy as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(legacy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_EXIT_T {
    pub pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cxt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_EXIT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_EXIT_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_EXIT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).cxt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(cxt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_THREAD_T {
    pub thread: pthread_t,
    pub entry: VCOS_THREAD_ENTRY_FN_T,
    pub arg: *mut ::std::os::raw::c_void,
    pub suspend: VCOS_SEMAPHORE_T,
    pub task_timer: VCOS_TIMER_T,
    pub task_timer_created: ::std::os::raw::c_int,
    pub orig_task_timer_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_task_timer_context: *mut ::std::os::raw::c_void,
    pub legacy: VCOS_UNSIGNED,
    pub name: [::std::os::raw::c_char; 16usize],
    pub dummy: VCOS_UNSIGNED,
    pub at_exit: [VCOS_THREAD_EXIT_T; 4usize],
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_T>(),
        312usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).entry as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).arg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).suspend as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer_created as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer_created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_expiration_routine as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_expiration_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_context as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).legacy as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).name as *const _ as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).dummy as *const _ as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).at_exit as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(at_exit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_WAITER_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T {
    pub events: VCOS_UNSIGNED,
    pub lock: VCOS_MUTEX_T,
    pub waiters: VCOS_EVENT_FLAGS_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 {
    pub head: *mut VCOS_EVENT_WAITER_T,
    pub tail: *mut VCOS_EVENT_WAITER_T,
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).tail as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T>(),
        72usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).lock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).waiters as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(waiters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_HEADER_TAG {
    pub owner: VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    pub next: *mut VCOS_BLOCKPOOL_HEADER_TAG,
    pub subpool: *mut VCOS_BLOCKPOOL_SUBPOOL_TAG,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).subpool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(subpool)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG),
            "::",
            stringify!(owner)
        )
    );
}
pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG {
    pub magic: u32,
    pub free_list: *mut VCOS_BLOCKPOOL_HEADER_T,
    pub mem: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    pub num_blocks: VCOS_UNSIGNED,
    pub available_blocks: VCOS_UNSIGNED,
    pub owner: *mut VCOS_BLOCKPOOL_TAG,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        64usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).free_list as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).mem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).start as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).num_blocks as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).available_blocks as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(available_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).owner as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).flags as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
}
pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_TAG {
    pub magic: u32,
    pub mutex: VCOS_MUTEX_T,
    pub align: VCOS_UNSIGNED,
    pub flags: VCOS_UNSIGNED,
    pub block_data_size: size_t,
    pub block_size: size_t,
    pub name: *const ::std::os::raw::c_char,
    pub num_subpools: VCOS_UNSIGNED,
    pub num_extension_blocks: VCOS_UNSIGNED,
    pub subpools: [VCOS_BLOCKPOOL_SUBPOOL_T; 8usize],
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_TAG>(),
        608usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_TAG>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).mutex as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).align as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).flags as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_data_size as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).name as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_subpools as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_subpools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_extension_blocks as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_extension_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).subpools as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(subpools)
        )
    );
}
pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_REENTRANT_MUTEX_T {
    pub mutex: VCOS_MUTEX_T,
    pub owner: *mut VCOS_THREAD_T,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_REENTRANT_MUTEX_T>(),
        64usize,
        concat!("Size of: ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_REENTRANT_MUTEX_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).owner as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).count as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_T {
    pub actual: *mut VCOS_NAMED_SEMAPHORE_IMPL_T,
    pub sem: *mut VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_NAMED_SEMAPHORE_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_NAMED_SEMAPHORE_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).actual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(sem)
        )
    );
}
pub type va_list = [u64; 4usize];
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED: VCOS_LOG_LEVEL_T = 0;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER: VCOS_LOG_LEVEL_T = 1;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR: VCOS_LOG_LEVEL_T = 2;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN: VCOS_LOG_LEVEL_T = 3;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO: VCOS_LOG_LEVEL_T = 4;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE: VCOS_LOG_LEVEL_T = 5;
pub type VCOS_LOG_LEVEL_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T {
    pub level: VCOS_LOG_LEVEL_T,
    pub name: *const ::std::os::raw::c_char,
    pub next: *mut VCOS_LOG_CAT_T,
    pub flags: VCOS_LOG_CAT_T__bindgen_ty_1,
    pub refcount: ::std::os::raw::c_uint,
    pub platform_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
}
impl VCOS_LOG_CAT_T__bindgen_ty_1 {
    #[inline]
    pub fn want_prefix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_prefix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_prefix: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_prefix: u32 = unsafe { ::std::mem::transmute(want_prefix) };
            want_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T>(),
        40usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).refcount as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).platform_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(platform_data)
        )
    );
}
pub type VCOS_VLOG_IMPL_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
pub type VCOS_CMD_T = VCOS_CMD_S;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_PARAM_T {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub argv_orig: *mut *mut ::std::os::raw::c_char,
    pub cmd_entry: *mut VCOS_CMD_T,
    pub cmd_parent_entry: *mut VCOS_CMD_T,
    pub use_log: ::std::os::raw::c_int,
    pub result_size: size_t,
    pub result_ptr: *mut ::std::os::raw::c_char,
    pub result_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_PARAM_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_PARAM_T>(),
        72usize,
        concat!("Size of: ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_PARAM_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv_orig as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv_orig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_parent_entry as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_parent_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).use_log as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(use_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_size as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_ptr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_buf as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_buf)
        )
    );
}
pub type VCOS_CMD_FUNC_T =
    ::std::option::Option<unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_S {
    pub name: *const ::std::os::raw::c_char,
    pub args: *const ::std::os::raw::c_char,
    pub cmd_fn: VCOS_CMD_FUNC_T,
    pub sub_cmd_entry: *mut VCOS_CMD_T,
    pub descr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_S() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_S>(),
        40usize,
        concat!("Size of: ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_S>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).args as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).cmd_fn as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(cmd_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).sub_cmd_entry as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(sub_cmd_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).descr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(descr)
        )
    );
}
pub const VCHI_FLAGS_T_VCHI_FLAGS_NONE: VCHI_FLAGS_T = 0;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE: VCHI_FLAGS_T = 1;
pub const VCHI_FLAGS_T_VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE: VCHI_FLAGS_T = 2;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_QUEUED: VCHI_FLAGS_T = 4;
pub const VCHI_FLAGS_T_VCHI_FLAGS_ALLOW_PARTIAL: VCHI_FLAGS_T = 8;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_DATA_READ: VCHI_FLAGS_T = 16;
pub const VCHI_FLAGS_T_VCHI_FLAGS_CALLBACK_WHEN_DATA_READ: VCHI_FLAGS_T = 32;
pub const VCHI_FLAGS_T_VCHI_FLAGS_ALIGN_SLOT: VCHI_FLAGS_T = 128;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_AUX_QUEUED: VCHI_FLAGS_T = 65536;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_AUX_COMPLETE: VCHI_FLAGS_T = 131072;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_DATA_QUEUED: VCHI_FLAGS_T = 262144;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_DATA_COMPLETE: VCHI_FLAGS_T = 524288;
pub const VCHI_FLAGS_T_VCHI_FLAGS_INTERNAL: VCHI_FLAGS_T = 16711680;
pub type VCHI_FLAGS_T = ::std::os::raw::c_uint;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_NOTHING: VCHI_CRC_CONTROL_T = -1;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_PER_SERVICE: VCHI_CRC_CONTROL_T = 0;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_EVERYTHING: VCHI_CRC_CONTROL_T = 1;
pub type VCHI_CRC_CONTROL_T = ::std::os::raw::c_int;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_REASON_MIN: VCHI_CALLBACK_REASON_T = 0;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_AVAILABLE: VCHI_CALLBACK_REASON_T = 1;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_SENT: VCHI_CALLBACK_REASON_T = 2;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 3;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_RECEIVED: VCHI_CALLBACK_REASON_T = 4;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_SENT: VCHI_CALLBACK_REASON_T = 5;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_RX_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 6;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_TX_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 7;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SERVICE_CLOSED: VCHI_CALLBACK_REASON_T = 8;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SENT_XOFF: VCHI_CALLBACK_REASON_T = 9;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SENT_XON: VCHI_CALLBACK_REASON_T = 10;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_DATA_READ: VCHI_CALLBACK_REASON_T = 11;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_OFF: VCHI_CALLBACK_REASON_T = 12;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_SUSPENDED: VCHI_CALLBACK_REASON_T = 13;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_ON: VCHI_CALLBACK_REASON_T = 14;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_RESUMED: VCHI_CALLBACK_REASON_T = 15;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_FORCED_POWER_OFF: VCHI_CALLBACK_REASON_T = 16;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_REASON_MAX: VCHI_CALLBACK_REASON_T = 17;
pub type VCHI_CALLBACK_REASON_T = ::std::os::raw::c_uint;
pub const VCHI_SERVICE_OPTION_T_VCHI_SERVICE_OPTION_MIN: VCHI_SERVICE_OPTION_T = 0;
pub const VCHI_SERVICE_OPTION_T_VCHI_SERVICE_OPTION_TRACE: VCHI_SERVICE_OPTION_T = 1;
pub const VCHI_SERVICE_OPTION_T_VCHI_SERVICE_OPTION_SYNCHRONOUS: VCHI_SERVICE_OPTION_T = 2;
pub const VCHI_SERVICE_OPTION_T_VCHI_SERVICE_OPTION_MAX: VCHI_SERVICE_OPTION_T = 3;
pub type VCHI_SERVICE_OPTION_T = ::std::os::raw::c_uint;
pub type VCHI_CALLBACK_T = ::std::option::Option<
    unsafe extern "C" fn(
        callback_param: *mut ::std::os::raw::c_void,
        reason: VCHI_CALLBACK_REASON_T,
        handle: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vchi_msg_vector {
    pub vec_base: *const ::std::os::raw::c_void,
    pub vec_len: i32,
}
#[test]
fn bindgen_test_layout_vchi_msg_vector() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector>(),
        16usize,
        concat!("Size of: ", stringify!(vchi_msg_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector>(),
        8usize,
        concat!("Alignment of ", stringify!(vchi_msg_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector>())).vec_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector),
            "::",
            stringify!(vec_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector>())).vec_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector),
            "::",
            stringify!(vec_len)
        )
    );
}
pub type VCHI_MSG_VECTOR_T = vchi_msg_vector;
pub type VCHI_CONNECTION_API_T = opaque_vchi_connection_api_t;
pub type VCHI_MESSAGE_DRIVER_T = opaque_vchi_message_driver_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_MSG_ITER_T {
    pub service: *mut opaque_vchi_service_t,
    pub last: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub remove: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCHI_MSG_ITER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_MSG_ITER_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCHI_MSG_ITER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_MSG_ITER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCHI_MSG_ITER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).service as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).last as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).remove as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(remove)
        )
    );
}
pub const message_event_type_MESSAGE_EVENT_NONE: message_event_type = 0;
pub const message_event_type_MESSAGE_EVENT_NOP: message_event_type = 1;
pub const message_event_type_MESSAGE_EVENT_MESSAGE: message_event_type = 2;
pub const message_event_type_MESSAGE_EVENT_SLOT_COMPLETE: message_event_type = 3;
pub const message_event_type_MESSAGE_EVENT_RX_BULK_PAUSED: message_event_type = 4;
pub const message_event_type_MESSAGE_EVENT_RX_BULK_COMPLETE: message_event_type = 5;
pub const message_event_type_MESSAGE_EVENT_TX_COMPLETE: message_event_type = 6;
pub const message_event_type_MESSAGE_EVENT_MSG_DISCARDED: message_event_type = 7;
pub type message_event_type = ::std::os::raw::c_uint;
pub use self::message_event_type as MESSAGE_EVENT_TYPE_T;
pub const vchi_msg_flags_VCHI_MSG_FLAGS_NONE: vchi_msg_flags = 0;
pub const vchi_msg_flags_VCHI_MSG_FLAGS_TERMINATE_DMA: vchi_msg_flags = 1;
pub type vchi_msg_flags = ::std::os::raw::c_uint;
pub use self::vchi_msg_flags as VCHI_MSG_FLAGS_T;
pub const message_tx_channel_MESSAGE_TX_CHANNEL_MESSAGE: message_tx_channel = 0;
pub const message_tx_channel_MESSAGE_TX_CHANNEL_BULK: message_tx_channel = 1;
pub type message_tx_channel = ::std::os::raw::c_uint;
pub use self::message_tx_channel as MESSAGE_TX_CHANNEL_T;
pub const message_rx_channel_MESSAGE_RX_CHANNEL_MESSAGE: message_rx_channel = 0;
pub const message_rx_channel_MESSAGE_RX_CHANNEL_BULK: message_rx_channel = 1;
pub type message_rx_channel = ::std::os::raw::c_uint;
pub use self::message_rx_channel as MESSAGE_RX_CHANNEL_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rx_msg_slot_info {
    pub next: *mut rx_msg_slot_info,
    pub addr: *mut u8,
    pub len: u32,
    pub write_ptr: u32,
    pub read_ptr: u32,
    pub active: ::std::os::raw::c_int,
    pub msgs_parsed: u32,
    pub msgs_released: u32,
    pub state: *mut ::std::os::raw::c_void,
    pub ref_count: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_rx_msg_slot_info() {
    assert_eq!(
        ::std::mem::size_of::<rx_msg_slot_info>(),
        88usize,
        concat!("Size of: ", stringify!(rx_msg_slot_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rx_msg_slot_info>(),
        8usize,
        concat!("Alignment of ", stringify!(rx_msg_slot_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).write_ptr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).read_ptr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).active as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).msgs_parsed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(msgs_parsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).msgs_released as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(msgs_released)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).ref_count as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(ref_count)
        )
    );
}
pub type RX_MSG_SLOTINFO_T = rx_msg_slot_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rx_bulk_slotinfo_t {
    pub next: *mut rx_bulk_slotinfo_t,
    pub blocking: *mut VCOS_SEMAPHORE_T,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: u32,
    pub service: *mut ::std::os::raw::c_void,
    pub handle: *mut ::std::os::raw::c_void,
    pub flags: VCHI_FLAGS_T,
}
#[test]
fn bindgen_test_layout_rx_bulk_slotinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<rx_bulk_slotinfo_t>(),
        56usize,
        concat!("Size of: ", stringify!(rx_bulk_slotinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rx_bulk_slotinfo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rx_bulk_slotinfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).blocking as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(blocking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).service as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).handle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).flags as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(flags)
        )
    );
}
pub type RX_BULK_SLOTINFO_T = rx_bulk_slotinfo_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MESSAGE_EVENT_T {
    pub type_: MESSAGE_EVENT_TYPE_T,
    pub message: MESSAGE_EVENT_T__bindgen_ty_1,
    pub rx_msg: *mut RX_MSG_SLOTINFO_T,
    pub rx_bulk: *mut RX_BULK_SLOTINFO_T,
    pub tx_handle: *mut ::std::os::raw::c_void,
    pub tx_channel: MESSAGE_TX_CHANNEL_T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MESSAGE_EVENT_T__bindgen_ty_1 {
    pub addr: *mut ::std::os::raw::c_void,
    pub slot_delta: u16,
    pub len: u32,
    pub slot: *mut RX_MSG_SLOTINFO_T,
    pub service: vcos_fourcc_t,
    pub tx_timestamp: u32,
    pub rx_timestamp: u32,
}
#[test]
fn bindgen_test_layout_MESSAGE_EVENT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MESSAGE_EVENT_T__bindgen_ty_1>(),
        40usize,
        concat!("Size of: ", stringify!(MESSAGE_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MESSAGE_EVENT_T__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(MESSAGE_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).slot_delta as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(slot_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).slot as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).service as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).tx_timestamp as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(tx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).rx_timestamp as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(rx_timestamp)
        )
    );
}
#[test]
fn bindgen_test_layout_MESSAGE_EVENT_T() {
    assert_eq!(
        ::std::mem::size_of::<MESSAGE_EVENT_T>(),
        80usize,
        concat!("Size of: ", stringify!(MESSAGE_EVENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MESSAGE_EVENT_T>(),
        8usize,
        concat!("Alignment of ", stringify!(MESSAGE_EVENT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).rx_msg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(rx_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).rx_bulk as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(rx_bulk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).tx_handle as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(tx_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).tx_channel as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(tx_channel)
        )
    );
}
pub type VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_MESSAGE_DRIVER_OPEN_T {
    pub event_callback: VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T,
}
#[test]
fn bindgen_test_layout_VCHI_MESSAGE_DRIVER_OPEN_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_MESSAGE_DRIVER_OPEN_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCHI_MESSAGE_DRIVER_OPEN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_MESSAGE_DRIVER_OPEN_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCHI_MESSAGE_DRIVER_OPEN_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCHI_MESSAGE_DRIVER_OPEN_T>())).event_callback as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MESSAGE_DRIVER_OPEN_T),
            "::",
            stringify!(event_callback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_mhandle_t {
    _unused: [u8; 0],
}
pub type VCHI_MDRIVER_HANDLE_T = *mut opaque_mhandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_message_driver_t {
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            params: *mut VCHI_MESSAGE_DRIVER_OPEN_T,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut VCHI_MDRIVER_HANDLE_T,
    >,
    pub suspending:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub resumed:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub power_control: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            arg1: MESSAGE_TX_CHANNEL_T,
            enable: vcos_bool_t,
        ) -> i32,
    >,
    pub add_msg_rx_slot: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            slot: *mut RX_MSG_SLOTINFO_T,
        ) -> i32,
    >,
    pub add_bulk_rx: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            data: *mut ::std::os::raw::c_void,
            len: u32,
            slot: *mut RX_BULK_SLOTINFO_T,
        ) -> i32,
    >,
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
            data: *const ::std::os::raw::c_void,
            len: u32,
            flags: VCHI_MSG_FLAGS_T,
            send_handle: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    pub next_event: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T, event: *mut MESSAGE_EVENT_T),
    >,
    pub enable:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub form_message: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            service_id: vcos_fourcc_t,
            vector: *mut VCHI_MSG_VECTOR_T,
            count: u32,
            address: *mut ::std::os::raw::c_void,
            length_avail: u32,
            max_total_length: u32,
            pad_to_fill: vcos_bool_t,
            allow_partial: vcos_bool_t,
        ) -> i32,
    >,
    pub update_message: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            dest: *mut ::std::os::raw::c_void,
            slot_count: *mut i16,
        ) -> i32,
    >,
    pub buffer_aligned: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            tx: ::std::os::raw::c_int,
            uncached: ::std::os::raw::c_int,
            address: *const ::std::os::raw::c_void,
            length: u32,
        ) -> i32,
    >,
    pub allocate_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            length: *mut u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            address: *mut ::std::os::raw::c_void,
        ),
    >,
    pub rx_slot_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            msg_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tx_slot_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            msg_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tx_supports_terminate: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> vcos_bool_t,
    >,
    pub tx_bulk_chunk_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> u32,
    >,
    pub tx_alignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> ::std::os::raw::c_int,
    >,
    pub rx_alignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_RX_CHANNEL_T,
        ) -> ::std::os::raw::c_int,
    >,
    pub form_bulk_aux: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
            data: *const ::std::os::raw::c_void,
            len: u32,
            chunk_size: u32,
            aux_data: *mut *const ::std::os::raw::c_void,
            aux_len: *mut i32,
        ),
    >,
    pub debug: ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T)>,
}
#[test]
fn bindgen_test_layout_opaque_vchi_message_driver_t() {
    assert_eq!(
        ::std::mem::size_of::<opaque_vchi_message_driver_t>(),
        176usize,
        concat!("Size of: ", stringify!(opaque_vchi_message_driver_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opaque_vchi_message_driver_t>(),
        8usize,
        concat!("Alignment of ", stringify!(opaque_vchi_message_driver_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).open as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).suspending as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(suspending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).resumed as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(resumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).power_control as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(power_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).add_msg_rx_slot as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(add_msg_rx_slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).add_bulk_rx as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(add_bulk_rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).send as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).next_event as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(next_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).enable as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).form_message as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(form_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).update_message as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(update_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).buffer_aligned as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(buffer_aligned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).allocate_buffer as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(allocate_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).free_buffer as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(free_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).rx_slot_size as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(rx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_slot_size as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_supports_terminate
                as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_supports_terminate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_bulk_chunk_size as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_bulk_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_alignment as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).rx_alignment as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(rx_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).form_bulk_aux as *const _
                as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(form_bulk_aux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).debug as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(debug)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_connected_service_handle_t {
    _unused: [u8; 0],
}
pub type VCHI_CONNECTION_SERVICE_HANDLE_T = *mut opaque_vchi_connection_connected_service_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_info_t {
    _unused: [u8; 0],
}
pub type VCHI_CONNECTION_STATE_T = opaque_vchi_connection_info_t;
pub type VCHI_CONNECTION_T = vchi_connection_t;
pub type VCHI_CONNECTION_INIT_T = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut vchi_connection_t,
        driver: *const VCHI_MESSAGE_DRIVER_T,
    ) -> *mut VCHI_CONNECTION_STATE_T,
>;
pub type VCHI_CONNECTION_CRC_CONTROL_T = ::std::option::Option<
    unsafe extern "C" fn(
        state_handle: *mut VCHI_CONNECTION_STATE_T,
        control: VCHI_CRC_CONTROL_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_CONNECT_T = ::std::option::Option<
    unsafe extern "C" fn(
        state_handle: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        rx_fifo_size: u32,
        tx_fifo_size: u32,
        server: ::std::os::raw::c_int,
        callback: VCHI_CALLBACK_T,
        callback_param: *mut ::std::os::raw::c_void,
        want_crc: vcos_bool_t,
        want_unaligned_bulk_rx: vcos_bool_t,
        want_unaligned_bulk_tx: vcos_bool_t,
        service_handle: *mut VCHI_CONNECTION_SERVICE_HANDLE_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_DISCONNECT_T = ::std::option::Option<
    unsafe extern "C" fn(service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        vector: *mut VCHI_MSG_VECTOR_T,
        count: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut ::std::os::raw::c_void,
        max_data_size_to_read: u32,
        actual_msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
        message_handle: *mut *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_HELD_MSG_RELEASE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        message_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_HELD_MSG_INFO_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        message_handle: *mut ::std::os::raw::c_void,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut i32,
        tx_timestamp: *mut u32,
        rx_timestamp: *mut u32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *const VCHI_MSG_ITER_T,
    ) -> vcos_bool_t,
>;
pub type VCHI_CONNECTION_MSG_ITER_NEXT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_REMOVE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_HOLD_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        msg_handle: *mut *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data_src: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        bulk_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data_dst: *mut ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        bulk_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVER_PRESENT = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        peer_flags: i32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_RX_SLOTS_AVAILABLE = ::std::option::Option<
    unsafe extern "C" fn(state: *const VCHI_CONNECTION_STATE_T) -> ::std::os::raw::c_int,
>;
pub type VCHI_CONNECTION_RX_SLOT_SIZE =
    ::std::option::Option<unsafe extern "C" fn(state: *const VCHI_CONNECTION_STATE_T) -> u32>;
pub type VCHI_CONNECTION_RX_BULK_BUFFER_ADDED = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service: vcos_fourcc_t,
        length: u32,
        channel: MESSAGE_TX_CHANNEL_T,
        channel_params: u32,
        data_length: u32,
        data_offset: u32,
    ),
>;
pub type VCHI_CONNECTION_FLOW_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, service_id: vcos_fourcc_t, xoff: i32),
>;
pub type VCHI_CONNECTION_SERVER_AVAILABLE_REPLY = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        flags: u32,
    ),
>;
pub type VCHI_CONNECTION_BULK_AUX_RECEIVED =
    ::std::option::Option<unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T)>;
pub type VCHI_CONNECTION_BULK_AUX_TRANSMITTED = ::std::option::Option<
    unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, handle: *mut ::std::os::raw::c_void),
>;
pub type VCHI_CONNECTION_INFO = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        protocol_version: u32,
        slot_size: u32,
        num_slots: u32,
        min_bulk_size: u32,
    ),
>;
pub type VCHI_CONNECTION_DISCONNECT =
    ::std::option::Option<unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, flags: u32)>;
pub type VCHI_CONNECTION_POWER_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        channel: MESSAGE_TX_CHANNEL_T,
        enable: vcos_bool_t,
    ),
>;
pub type VCHI_BUFFER_ALLOCATE = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        length: *mut u32,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VCHI_BUFFER_FREE = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        address: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_api_t {
    pub init: VCHI_CONNECTION_INIT_T,
    pub crc_control: VCHI_CONNECTION_CRC_CONTROL_T,
    pub service_connect: VCHI_CONNECTION_SERVICE_CONNECT_T,
    pub service_disconnect: VCHI_CONNECTION_SERVICE_DISCONNECT_T,
    pub service_queue_msg: VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T,
    pub service_queue_msgv: VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T,
    pub service_dequeue_msg: VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T,
    pub service_peek_msg: VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T,
    pub service_hold_msg: VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T,
    pub service_look_ahead_msg: VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T,
    pub held_msg_release: VCHI_CONNECTION_HELD_MSG_RELEASE_T,
    pub held_msg_info: VCHI_CONNECTION_HELD_MSG_INFO_T,
    pub msg_iter_has_next: VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T,
    pub msg_iter_next: VCHI_CONNECTION_MSG_ITER_NEXT_T,
    pub msg_iter_remove: VCHI_CONNECTION_MSG_ITER_REMOVE_T,
    pub msg_iter_hold: VCHI_CONNECTION_MSG_ITER_HOLD_T,
    pub bulk_queue_transmit: VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T,
    pub bulk_queue_receive: VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T,
    pub server_present: VCHI_CONNECTION_SERVER_PRESENT,
    pub connection_rx_slots_available: VCHI_CONNECTION_RX_SLOTS_AVAILABLE,
    pub connection_rx_slot_size: VCHI_CONNECTION_RX_SLOT_SIZE,
    pub rx_bulk_buffer_added: VCHI_CONNECTION_RX_BULK_BUFFER_ADDED,
    pub flow_control: VCHI_CONNECTION_FLOW_CONTROL,
    pub server_available_reply: VCHI_CONNECTION_SERVER_AVAILABLE_REPLY,
    pub bulk_aux_received: VCHI_CONNECTION_BULK_AUX_RECEIVED,
    pub bulk_aux_transmitted: VCHI_CONNECTION_BULK_AUX_TRANSMITTED,
    pub connection_info: VCHI_CONNECTION_INFO,
    pub disconnect: VCHI_CONNECTION_DISCONNECT,
    pub power_control: VCHI_CONNECTION_POWER_CONTROL,
    pub buffer_allocate: VCHI_BUFFER_ALLOCATE,
    pub buffer_free: VCHI_BUFFER_FREE,
}
#[test]
fn bindgen_test_layout_opaque_vchi_connection_api_t() {
    assert_eq!(
        ::std::mem::size_of::<opaque_vchi_connection_api_t>(),
        248usize,
        concat!("Size of: ", stringify!(opaque_vchi_connection_api_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opaque_vchi_connection_api_t>(),
        8usize,
        concat!("Alignment of ", stringify!(opaque_vchi_connection_api_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).init as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).crc_control as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(crc_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_connect as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_connect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_disconnect as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_queue_msg as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_queue_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_queue_msgv as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_queue_msgv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_dequeue_msg as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_dequeue_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_peek_msg as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_peek_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_hold_msg as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_hold_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_look_ahead_msg
                as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_look_ahead_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).held_msg_release as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(held_msg_release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).held_msg_info as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(held_msg_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_has_next as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_has_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_next as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_remove as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_remove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_hold as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_hold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_queue_transmit as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_queue_transmit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_queue_receive as *const _
                as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_queue_receive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).server_present as *const _
                as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(server_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_rx_slots_available
                as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_rx_slots_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_rx_slot_size
                as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_rx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).rx_bulk_buffer_added
                as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(rx_bulk_buffer_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).flow_control as *const _
                as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).server_available_reply
                as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(server_available_reply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_aux_received as *const _
                as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_aux_received)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_aux_transmitted
                as *const _ as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_aux_transmitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_info as *const _
                as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).disconnect as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).power_control as *const _
                as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(power_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).buffer_allocate as *const _
                as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(buffer_allocate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).buffer_free as *const _
                as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(buffer_free)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vchi_connection_t {
    pub api: *const VCHI_CONNECTION_API_T,
    pub state: *mut VCHI_CONNECTION_STATE_T,
    pub sem: VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_vchi_connection_t() {
    assert_eq!(
        ::std::mem::size_of::<vchi_connection_t>(),
        48usize,
        concat!("Size of: ", stringify!(vchi_connection_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_connection_t>(),
        8usize,
        concat!("Alignment of ", stringify!(vchi_connection_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).api as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).sem as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(sem)
        )
    );
}
pub type VCHI_MEM_HANDLE_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_VERSION_T {
    pub version: u32,
    pub version_min: u32,
}
#[test]
fn bindgen_test_layout_VCHI_VERSION_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_VERSION_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCHI_VERSION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_VERSION_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCHI_VERSION_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_VERSION_T>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_VERSION_T),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_VERSION_T>())).version_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_VERSION_T),
            "::",
            stringify!(version_min)
        )
    );
}
pub const VCHI_MSG_VECTOR_TYPE_T_VCHI_VEC_POINTER: VCHI_MSG_VECTOR_TYPE_T = 0;
pub const VCHI_MSG_VECTOR_TYPE_T_VCHI_VEC_HANDLE: VCHI_MSG_VECTOR_TYPE_T = 1;
pub const VCHI_MSG_VECTOR_TYPE_T_VCHI_VEC_LIST: VCHI_MSG_VECTOR_TYPE_T = 2;
pub type VCHI_MSG_VECTOR_TYPE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vchi_msg_vector_ex {
    pub type_: VCHI_MSG_VECTOR_TYPE_T,
    pub u: vchi_msg_vector_ex__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union vchi_msg_vector_ex__bindgen_ty_1 {
    pub handle: vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1,
    pub ptr: vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2,
    pub list: vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1 {
    pub handle: VCHI_MEM_HANDLE_T,
    pub offset: u32,
    pub vec_len: i32,
}
#[test]
fn bindgen_test_layout_vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1>())).handle
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1>())).offset
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1>())).vec_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vec_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2 {
    pub vec_base: *const ::std::os::raw::c_void,
    pub vec_len: i32,
}
#[test]
fn bindgen_test_layout_vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2>())).vec_base
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(vec_base)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2>())).vec_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(vec_len)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3 {
    pub vec: *mut vchi_msg_vector_ex,
    pub vec_len: u32,
}
#[test]
fn bindgen_test_layout_vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3>())).vec
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(vec)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3>())).vec_len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1__bindgen_ty_3),
            "::",
            stringify!(vec_len)
        )
    );
}
#[test]
fn bindgen_test_layout_vchi_msg_vector_ex__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector_ex__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(vchi_msg_vector_ex__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector_ex__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1>())).ptr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<vchi_msg_vector_ex__bindgen_ty_1>())).list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex__bindgen_ty_1),
            "::",
            stringify!(list)
        )
    );
}
#[test]
fn bindgen_test_layout_vchi_msg_vector_ex() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector_ex>(),
        24usize,
        concat!("Size of: ", stringify!(vchi_msg_vector_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(vchi_msg_vector_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector_ex>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector_ex>())).u as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector_ex),
            "::",
            stringify!(u)
        )
    );
}
pub type VCHI_MSG_VECTOR_EX_T = vchi_msg_vector_ex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_service_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_HELD_MSG_T {
    pub service: *mut opaque_vchi_service_t,
    pub message: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCHI_HELD_MSG_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_HELD_MSG_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCHI_HELD_MSG_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_HELD_MSG_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCHI_HELD_MSG_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_HELD_MSG_T>())).service as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_HELD_MSG_T),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_HELD_MSG_T>())).message as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_HELD_MSG_T),
            "::",
            stringify!(message)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SERVICE_CREATION_T {
    pub version: VCHI_VERSION_T,
    pub service_id: vcos_fourcc_t,
    pub connection: *mut VCHI_CONNECTION_T,
    pub rx_fifo_size: u32,
    pub tx_fifo_size: u32,
    pub callback: VCHI_CALLBACK_T,
    pub callback_param: *mut ::std::os::raw::c_void,
    pub want_unaligned_bulk_rx: vcos_bool_t,
    pub want_unaligned_bulk_tx: vcos_bool_t,
    pub want_crc: vcos_bool_t,
}
#[test]
fn bindgen_test_layout_SERVICE_CREATION_T() {
    assert_eq!(
        ::std::mem::size_of::<SERVICE_CREATION_T>(),
        64usize,
        concat!("Size of: ", stringify!(SERVICE_CREATION_T))
    );
    assert_eq!(
        ::std::mem::align_of::<SERVICE_CREATION_T>(),
        8usize,
        concat!("Alignment of ", stringify!(SERVICE_CREATION_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).service_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).connection as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(connection)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).rx_fifo_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(rx_fifo_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).tx_fifo_size as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(tx_fifo_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).callback as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SERVICE_CREATION_T>())).callback_param as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(callback_param)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SERVICE_CREATION_T>())).want_unaligned_bulk_rx as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(want_unaligned_bulk_rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SERVICE_CREATION_T>())).want_unaligned_bulk_tx as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(want_unaligned_bulk_tx)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SERVICE_CREATION_T>())).want_crc as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(SERVICE_CREATION_T),
            "::",
            stringify!(want_crc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_instance_handle_t {
    _unused: [u8; 0],
}
pub type VCHI_INSTANCE_T = *mut opaque_vchi_instance_handle_t;
pub type VCHI_SERVICE_HANDLE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pagelist_struct {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_IMPL_T {
    pub _address: u8,
}
extern crate libloading;
pub struct libbcm_host {
    __library: ::libloading::Library,
    pub bcm_host_init: unsafe extern "C" fn(),
    pub bcm_host_deinit: unsafe extern "C" fn(),
    pub graphics_get_display_size:
        unsafe extern "C" fn(display_number: u16, width: *mut u32, height: *mut u32) -> i32,
    pub bcm_host_get_peripheral_address: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub bcm_host_get_peripheral_size: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub bcm_host_get_sdram_address: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub vcos_pthreads_logging_assert: unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_verify_bkpts_enabled: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_verify_bkpts_enable:
        unsafe extern "C" fn(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    pub vcos_abort: unsafe extern "C" fn(),
    pub vcos_backtrace_self: unsafe extern "C" fn(),
    pub vcos_generic_event_flags_create: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_event_flags_set: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ),
    pub vcos_generic_event_flags_delete: unsafe extern "C" fn(arg1: *mut VCOS_EVENT_FLAGS_T),
    pub vcos_generic_event_flags_get: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_init: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_create_on_heap: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_extend: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_alloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_calloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_free: unsafe extern "C" fn(block: *mut ::std::os::raw::c_void),
    pub vcos_generic_blockpool_available_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_used_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_delete: unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T),
    pub vcos_generic_blockpool_elem_to_handle:
        unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> u32,
    pub vcos_generic_blockpool_elem_from_handle:
        unsafe extern "C" fn(
            pool: *mut VCOS_BLOCKPOOL_T,
            handle: u32,
        ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_is_valid_elem: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32,
    pub vcos_generic_mem_alloc: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_calloc: unsafe extern "C" fn(
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_free: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
    pub vcos_generic_mem_alloc_aligned: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_pthreads_map_error:
        unsafe extern "C" fn(error: ::std::os::raw::c_int) -> VCOS_STATUS_T,
    pub vcos_pthreads_map_errno: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_thread_at_exit: unsafe extern "C" fn(
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_dummy_thread_create: unsafe extern "C" fn() -> *mut VCOS_THREAD_T,
    pub vcos_getmicrosecs64_internal: unsafe extern "C" fn() -> u64,
    pub vcos_pthreads_timer_create: unsafe extern "C" fn(
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_pthreads_timer_set:
        unsafe extern "C" fn(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED),
    pub vcos_pthreads_timer_cancel: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_pthreads_timer_delete: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_generic_reentrant_mutex_create: unsafe extern "C" fn(
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_reentrant_mutex_delete: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_lock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_unlock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_named_semaphore_create: unsafe extern "C" fn(
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_named_semaphore_delete: unsafe extern "C" fn(sem: *mut VCOS_NAMED_SEMAPHORE_T),
    pub vcos_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_deinit: unsafe extern "C" fn(),
    pub vcos_global_lock: unsafe extern "C" fn(),
    pub vcos_global_unlock: unsafe extern "C" fn(),
    pub vcos_set_args:
        unsafe extern "C" fn(argc: ::std::os::raw::c_int, argv: *mut *const ::std::os::raw::c_char),
    pub vcos_get_argc: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_get_argv: unsafe extern "C" fn() -> *mut *const ::std::os::raw::c_char,
    pub vcos_platform_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_platform_deinit: unsafe extern "C" fn(),
    pub vcos_have_rtos: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_thread_create: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_exit: unsafe extern "C" fn(data: *mut ::std::os::raw::c_void),
    pub vcos_thread_join:
        unsafe extern "C" fn(thread: *mut VCOS_THREAD_T, pData: *mut *mut ::std::os::raw::c_void),
    pub vcos_thread_create_classic: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_get_name:
        unsafe extern "C" fn(thread: *const VCOS_THREAD_T) -> *const ::std::os::raw::c_char,
    pub vcos_log_level_to_string:
        unsafe extern "C" fn(level: VCOS_LOG_LEVEL_T) -> *const ::std::os::raw::c_char,
    pub vcos_string_to_log_level: unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T,
    pub vcos_log_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_vlog_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_set_vlog_impl: unsafe extern "C" fn(vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T),
    pub vcos_vlog_default_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_logging_init: unsafe extern "C" fn(),
    pub vcos_log_register:
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char, category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_unregister: unsafe extern "C" fn(category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_get_default_category: unsafe extern "C" fn() -> *const VCOS_LOG_CAT_T,
    pub vcos_set_log_options: unsafe extern "C" fn(opt: *const ::std::os::raw::c_char),
    pub vcos_log_dump_mem_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ),
    pub vcos_cmd_error:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_printf:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_vprintf: unsafe extern "C" fn(
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_cmd_always_log_output: unsafe extern "C" fn(log_category: *mut VCOS_LOG_CAT_T),
    pub vcos_cmd_usage: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T),
    pub vcos_cmd_register: unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_register_multiple:
        unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_execute: unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_cmd_shutdown: unsafe extern "C" fn(),
    pub vcos_vsnprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int,
    pub vcos_snprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
    pub vcos_safe_vsprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t,
    pub vcos_safe_sprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> size_t,
    pub vcos_safe_strcpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_safe_strncpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_thread_attr_init: unsafe extern "C" fn(attrs: *mut VCOS_THREAD_ATTR_T),
    pub vcos_timer_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_once: unsafe extern "C" fn(
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T,
    pub vchi_create_connection: unsafe extern "C" fn(
        function_table: *const VCHI_CONNECTION_API_T,
        low_level: *const VCHI_MESSAGE_DRIVER_T,
    ) -> *mut VCHI_CONNECTION_T,
    pub vchi_initialise: unsafe extern "C" fn(instance_handle: *mut VCHI_INSTANCE_T) -> i32,
    pub vchi_connect: unsafe extern "C" fn(
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
        instance_handle: VCHI_INSTANCE_T,
    ) -> i32,
    pub vchi_disconnect: unsafe extern "C" fn(instance_handle: VCHI_INSTANCE_T) -> i32,
    pub vchi_service_create: unsafe extern "C" fn(
        instance_handle: VCHI_INSTANCE_T,
        setup: *mut SERVICE_CREATION_T,
        handle: *mut VCHI_SERVICE_HANDLE_T,
    ) -> i32,
    pub vchi_service_destroy: unsafe extern "C" fn(handle: VCHI_SERVICE_HANDLE_T) -> i32,
    pub vchi_service_open: unsafe extern "C" fn(
        instance_handle: VCHI_INSTANCE_T,
        setup: *mut SERVICE_CREATION_T,
        handle: *mut VCHI_SERVICE_HANDLE_T,
    ) -> i32,
    pub vchi_service_close: unsafe extern "C" fn(handle: VCHI_SERVICE_HANDLE_T) -> i32,
    pub vchi_service_use: unsafe extern "C" fn(handle: VCHI_SERVICE_HANDLE_T) -> i32,
    pub vchi_service_release: unsafe extern "C" fn(handle: VCHI_SERVICE_HANDLE_T) -> i32,
    pub vchi_service_set_option: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        option: VCHI_SERVICE_OPTION_T,
        value: ::std::os::raw::c_int,
    ) -> i32,
    pub vchi_msg_queue: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
    pub vchi_msg_queuev: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        vector: *mut VCHI_MSG_VECTOR_T,
        count: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
    pub vchi_msg_dequeue: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut ::std::os::raw::c_void,
        max_data_size_to_read: u32,
        actual_msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
    pub vchi_msg_peek: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
    pub vchi_msg_remove: unsafe extern "C" fn(handle: VCHI_SERVICE_HANDLE_T) -> i32,
    pub vchi_msg_hold: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
        message_descriptor: *mut VCHI_HELD_MSG_T,
    ) -> i32,
    pub vchi_held_msg_release: unsafe extern "C" fn(message: *mut VCHI_HELD_MSG_T) -> i32,
    pub vchi_bulk_queue_receive: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data_dst: *mut ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        transfer_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
    pub vchi_bulk_queue_transmit: unsafe extern "C" fn(
        handle: VCHI_SERVICE_HANDLE_T,
        data_src: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        transfer_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
    pub vchi_mphi_message_driver_func_table: unsafe extern "C" fn() -> *const VCHI_MESSAGE_DRIVER_T,
    pub vc_vchi_gencmd_init: unsafe extern "C" fn(
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ),
    pub vc_gencmd_stop: unsafe extern "C" fn(),
    pub vc_gencmd_send:
        unsafe extern "C" fn(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int,
    pub vc_gencmd_read_response: unsafe extern "C" fn(
        response: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_string_property: unsafe extern "C" fn(
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_number_property: unsafe extern "C" fn(
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        number: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_until: unsafe extern "C" fn(
        cmd: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        error_string: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub bcm_host_get_model_type: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_model_pi4: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_fkms_active: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_kms_active: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_get_processor_id: unsafe extern "C" fn() -> ::std::os::raw::c_int,
}
impl libbcm_host {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let bcm_host_init = __library.get(b"bcm_host_init\0").map(|sym| *sym)?;
        let bcm_host_deinit = __library.get(b"bcm_host_deinit\0").map(|sym| *sym)?;
        let graphics_get_display_size = __library
            .get(b"graphics_get_display_size\0")
            .map(|sym| *sym)?;
        let bcm_host_get_peripheral_address = __library
            .get(b"bcm_host_get_peripheral_address\0")
            .map(|sym| *sym)?;
        let bcm_host_get_peripheral_size = __library
            .get(b"bcm_host_get_peripheral_size\0")
            .map(|sym| *sym)?;
        let bcm_host_get_sdram_address = __library
            .get(b"bcm_host_get_sdram_address\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_logging_assert = __library
            .get(b"vcos_pthreads_logging_assert\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enabled = __library
            .get(b"vcos_verify_bkpts_enabled\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enable = __library
            .get(b"vcos_verify_bkpts_enable\0")
            .map(|sym| *sym)?;
        let vcos_abort = __library.get(b"vcos_abort\0").map(|sym| *sym)?;
        let vcos_backtrace_self = __library.get(b"vcos_backtrace_self\0").map(|sym| *sym)?;
        let vcos_generic_event_flags_create = __library
            .get(b"vcos_generic_event_flags_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_set = __library
            .get(b"vcos_generic_event_flags_set\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_delete = __library
            .get(b"vcos_generic_event_flags_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_get = __library
            .get(b"vcos_generic_event_flags_get\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_init = __library
            .get(b"vcos_generic_blockpool_init\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_create_on_heap = __library
            .get(b"vcos_generic_blockpool_create_on_heap\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_extend = __library
            .get(b"vcos_generic_blockpool_extend\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_alloc = __library
            .get(b"vcos_generic_blockpool_alloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_calloc = __library
            .get(b"vcos_generic_blockpool_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_free = __library
            .get(b"vcos_generic_blockpool_free\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_available_count = __library
            .get(b"vcos_generic_blockpool_available_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_used_count = __library
            .get(b"vcos_generic_blockpool_used_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_delete = __library
            .get(b"vcos_generic_blockpool_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_to_handle = __library
            .get(b"vcos_generic_blockpool_elem_to_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_from_handle = __library
            .get(b"vcos_generic_blockpool_elem_from_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_is_valid_elem = __library
            .get(b"vcos_generic_blockpool_is_valid_elem\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_alloc = __library.get(b"vcos_generic_mem_alloc\0").map(|sym| *sym)?;
        let vcos_generic_mem_calloc = __library
            .get(b"vcos_generic_mem_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_free = __library.get(b"vcos_generic_mem_free\0").map(|sym| *sym)?;
        let vcos_generic_mem_alloc_aligned = __library
            .get(b"vcos_generic_mem_alloc_aligned\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_error = __library
            .get(b"vcos_pthreads_map_error\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_errno = __library
            .get(b"vcos_pthreads_map_errno\0")
            .map(|sym| *sym)?;
        let vcos_thread_at_exit = __library.get(b"vcos_thread_at_exit\0").map(|sym| *sym)?;
        let vcos_dummy_thread_create = __library
            .get(b"vcos_dummy_thread_create\0")
            .map(|sym| *sym)?;
        let vcos_getmicrosecs64_internal = __library
            .get(b"vcos_getmicrosecs64_internal\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_create = __library
            .get(b"vcos_pthreads_timer_create\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_set = __library
            .get(b"vcos_pthreads_timer_set\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_cancel = __library
            .get(b"vcos_pthreads_timer_cancel\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_delete = __library
            .get(b"vcos_pthreads_timer_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_create = __library
            .get(b"vcos_generic_reentrant_mutex_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_delete = __library
            .get(b"vcos_generic_reentrant_mutex_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_lock = __library
            .get(b"vcos_generic_reentrant_mutex_lock\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_unlock = __library
            .get(b"vcos_generic_reentrant_mutex_unlock\0")
            .map(|sym| *sym)?;
        let vcos_generic_named_semaphore_create = __library
            .get(b"vcos_generic_named_semaphore_create\0")
            .map(|sym| *sym)?;
        let vcos_named_semaphore_delete = __library
            .get(b"vcos_named_semaphore_delete\0")
            .map(|sym| *sym)?;
        let vcos_init = __library.get(b"vcos_init\0").map(|sym| *sym)?;
        let vcos_deinit = __library.get(b"vcos_deinit\0").map(|sym| *sym)?;
        let vcos_global_lock = __library.get(b"vcos_global_lock\0").map(|sym| *sym)?;
        let vcos_global_unlock = __library.get(b"vcos_global_unlock\0").map(|sym| *sym)?;
        let vcos_set_args = __library.get(b"vcos_set_args\0").map(|sym| *sym)?;
        let vcos_get_argc = __library.get(b"vcos_get_argc\0").map(|sym| *sym)?;
        let vcos_get_argv = __library.get(b"vcos_get_argv\0").map(|sym| *sym)?;
        let vcos_platform_init = __library.get(b"vcos_platform_init\0").map(|sym| *sym)?;
        let vcos_platform_deinit = __library.get(b"vcos_platform_deinit\0").map(|sym| *sym)?;
        let vcos_have_rtos = __library.get(b"vcos_have_rtos\0").map(|sym| *sym)?;
        let vcos_thread_create = __library.get(b"vcos_thread_create\0").map(|sym| *sym)?;
        let vcos_thread_exit = __library.get(b"vcos_thread_exit\0").map(|sym| *sym)?;
        let vcos_thread_join = __library.get(b"vcos_thread_join\0").map(|sym| *sym)?;
        let vcos_thread_create_classic = __library
            .get(b"vcos_thread_create_classic\0")
            .map(|sym| *sym)?;
        let vcos_thread_get_name = __library.get(b"vcos_thread_get_name\0").map(|sym| *sym)?;
        let vcos_log_level_to_string = __library
            .get(b"vcos_log_level_to_string\0")
            .map(|sym| *sym)?;
        let vcos_string_to_log_level = __library
            .get(b"vcos_string_to_log_level\0")
            .map(|sym| *sym)?;
        let vcos_log_impl = __library.get(b"vcos_log_impl\0").map(|sym| *sym)?;
        let vcos_vlog_impl = __library.get(b"vcos_vlog_impl\0").map(|sym| *sym)?;
        let vcos_set_vlog_impl = __library.get(b"vcos_set_vlog_impl\0").map(|sym| *sym)?;
        let vcos_vlog_default_impl = __library.get(b"vcos_vlog_default_impl\0").map(|sym| *sym)?;
        let vcos_logging_init = __library.get(b"vcos_logging_init\0").map(|sym| *sym)?;
        let vcos_log_register = __library.get(b"vcos_log_register\0").map(|sym| *sym)?;
        let vcos_log_unregister = __library.get(b"vcos_log_unregister\0").map(|sym| *sym)?;
        let vcos_log_get_default_category = __library
            .get(b"vcos_log_get_default_category\0")
            .map(|sym| *sym)?;
        let vcos_set_log_options = __library.get(b"vcos_set_log_options\0").map(|sym| *sym)?;
        let vcos_log_dump_mem_impl = __library.get(b"vcos_log_dump_mem_impl\0").map(|sym| *sym)?;
        let vcos_cmd_error = __library.get(b"vcos_cmd_error\0").map(|sym| *sym)?;
        let vcos_cmd_printf = __library.get(b"vcos_cmd_printf\0").map(|sym| *sym)?;
        let vcos_cmd_vprintf = __library.get(b"vcos_cmd_vprintf\0").map(|sym| *sym)?;
        let vcos_cmd_always_log_output = __library
            .get(b"vcos_cmd_always_log_output\0")
            .map(|sym| *sym)?;
        let vcos_cmd_usage = __library.get(b"vcos_cmd_usage\0").map(|sym| *sym)?;
        let vcos_cmd_register = __library.get(b"vcos_cmd_register\0").map(|sym| *sym)?;
        let vcos_cmd_register_multiple = __library
            .get(b"vcos_cmd_register_multiple\0")
            .map(|sym| *sym)?;
        let vcos_cmd_execute = __library.get(b"vcos_cmd_execute\0").map(|sym| *sym)?;
        let vcos_cmd_shutdown = __library.get(b"vcos_cmd_shutdown\0").map(|sym| *sym)?;
        let vcos_vsnprintf = __library.get(b"vcos_vsnprintf\0").map(|sym| *sym)?;
        let vcos_snprintf = __library.get(b"vcos_snprintf\0").map(|sym| *sym)?;
        let vcos_safe_vsprintf = __library.get(b"vcos_safe_vsprintf\0").map(|sym| *sym)?;
        let vcos_safe_sprintf = __library.get(b"vcos_safe_sprintf\0").map(|sym| *sym)?;
        let vcos_safe_strcpy = __library.get(b"vcos_safe_strcpy\0").map(|sym| *sym)?;
        let vcos_safe_strncpy = __library.get(b"vcos_safe_strncpy\0").map(|sym| *sym)?;
        let vcos_thread_attr_init = __library.get(b"vcos_thread_attr_init\0").map(|sym| *sym)?;
        let vcos_timer_init = __library.get(b"vcos_timer_init\0").map(|sym| *sym)?;
        let vcos_once = __library.get(b"vcos_once\0").map(|sym| *sym)?;
        let vchi_create_connection = __library.get(b"vchi_create_connection\0").map(|sym| *sym)?;
        let vchi_initialise = __library.get(b"vchi_initialise\0").map(|sym| *sym)?;
        let vchi_connect = __library.get(b"vchi_connect\0").map(|sym| *sym)?;
        let vchi_disconnect = __library.get(b"vchi_disconnect\0").map(|sym| *sym)?;
        let vchi_service_create = __library.get(b"vchi_service_create\0").map(|sym| *sym)?;
        let vchi_service_destroy = __library.get(b"vchi_service_destroy\0").map(|sym| *sym)?;
        let vchi_service_open = __library.get(b"vchi_service_open\0").map(|sym| *sym)?;
        let vchi_service_close = __library.get(b"vchi_service_close\0").map(|sym| *sym)?;
        let vchi_service_use = __library.get(b"vchi_service_use\0").map(|sym| *sym)?;
        let vchi_service_release = __library.get(b"vchi_service_release\0").map(|sym| *sym)?;
        let vchi_service_set_option = __library
            .get(b"vchi_service_set_option\0")
            .map(|sym| *sym)?;
        let vchi_msg_queue = __library.get(b"vchi_msg_queue\0").map(|sym| *sym)?;
        let vchi_msg_queuev = __library.get(b"vchi_msg_queuev\0").map(|sym| *sym)?;
        let vchi_msg_dequeue = __library.get(b"vchi_msg_dequeue\0").map(|sym| *sym)?;
        let vchi_msg_peek = __library.get(b"vchi_msg_peek\0").map(|sym| *sym)?;
        let vchi_msg_remove = __library.get(b"vchi_msg_remove\0").map(|sym| *sym)?;
        let vchi_msg_hold = __library.get(b"vchi_msg_hold\0").map(|sym| *sym)?;
        let vchi_held_msg_release = __library.get(b"vchi_held_msg_release\0").map(|sym| *sym)?;
        let vchi_bulk_queue_receive = __library
            .get(b"vchi_bulk_queue_receive\0")
            .map(|sym| *sym)?;
        let vchi_bulk_queue_transmit = __library
            .get(b"vchi_bulk_queue_transmit\0")
            .map(|sym| *sym)?;
        let vchi_mphi_message_driver_func_table = __library
            .get(b"vchi_mphi_message_driver_func_table\0")
            .map(|sym| *sym)?;
        let vc_vchi_gencmd_init = __library.get(b"vc_vchi_gencmd_init\0").map(|sym| *sym)?;
        let vc_gencmd_stop = __library.get(b"vc_gencmd_stop\0").map(|sym| *sym)?;
        let vc_gencmd_send = __library.get(b"vc_gencmd_send\0").map(|sym| *sym)?;
        let vc_gencmd_read_response = __library
            .get(b"vc_gencmd_read_response\0")
            .map(|sym| *sym)?;
        let vc_gencmd_string_property = __library
            .get(b"vc_gencmd_string_property\0")
            .map(|sym| *sym)?;
        let vc_gencmd_number_property = __library
            .get(b"vc_gencmd_number_property\0")
            .map(|sym| *sym)?;
        let vc_gencmd_until = __library.get(b"vc_gencmd_until\0").map(|sym| *sym)?;
        let bcm_host_get_model_type = __library
            .get(b"bcm_host_get_model_type\0")
            .map(|sym| *sym)?;
        let bcm_host_is_model_pi4 = __library.get(b"bcm_host_is_model_pi4\0").map(|sym| *sym)?;
        let bcm_host_is_fkms_active = __library
            .get(b"bcm_host_is_fkms_active\0")
            .map(|sym| *sym)?;
        let bcm_host_is_kms_active = __library.get(b"bcm_host_is_kms_active\0").map(|sym| *sym)?;
        let bcm_host_get_processor_id = __library
            .get(b"bcm_host_get_processor_id\0")
            .map(|sym| *sym)?;
        Ok(libbcm_host {
            __library,
            bcm_host_init,
            bcm_host_deinit,
            graphics_get_display_size,
            bcm_host_get_peripheral_address,
            bcm_host_get_peripheral_size,
            bcm_host_get_sdram_address,
            vcos_pthreads_logging_assert,
            vcos_verify_bkpts_enabled,
            vcos_verify_bkpts_enable,
            vcos_abort,
            vcos_backtrace_self,
            vcos_generic_event_flags_create,
            vcos_generic_event_flags_set,
            vcos_generic_event_flags_delete,
            vcos_generic_event_flags_get,
            vcos_generic_blockpool_init,
            vcos_generic_blockpool_create_on_heap,
            vcos_generic_blockpool_extend,
            vcos_generic_blockpool_alloc,
            vcos_generic_blockpool_calloc,
            vcos_generic_blockpool_free,
            vcos_generic_blockpool_available_count,
            vcos_generic_blockpool_used_count,
            vcos_generic_blockpool_delete,
            vcos_generic_blockpool_elem_to_handle,
            vcos_generic_blockpool_elem_from_handle,
            vcos_generic_blockpool_is_valid_elem,
            vcos_generic_mem_alloc,
            vcos_generic_mem_calloc,
            vcos_generic_mem_free,
            vcos_generic_mem_alloc_aligned,
            vcos_pthreads_map_error,
            vcos_pthreads_map_errno,
            vcos_thread_at_exit,
            vcos_dummy_thread_create,
            vcos_getmicrosecs64_internal,
            vcos_pthreads_timer_create,
            vcos_pthreads_timer_set,
            vcos_pthreads_timer_cancel,
            vcos_pthreads_timer_delete,
            vcos_generic_reentrant_mutex_create,
            vcos_generic_reentrant_mutex_delete,
            vcos_generic_reentrant_mutex_lock,
            vcos_generic_reentrant_mutex_unlock,
            vcos_generic_named_semaphore_create,
            vcos_named_semaphore_delete,
            vcos_init,
            vcos_deinit,
            vcos_global_lock,
            vcos_global_unlock,
            vcos_set_args,
            vcos_get_argc,
            vcos_get_argv,
            vcos_platform_init,
            vcos_platform_deinit,
            vcos_have_rtos,
            vcos_thread_create,
            vcos_thread_exit,
            vcos_thread_join,
            vcos_thread_create_classic,
            vcos_thread_get_name,
            vcos_log_level_to_string,
            vcos_string_to_log_level,
            vcos_log_impl,
            vcos_vlog_impl,
            vcos_set_vlog_impl,
            vcos_vlog_default_impl,
            vcos_logging_init,
            vcos_log_register,
            vcos_log_unregister,
            vcos_log_get_default_category,
            vcos_set_log_options,
            vcos_log_dump_mem_impl,
            vcos_cmd_error,
            vcos_cmd_printf,
            vcos_cmd_vprintf,
            vcos_cmd_always_log_output,
            vcos_cmd_usage,
            vcos_cmd_register,
            vcos_cmd_register_multiple,
            vcos_cmd_execute,
            vcos_cmd_shutdown,
            vcos_vsnprintf,
            vcos_snprintf,
            vcos_safe_vsprintf,
            vcos_safe_sprintf,
            vcos_safe_strcpy,
            vcos_safe_strncpy,
            vcos_thread_attr_init,
            vcos_timer_init,
            vcos_once,
            vchi_create_connection,
            vchi_initialise,
            vchi_connect,
            vchi_disconnect,
            vchi_service_create,
            vchi_service_destroy,
            vchi_service_open,
            vchi_service_close,
            vchi_service_use,
            vchi_service_release,
            vchi_service_set_option,
            vchi_msg_queue,
            vchi_msg_queuev,
            vchi_msg_dequeue,
            vchi_msg_peek,
            vchi_msg_remove,
            vchi_msg_hold,
            vchi_held_msg_release,
            vchi_bulk_queue_receive,
            vchi_bulk_queue_transmit,
            vchi_mphi_message_driver_func_table,
            vc_vchi_gencmd_init,
            vc_gencmd_stop,
            vc_gencmd_send,
            vc_gencmd_read_response,
            vc_gencmd_string_property,
            vc_gencmd_number_property,
            vc_gencmd_until,
            bcm_host_get_model_type,
            bcm_host_is_model_pi4,
            bcm_host_is_fkms_active,
            bcm_host_is_kms_active,
            bcm_host_get_processor_id,
        })
    }
    pub unsafe fn bcm_host_init(&self) -> () {
        (self.bcm_host_init)()
    }
    pub unsafe fn bcm_host_deinit(&self) -> () {
        (self.bcm_host_deinit)()
    }
    pub unsafe fn graphics_get_display_size(
        &self,
        display_number: u16,
        width: *mut u32,
        height: *mut u32,
    ) -> i32 {
        (self.graphics_get_display_size)(display_number, width, height)
    }
    pub unsafe fn bcm_host_get_peripheral_address(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_peripheral_address)()
    }
    pub unsafe fn bcm_host_get_peripheral_size(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_peripheral_size)()
    }
    pub unsafe fn bcm_host_get_sdram_address(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_sdram_address)()
    }
    pub unsafe fn vcos_verify_bkpts_enabled(&self) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enabled)()
    }
    pub unsafe fn vcos_verify_bkpts_enable(
        &self,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enable)(enable)
    }
    pub unsafe fn vcos_abort(&self) -> () {
        (self.vcos_abort)()
    }
    pub unsafe fn vcos_backtrace_self(&self) -> () {
        (self.vcos_backtrace_self)()
    }
    pub unsafe fn vcos_generic_event_flags_create(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_create)(flags, name)
    }
    pub unsafe fn vcos_generic_event_flags_set(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ) -> () {
        (self.vcos_generic_event_flags_set)(flags, events, op)
    }
    pub unsafe fn vcos_generic_event_flags_delete(&self, arg1: *mut VCOS_EVENT_FLAGS_T) -> () {
        (self.vcos_generic_event_flags_delete)(arg1)
    }
    pub unsafe fn vcos_generic_event_flags_get(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_get)(flags, requested_events, op, suspend, retrieved_events)
    }
    pub unsafe fn vcos_generic_blockpool_init(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_init)(
            pool, num_blocks, block_size, start, pool_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_create_on_heap(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_create_on_heap)(
            pool, num_blocks, block_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_extend(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_extend)(pool, num_extensions, num_blocks)
    }
    pub unsafe fn vcos_generic_blockpool_alloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_alloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_calloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_calloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_free(&self, block: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_blockpool_free)(block)
    }
    pub unsafe fn vcos_generic_blockpool_available_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_available_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_used_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_used_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_delete(&self, pool: *mut VCOS_BLOCKPOOL_T) -> () {
        (self.vcos_generic_blockpool_delete)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_elem_to_handle(
        &self,
        block: *mut ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_elem_to_handle)(block)
    }
    pub unsafe fn vcos_generic_blockpool_elem_from_handle(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        handle: u32,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_elem_from_handle)(pool, handle)
    }
    pub unsafe fn vcos_generic_blockpool_is_valid_elem(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_is_valid_elem)(pool, block)
    }
    pub unsafe fn vcos_generic_mem_alloc(
        &self,
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc)(sz, desc)
    }
    pub unsafe fn vcos_generic_mem_calloc(
        &self,
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_calloc)(count, sz, descr)
    }
    pub unsafe fn vcos_generic_mem_free(&self, ptr: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_mem_free)(ptr)
    }
    pub unsafe fn vcos_generic_mem_alloc_aligned(
        &self,
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc_aligned)(sz, align, desc)
    }
    pub unsafe fn vcos_pthreads_map_error(&self, error: ::std::os::raw::c_int) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_error)(error)
    }
    pub unsafe fn vcos_pthreads_map_errno(&self) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_errno)()
    }
    pub unsafe fn vcos_thread_at_exit(
        &self,
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_at_exit)(pfn, cxt)
    }
    pub unsafe fn vcos_dummy_thread_create(&self) -> *mut VCOS_THREAD_T {
        (self.vcos_dummy_thread_create)()
    }
    pub unsafe fn vcos_getmicrosecs64_internal(&self) -> u64 {
        (self.vcos_getmicrosecs64_internal)()
    }
    pub unsafe fn vcos_pthreads_timer_create(
        &self,
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_pthreads_timer_create)(timer, name, expiration_routine, context)
    }
    pub unsafe fn vcos_pthreads_timer_set(
        &self,
        timer: *mut VCOS_TIMER_T,
        delay_ms: VCOS_UNSIGNED,
    ) -> () {
        (self.vcos_pthreads_timer_set)(timer, delay_ms)
    }
    pub unsafe fn vcos_pthreads_timer_cancel(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_cancel)(timer)
    }
    pub unsafe fn vcos_pthreads_timer_delete(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_delete)(timer)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_create(
        &self,
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_reentrant_mutex_create)(m, name)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_delete(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_delete)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_lock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_lock)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_unlock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_unlock)(m)
    }
    pub unsafe fn vcos_generic_named_semaphore_create(
        &self,
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_named_semaphore_create)(sem, name, count)
    }
    pub unsafe fn vcos_named_semaphore_delete(&self, sem: *mut VCOS_NAMED_SEMAPHORE_T) -> () {
        (self.vcos_named_semaphore_delete)(sem)
    }
    pub unsafe fn vcos_init(&self) -> VCOS_STATUS_T {
        (self.vcos_init)()
    }
    pub unsafe fn vcos_deinit(&self) -> () {
        (self.vcos_deinit)()
    }
    pub unsafe fn vcos_global_lock(&self) -> () {
        (self.vcos_global_lock)()
    }
    pub unsafe fn vcos_global_unlock(&self) -> () {
        (self.vcos_global_unlock)()
    }
    pub unsafe fn vcos_set_args(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> () {
        (self.vcos_set_args)(argc, argv)
    }
    pub unsafe fn vcos_get_argc(&self) -> ::std::os::raw::c_int {
        (self.vcos_get_argc)()
    }
    pub unsafe fn vcos_get_argv(&self) -> *mut *const ::std::os::raw::c_char {
        (self.vcos_get_argv)()
    }
    pub unsafe fn vcos_platform_init(&self) -> VCOS_STATUS_T {
        (self.vcos_platform_init)()
    }
    pub unsafe fn vcos_platform_deinit(&self) -> () {
        (self.vcos_platform_deinit)()
    }
    pub unsafe fn vcos_have_rtos(&self) -> ::std::os::raw::c_int {
        (self.vcos_have_rtos)()
    }
    pub unsafe fn vcos_thread_create(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create)(thread, name, attrs, entry, arg)
    }
    pub unsafe fn vcos_thread_exit(&self, data: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_thread_exit)(data)
    }
    pub unsafe fn vcos_thread_join(
        &self,
        thread: *mut VCOS_THREAD_T,
        pData: *mut *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vcos_thread_join)(thread, pData)
    }
    pub unsafe fn vcos_thread_create_classic(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create_classic)(
            thread, name, entry, arg, stack, stacksz, priaff, timeslice, autostart,
        )
    }
    pub unsafe fn vcos_thread_get_name(
        &self,
        thread: *const VCOS_THREAD_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_thread_get_name)(thread)
    }
    pub unsafe fn vcos_log_level_to_string(
        &self,
        level: VCOS_LOG_LEVEL_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_log_level_to_string)(level)
    }
    pub unsafe fn vcos_string_to_log_level(
        &self,
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T {
        (self.vcos_string_to_log_level)(str_, level)
    }
    pub unsafe fn vcos_vlog_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_set_vlog_impl(&self, vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T) -> () {
        (self.vcos_set_vlog_impl)(vlog_impl_func)
    }
    pub unsafe fn vcos_vlog_default_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_default_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_logging_init(&self) -> () {
        (self.vcos_logging_init)()
    }
    pub unsafe fn vcos_log_register(
        &self,
        name: *const ::std::os::raw::c_char,
        category: *mut VCOS_LOG_CAT_T,
    ) -> () {
        (self.vcos_log_register)(name, category)
    }
    pub unsafe fn vcos_log_unregister(&self, category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_log_unregister)(category)
    }
    pub unsafe fn vcos_log_get_default_category(&self) -> *const VCOS_LOG_CAT_T {
        (self.vcos_log_get_default_category)()
    }
    pub unsafe fn vcos_set_log_options(&self, opt: *const ::std::os::raw::c_char) -> () {
        (self.vcos_set_log_options)(opt)
    }
    pub unsafe fn vcos_log_dump_mem_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ) -> () {
        (self.vcos_log_dump_mem_impl)(cat, label, addr, voidMem, numBytes)
    }
    pub unsafe fn vcos_cmd_vprintf(
        &self,
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_cmd_vprintf)(param, fmt, args)
    }
    pub unsafe fn vcos_cmd_always_log_output(&self, log_category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_cmd_always_log_output)(log_category)
    }
    pub unsafe fn vcos_cmd_usage(&self, param: *mut VCOS_CMD_PARAM_T) -> () {
        (self.vcos_cmd_usage)(param)
    }
    pub unsafe fn vcos_cmd_register(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_register_multiple(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register_multiple)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_execute(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_cmd_execute)(argc, argv, result_size, result_buf)
    }
    pub unsafe fn vcos_cmd_shutdown(&self) -> () {
        (self.vcos_cmd_shutdown)()
    }
    pub unsafe fn vcos_vsnprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int {
        (self.vcos_vsnprintf)(buf, buflen, fmt, ap)
    }
    pub unsafe fn vcos_safe_vsprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t {
        (self.vcos_safe_vsprintf)(buf, buflen, offset, fmt, ap)
    }
    pub unsafe fn vcos_safe_strcpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strcpy)(dst, src, dstlen, offset)
    }
    pub unsafe fn vcos_safe_strncpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strncpy)(dst, src, srclen, dstlen, offset)
    }
    pub unsafe fn vcos_thread_attr_init(&self, attrs: *mut VCOS_THREAD_ATTR_T) -> () {
        (self.vcos_thread_attr_init)(attrs)
    }
    pub unsafe fn vcos_timer_init(&self) -> VCOS_STATUS_T {
        (self.vcos_timer_init)()
    }
    pub unsafe fn vcos_once(
        &self,
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T {
        (self.vcos_once)(once_control, init_routine)
    }
    pub unsafe fn vchi_create_connection(
        &self,
        function_table: *const VCHI_CONNECTION_API_T,
        low_level: *const VCHI_MESSAGE_DRIVER_T,
    ) -> *mut VCHI_CONNECTION_T {
        (self.vchi_create_connection)(function_table, low_level)
    }
    pub unsafe fn vchi_initialise(&self, instance_handle: *mut VCHI_INSTANCE_T) -> i32 {
        (self.vchi_initialise)(instance_handle)
    }
    pub unsafe fn vchi_connect(
        &self,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
        instance_handle: VCHI_INSTANCE_T,
    ) -> i32 {
        (self.vchi_connect)(connections, num_connections, instance_handle)
    }
    pub unsafe fn vchi_disconnect(&self, instance_handle: VCHI_INSTANCE_T) -> i32 {
        (self.vchi_disconnect)(instance_handle)
    }
    pub unsafe fn vchi_service_create(
        &self,
        instance_handle: VCHI_INSTANCE_T,
        setup: *mut SERVICE_CREATION_T,
        handle: *mut VCHI_SERVICE_HANDLE_T,
    ) -> i32 {
        (self.vchi_service_create)(instance_handle, setup, handle)
    }
    pub unsafe fn vchi_service_destroy(&self, handle: VCHI_SERVICE_HANDLE_T) -> i32 {
        (self.vchi_service_destroy)(handle)
    }
    pub unsafe fn vchi_service_open(
        &self,
        instance_handle: VCHI_INSTANCE_T,
        setup: *mut SERVICE_CREATION_T,
        handle: *mut VCHI_SERVICE_HANDLE_T,
    ) -> i32 {
        (self.vchi_service_open)(instance_handle, setup, handle)
    }
    pub unsafe fn vchi_service_close(&self, handle: VCHI_SERVICE_HANDLE_T) -> i32 {
        (self.vchi_service_close)(handle)
    }
    pub unsafe fn vchi_service_use(&self, handle: VCHI_SERVICE_HANDLE_T) -> i32 {
        (self.vchi_service_use)(handle)
    }
    pub unsafe fn vchi_service_release(&self, handle: VCHI_SERVICE_HANDLE_T) -> i32 {
        (self.vchi_service_release)(handle)
    }
    pub unsafe fn vchi_service_set_option(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        option: VCHI_SERVICE_OPTION_T,
        value: ::std::os::raw::c_int,
    ) -> i32 {
        (self.vchi_service_set_option)(handle, option, value)
    }
    pub unsafe fn vchi_msg_queue(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32 {
        (self.vchi_msg_queue)(handle, data, data_size, flags, msg_handle)
    }
    pub unsafe fn vchi_msg_queuev(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        vector: *mut VCHI_MSG_VECTOR_T,
        count: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32 {
        (self.vchi_msg_queuev)(handle, vector, count, flags, msg_handle)
    }
    pub unsafe fn vchi_msg_dequeue(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut ::std::os::raw::c_void,
        max_data_size_to_read: u32,
        actual_msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32 {
        (self.vchi_msg_dequeue)(handle, data, max_data_size_to_read, actual_msg_size, flags)
    }
    pub unsafe fn vchi_msg_peek(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32 {
        (self.vchi_msg_peek)(handle, data, msg_size, flags)
    }
    pub unsafe fn vchi_msg_remove(&self, handle: VCHI_SERVICE_HANDLE_T) -> i32 {
        (self.vchi_msg_remove)(handle)
    }
    pub unsafe fn vchi_msg_hold(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
        message_descriptor: *mut VCHI_HELD_MSG_T,
    ) -> i32 {
        (self.vchi_msg_hold)(handle, data, msg_size, flags, message_descriptor)
    }
    pub unsafe fn vchi_held_msg_release(&self, message: *mut VCHI_HELD_MSG_T) -> i32 {
        (self.vchi_held_msg_release)(message)
    }
    pub unsafe fn vchi_bulk_queue_receive(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data_dst: *mut ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        transfer_handle: *mut ::std::os::raw::c_void,
    ) -> i32 {
        (self.vchi_bulk_queue_receive)(handle, data_dst, data_size, flags, transfer_handle)
    }
    pub unsafe fn vchi_bulk_queue_transmit(
        &self,
        handle: VCHI_SERVICE_HANDLE_T,
        data_src: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        transfer_handle: *mut ::std::os::raw::c_void,
    ) -> i32 {
        (self.vchi_bulk_queue_transmit)(handle, data_src, data_size, flags, transfer_handle)
    }
    pub unsafe fn vchi_mphi_message_driver_func_table(&self) -> *const VCHI_MESSAGE_DRIVER_T {
        (self.vchi_mphi_message_driver_func_table)()
    }
    pub unsafe fn vc_vchi_gencmd_init(
        &self,
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> () {
        (self.vc_vchi_gencmd_init)(initialise_instance, connections, num_connections)
    }
    pub unsafe fn vc_gencmd_stop(&self) -> () {
        (self.vc_gencmd_stop)()
    }
    pub unsafe fn vc_gencmd_read_response(
        &self,
        response: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_read_response)(response, maxlen)
    }
    pub unsafe fn vc_gencmd_string_property(
        &self,
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_string_property)(text, property, value, length)
    }
    pub unsafe fn vc_gencmd_number_property(
        &self,
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        number: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_number_property)(text, property, number)
    }
    pub unsafe fn vc_gencmd_until(
        &self,
        cmd: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        error_string: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_until)(cmd, property, value, error_string, timeout)
    }
    pub unsafe fn bcm_host_get_model_type(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_get_model_type)()
    }
    pub unsafe fn bcm_host_is_model_pi4(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_model_pi4)()
    }
    pub unsafe fn bcm_host_is_fkms_active(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_fkms_active)()
    }
    pub unsafe fn bcm_host_is_kms_active(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_kms_active)()
    }
    pub unsafe fn bcm_host_get_processor_id(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_get_processor_id)()
    }
}
