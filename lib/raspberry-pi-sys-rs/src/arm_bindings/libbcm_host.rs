/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const BCM_HOST_BOARD_TYPE_MODELA: u32 = 0;
pub const BCM_HOST_BOARD_TYPE_MODELB: u32 = 1;
pub const BCM_HOST_BOARD_TYPE_MODELAPLUS: u32 = 2;
pub const BCM_HOST_BOARD_TYPE_MODELBPLUS: u32 = 3;
pub const BCM_HOST_BOARD_TYPE_PI2MODELB: u32 = 4;
pub const BCM_HOST_BOARD_TYPE_ALPHA: u32 = 5;
pub const BCM_HOST_BOARD_TYPE_CM: u32 = 6;
pub const BCM_HOST_BOARD_TYPE_CM2: u32 = 7;
pub const BCM_HOST_BOARD_TYPE_PI3MODELB: u32 = 8;
pub const BCM_HOST_BOARD_TYPE_PI0: u32 = 9;
pub const BCM_HOST_BOARD_TYPE_CM3: u32 = 10;
pub const BCM_HOST_BOARD_TYPE_CUSTOM: u32 = 11;
pub const BCM_HOST_BOARD_TYPE_PI0W: u32 = 12;
pub const BCM_HOST_BOARD_TYPE_PI3MODELBPLUS: u32 = 13;
pub const BCM_HOST_BOARD_TYPE_PI3MODELAPLUS: u32 = 14;
pub const BCM_HOST_BOARD_TYPE_FPGA: u32 = 15;
pub const BCM_HOST_BOARD_TYPE_CM3PLUS: u32 = 16;
pub const BCM_HOST_BOARD_TYPE_PI4MODELB: u32 = 17;
pub const BCM_HOST_BOARD_TYPE_PI400: u32 = 19;
pub const BCM_HOST_BOARD_TYPE_CM4: u32 = 20;
pub const BCM_HOST_PROCESSOR_BCM2835: u32 = 0;
pub const BCM_HOST_PROCESSOR_BCM2836: u32 = 1;
pub const BCM_HOST_PROCESSOR_BCM2837: u32 = 2;
pub const BCM_HOST_PROCESSOR_BCM2838: u32 = 3;
pub const BCM_HOST_PROCESSOR_BCM2711: u32 = 3;
pub const GENCMDSERVICE_MSGFIFO_SIZE: u32 = 4092;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type size_t = ::std::os::raw::c_uint;
pub type VCOS_THREAD_ENTRY_FN_T = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub const VCOS_STATUS_T_VCOS_SUCCESS: VCOS_STATUS_T = 0;
pub const VCOS_STATUS_T_VCOS_EAGAIN: VCOS_STATUS_T = 1;
pub const VCOS_STATUS_T_VCOS_ENOENT: VCOS_STATUS_T = 2;
pub const VCOS_STATUS_T_VCOS_ENOSPC: VCOS_STATUS_T = 3;
pub const VCOS_STATUS_T_VCOS_EINVAL: VCOS_STATUS_T = 4;
pub const VCOS_STATUS_T_VCOS_EACCESS: VCOS_STATUS_T = 5;
pub const VCOS_STATUS_T_VCOS_ENOMEM: VCOS_STATUS_T = 6;
pub const VCOS_STATUS_T_VCOS_ENOSYS: VCOS_STATUS_T = 7;
pub const VCOS_STATUS_T_VCOS_EEXIST: VCOS_STATUS_T = 8;
pub const VCOS_STATUS_T_VCOS_ENXIO: VCOS_STATUS_T = 9;
pub const VCOS_STATUS_T_VCOS_EINTR: VCOS_STATUS_T = 10;
pub type VCOS_STATUS_T = ::std::os::raw::c_uint;
pub type vcos_bool_t = i32;
pub type vcos_fourcc_t = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__spins as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 16usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        16usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type VCOS_SEMAPHORE_T = sem_t;
pub type VCOS_UNSIGNED = u32;
pub type VCOS_OPTION = u32;
pub type VCOS_ONCE_T = pthread_once_t;
pub type VCOS_MUTEX_T = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_TIMER_T {
    pub thread: pthread_t,
    pub lock: pthread_mutex_t,
    pub settings_changed: pthread_cond_t,
    pub quit: ::std::os::raw::c_int,
    pub expires: timespec,
    pub orig_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_TIMER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_TIMER_T>(),
        104usize,
        concat!("Size of: ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_TIMER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).settings_changed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(settings_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).quit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).expires as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_expiration_routine as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_context as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_ATTR_T {
    pub ta_stackaddr: *mut ::std::os::raw::c_void,
    pub ta_stacksz: VCOS_UNSIGNED,
    pub ta_priority: VCOS_UNSIGNED,
    pub ta_affinity: VCOS_UNSIGNED,
    pub ta_timeslice: VCOS_UNSIGNED,
    pub legacy: VCOS_UNSIGNED,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_ATTR_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_ATTR_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_ATTR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stackaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stacksz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stacksz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_priority as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_affinity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_timeslice as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_timeslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).legacy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(legacy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_EXIT_T {
    pub pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cxt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_EXIT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_EXIT_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_EXIT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).cxt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(cxt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_THREAD_T {
    pub thread: pthread_t,
    pub entry: VCOS_THREAD_ENTRY_FN_T,
    pub arg: *mut ::std::os::raw::c_void,
    pub suspend: VCOS_SEMAPHORE_T,
    pub task_timer: VCOS_TIMER_T,
    pub task_timer_created: ::std::os::raw::c_int,
    pub orig_task_timer_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_task_timer_context: *mut ::std::os::raw::c_void,
    pub legacy: VCOS_UNSIGNED,
    pub name: [::std::os::raw::c_char; 16usize],
    pub dummy: VCOS_UNSIGNED,
    pub at_exit: [VCOS_THREAD_EXIT_T; 4usize],
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_T>(),
        208usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).entry as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).suspend as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer_created as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer_created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_expiration_routine as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_expiration_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_context as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).legacy as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).dummy as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).at_exit as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(at_exit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_WAITER_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T {
    pub events: VCOS_UNSIGNED,
    pub lock: VCOS_MUTEX_T,
    pub waiters: VCOS_EVENT_FLAGS_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 {
    pub head: *mut VCOS_EVENT_WAITER_T,
    pub tail: *mut VCOS_EVENT_WAITER_T,
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).tail as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).waiters as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(waiters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_HEADER_TAG {
    pub owner: VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    pub next: *mut VCOS_BLOCKPOOL_HEADER_TAG,
    pub subpool: *mut VCOS_BLOCKPOOL_SUBPOOL_TAG,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).subpool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(subpool)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG),
            "::",
            stringify!(owner)
        )
    );
}
pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG {
    pub magic: u32,
    pub free_list: *mut VCOS_BLOCKPOOL_HEADER_T,
    pub mem: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    pub num_blocks: VCOS_UNSIGNED,
    pub available_blocks: VCOS_UNSIGNED,
    pub owner: *mut VCOS_BLOCKPOOL_TAG,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).free_list as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).start as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).num_blocks as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).available_blocks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(available_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).owner as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
}
pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_TAG {
    pub magic: u32,
    pub mutex: VCOS_MUTEX_T,
    pub align: VCOS_UNSIGNED,
    pub flags: VCOS_UNSIGNED,
    pub block_data_size: size_t,
    pub block_size: size_t,
    pub name: *const ::std::os::raw::c_char,
    pub num_subpools: VCOS_UNSIGNED,
    pub num_extension_blocks: VCOS_UNSIGNED,
    pub subpools: [VCOS_BLOCKPOOL_SUBPOOL_T; 8usize],
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_TAG>(),
        344usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).mutex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).align as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_data_size as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).name as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_subpools as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_subpools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_extension_blocks as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_extension_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).subpools as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(subpools)
        )
    );
}
pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_REENTRANT_MUTEX_T {
    pub mutex: VCOS_MUTEX_T,
    pub owner: *mut VCOS_THREAD_T,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_REENTRANT_MUTEX_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_REENTRANT_MUTEX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).owner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_T {
    pub actual: *mut VCOS_NAMED_SEMAPHORE_IMPL_T,
    pub sem: *mut VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_NAMED_SEMAPHORE_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_NAMED_SEMAPHORE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).actual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).sem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(sem)
        )
    );
}
pub type va_list = u32;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED: VCOS_LOG_LEVEL_T = 0;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER: VCOS_LOG_LEVEL_T = 1;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR: VCOS_LOG_LEVEL_T = 2;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN: VCOS_LOG_LEVEL_T = 3;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO: VCOS_LOG_LEVEL_T = 4;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE: VCOS_LOG_LEVEL_T = 5;
pub type VCOS_LOG_LEVEL_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T {
    pub level: VCOS_LOG_LEVEL_T,
    pub name: *const ::std::os::raw::c_char,
    pub next: *mut VCOS_LOG_CAT_T,
    pub flags: VCOS_LOG_CAT_T__bindgen_ty_1,
    pub refcount: ::std::os::raw::c_uint,
    pub platform_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
}
impl VCOS_LOG_CAT_T__bindgen_ty_1 {
    #[inline]
    pub fn want_prefix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_prefix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_prefix: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_prefix: u32 = unsafe { ::std::mem::transmute(want_prefix) };
            want_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).platform_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(platform_data)
        )
    );
}
pub type VCOS_VLOG_IMPL_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
pub type VCOS_CMD_T = VCOS_CMD_S;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_PARAM_T {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub argv_orig: *mut *mut ::std::os::raw::c_char,
    pub cmd_entry: *mut VCOS_CMD_T,
    pub cmd_parent_entry: *mut VCOS_CMD_T,
    pub use_log: ::std::os::raw::c_int,
    pub result_size: size_t,
    pub result_ptr: *mut ::std::os::raw::c_char,
    pub result_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_PARAM_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_PARAM_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_PARAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv_orig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv_orig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_parent_entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_parent_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).use_log as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(use_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_ptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_buf)
        )
    );
}
pub type VCOS_CMD_FUNC_T =
    ::std::option::Option<unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_S {
    pub name: *const ::std::os::raw::c_char,
    pub args: *const ::std::os::raw::c_char,
    pub cmd_fn: VCOS_CMD_FUNC_T,
    pub sub_cmd_entry: *mut VCOS_CMD_T,
    pub descr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_S() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_S>(),
        20usize,
        concat!("Size of: ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_S>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).args as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).cmd_fn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(cmd_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).sub_cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(sub_cmd_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).descr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(descr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tag_VC_RECT_T {
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
}
#[test]
fn bindgen_test_layout_tag_VC_RECT_T() {
    assert_eq!(
        ::std::mem::size_of::<tag_VC_RECT_T>(),
        16usize,
        concat!("Size of: ", stringify!(tag_VC_RECT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<tag_VC_RECT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(tag_VC_RECT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tag_VC_RECT_T>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_VC_RECT_T),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tag_VC_RECT_T>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_VC_RECT_T),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tag_VC_RECT_T>())).width as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_VC_RECT_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tag_VC_RECT_T>())).height as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tag_VC_RECT_T),
            "::",
            stringify!(height)
        )
    );
}
pub type VC_RECT_T = tag_VC_RECT_T;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_MIN: VC_IMAGE_TYPE_T = 0;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGB565: VC_IMAGE_TYPE_T = 1;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_1BPP: VC_IMAGE_TYPE_T = 2;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV420: VC_IMAGE_TYPE_T = 3;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_48BPP: VC_IMAGE_TYPE_T = 4;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGB888: VC_IMAGE_TYPE_T = 5;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_8BPP: VC_IMAGE_TYPE_T = 6;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_4BPP: VC_IMAGE_TYPE_T = 7;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_3D32: VC_IMAGE_TYPE_T = 8;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_3D32B: VC_IMAGE_TYPE_T = 9;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_3D32MAT: VC_IMAGE_TYPE_T = 10;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGB2X9: VC_IMAGE_TYPE_T = 11;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGB666: VC_IMAGE_TYPE_T = 12;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_PAL4_OBSOLETE: VC_IMAGE_TYPE_T = 13;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_PAL8_OBSOLETE: VC_IMAGE_TYPE_T = 14;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBA32: VC_IMAGE_TYPE_T = 15;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422: VC_IMAGE_TYPE_T = 16;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBA565: VC_IMAGE_TYPE_T = 17;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBA16: VC_IMAGE_TYPE_T = 18;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV_UV: VC_IMAGE_TYPE_T = 19;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_RGBA32: VC_IMAGE_TYPE_T = 20;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_RGBX32: VC_IMAGE_TYPE_T = 21;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_FLOAT: VC_IMAGE_TYPE_T = 22;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_RGBA16: VC_IMAGE_TYPE_T = 23;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_RGBA5551: VC_IMAGE_TYPE_T = 24;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_RGB565: VC_IMAGE_TYPE_T = 25;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_YA88: VC_IMAGE_TYPE_T = 26;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_BYTE: VC_IMAGE_TYPE_T = 27;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_PAL8: VC_IMAGE_TYPE_T = 28;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_PAL4: VC_IMAGE_TYPE_T = 29;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_ETC1: VC_IMAGE_TYPE_T = 30;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_BGR888: VC_IMAGE_TYPE_T = 31;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_BGR888_NP: VC_IMAGE_TYPE_T = 32;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_BAYER: VC_IMAGE_TYPE_T = 33;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_CODEC: VC_IMAGE_TYPE_T = 34;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV_UV32: VC_IMAGE_TYPE_T = 35;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_Y8: VC_IMAGE_TYPE_T = 36;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_A8: VC_IMAGE_TYPE_T = 37;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_SHORT: VC_IMAGE_TYPE_T = 38;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_1BPP: VC_IMAGE_TYPE_T = 39;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_OPENGL: VC_IMAGE_TYPE_T = 40;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV444I: VC_IMAGE_TYPE_T = 41;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422PLANAR: VC_IMAGE_TYPE_T = 42;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_ARGB8888: VC_IMAGE_TYPE_T = 43;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_XRGB8888: VC_IMAGE_TYPE_T = 44;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422YUYV: VC_IMAGE_TYPE_T = 45;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422YVYU: VC_IMAGE_TYPE_T = 46;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422UYVY: VC_IMAGE_TYPE_T = 47;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV422VYUY: VC_IMAGE_TYPE_T = 48;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBX32: VC_IMAGE_TYPE_T = 49;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBX8888: VC_IMAGE_TYPE_T = 50;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_BGRX8888: VC_IMAGE_TYPE_T = 51;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV420SP: VC_IMAGE_TYPE_T = 52;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV444PLANAR: VC_IMAGE_TYPE_T = 53;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_U8: VC_IMAGE_TYPE_T = 54;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_TF_V8: VC_IMAGE_TYPE_T = 55;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV420_16: VC_IMAGE_TYPE_T = 56;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV_UV_16: VC_IMAGE_TYPE_T = 57;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV420_S: VC_IMAGE_TYPE_T = 58;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_YUV10COL: VC_IMAGE_TYPE_T = 59;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_RGBA1010102: VC_IMAGE_TYPE_T = 60;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_MAX: VC_IMAGE_TYPE_T = 61;
pub const VC_IMAGE_TYPE_T_VC_IMAGE_FORCE_ENUM_16BIT: VC_IMAGE_TYPE_T = 65535;
pub type VC_IMAGE_TYPE_T = ::std::os::raw::c_uint;
pub const VCOS_DISPLAY_INPUT_FORMAT_T_VCOS_DISPLAY_INPUT_FORMAT_INVALID:
    VCOS_DISPLAY_INPUT_FORMAT_T = 0;
pub const VCOS_DISPLAY_INPUT_FORMAT_T_VCOS_DISPLAY_INPUT_FORMAT_RGB888:
    VCOS_DISPLAY_INPUT_FORMAT_T = 1;
pub const VCOS_DISPLAY_INPUT_FORMAT_T_VCOS_DISPLAY_INPUT_FORMAT_RGB565:
    VCOS_DISPLAY_INPUT_FORMAT_T = 2;
pub type VCOS_DISPLAY_INPUT_FORMAT_T = ::std::os::raw::c_uint;
pub use self::VCOS_DISPLAY_INPUT_FORMAT_T as DISPLAY_INPUT_FORMAT_T;
pub type DISPMANX_DISPLAY_HANDLE_T = u32;
pub type DISPMANX_UPDATE_HANDLE_T = u32;
pub type DISPMANX_ELEMENT_HANDLE_T = u32;
pub type DISPMANX_RESOURCE_HANDLE_T = u32;
pub type DISPMANX_PROTECTION_T = u32;
pub const DISPMANX_TRANSFORM_T_DISPMANX_NO_ROTATE: DISPMANX_TRANSFORM_T = 0;
pub const DISPMANX_TRANSFORM_T_DISPMANX_ROTATE_90: DISPMANX_TRANSFORM_T = 1;
pub const DISPMANX_TRANSFORM_T_DISPMANX_ROTATE_180: DISPMANX_TRANSFORM_T = 2;
pub const DISPMANX_TRANSFORM_T_DISPMANX_ROTATE_270: DISPMANX_TRANSFORM_T = 3;
pub const DISPMANX_TRANSFORM_T_DISPMANX_FLIP_HRIZ: DISPMANX_TRANSFORM_T = 65536;
pub const DISPMANX_TRANSFORM_T_DISPMANX_FLIP_VERT: DISPMANX_TRANSFORM_T = 131072;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_INVERT: DISPMANX_TRANSFORM_T = 524288;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_NONE: DISPMANX_TRANSFORM_T = 0;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_MONO: DISPMANX_TRANSFORM_T = 1048576;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_SBS: DISPMANX_TRANSFORM_T = 2097152;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_TB: DISPMANX_TRANSFORM_T = 3145728;
pub const DISPMANX_TRANSFORM_T_DISPMANX_STEREOSCOPIC_MASK: DISPMANX_TRANSFORM_T = 15728640;
pub const DISPMANX_TRANSFORM_T_DISPMANX_SNAPSHOT_NO_YUV: DISPMANX_TRANSFORM_T = 16777216;
pub const DISPMANX_TRANSFORM_T_DISPMANX_SNAPSHOT_NO_RGB: DISPMANX_TRANSFORM_T = 33554432;
pub const DISPMANX_TRANSFORM_T_DISPMANX_SNAPSHOT_FILL: DISPMANX_TRANSFORM_T = 67108864;
pub const DISPMANX_TRANSFORM_T_DISPMANX_SNAPSHOT_SWAP_RED_BLUE: DISPMANX_TRANSFORM_T = 134217728;
pub const DISPMANX_TRANSFORM_T_DISPMANX_SNAPSHOT_PACK: DISPMANX_TRANSFORM_T = 268435456;
pub type DISPMANX_TRANSFORM_T = ::std::os::raw::c_uint;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_FROM_SOURCE: DISPMANX_FLAGS_ALPHA_T = 0;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_FIXED_ALL_PIXELS: DISPMANX_FLAGS_ALPHA_T = 1;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_FIXED_NON_ZERO: DISPMANX_FLAGS_ALPHA_T = 2;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_FIXED_EXCEED_0X07: DISPMANX_FLAGS_ALPHA_T = 3;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_PREMULT: DISPMANX_FLAGS_ALPHA_T = 65536;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_MIX: DISPMANX_FLAGS_ALPHA_T = 131072;
pub const DISPMANX_FLAGS_ALPHA_T_DISPMANX_FLAGS_ALPHA_DISCARD_LOWER_LAYERS: DISPMANX_FLAGS_ALPHA_T =
    262144;
pub type DISPMANX_FLAGS_ALPHA_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VC_DISPMANX_ALPHA_T {
    pub flags: DISPMANX_FLAGS_ALPHA_T,
    pub opacity: u32,
    pub mask: DISPMANX_RESOURCE_HANDLE_T,
}
#[test]
fn bindgen_test_layout_VC_DISPMANX_ALPHA_T() {
    assert_eq!(
        ::std::mem::size_of::<VC_DISPMANX_ALPHA_T>(),
        12usize,
        concat!("Size of: ", stringify!(VC_DISPMANX_ALPHA_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VC_DISPMANX_ALPHA_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VC_DISPMANX_ALPHA_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_DISPMANX_ALPHA_T>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_DISPMANX_ALPHA_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_DISPMANX_ALPHA_T>())).opacity as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_DISPMANX_ALPHA_T),
            "::",
            stringify!(opacity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_DISPMANX_ALPHA_T>())).mask as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_DISPMANX_ALPHA_T),
            "::",
            stringify!(mask)
        )
    );
}
pub const DISPMANX_FLAGS_CLAMP_T_DISPMANX_FLAGS_CLAMP_NONE: DISPMANX_FLAGS_CLAMP_T = 0;
pub const DISPMANX_FLAGS_CLAMP_T_DISPMANX_FLAGS_CLAMP_LUMA_TRANSPARENT: DISPMANX_FLAGS_CLAMP_T = 1;
pub const DISPMANX_FLAGS_CLAMP_T_DISPMANX_FLAGS_CLAMP_CHROMA_TRANSPARENT: DISPMANX_FLAGS_CLAMP_T =
    2;
pub const DISPMANX_FLAGS_CLAMP_T_DISPMANX_FLAGS_CLAMP_TRANSPARENT: DISPMANX_FLAGS_CLAMP_T = 3;
pub type DISPMANX_FLAGS_CLAMP_T = ::std::os::raw::c_uint;
pub const DISPMANX_FLAGS_KEYMASK_T_DISPMANX_FLAGS_KEYMASK_OVERRIDE: DISPMANX_FLAGS_KEYMASK_T = 1;
pub const DISPMANX_FLAGS_KEYMASK_T_DISPMANX_FLAGS_KEYMASK_SMOOTH: DISPMANX_FLAGS_KEYMASK_T = 2;
pub const DISPMANX_FLAGS_KEYMASK_T_DISPMANX_FLAGS_KEYMASK_CR_INV: DISPMANX_FLAGS_KEYMASK_T = 4;
pub const DISPMANX_FLAGS_KEYMASK_T_DISPMANX_FLAGS_KEYMASK_CB_INV: DISPMANX_FLAGS_KEYMASK_T = 8;
pub const DISPMANX_FLAGS_KEYMASK_T_DISPMANX_FLAGS_KEYMASK_YY_INV: DISPMANX_FLAGS_KEYMASK_T = 16;
pub type DISPMANX_FLAGS_KEYMASK_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union DISPMANX_CLAMP_KEYS_T {
    pub yuv: DISPMANX_CLAMP_KEYS_T__bindgen_ty_1,
    pub rgb: DISPMANX_CLAMP_KEYS_T__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPMANX_CLAMP_KEYS_T__bindgen_ty_1 {
    pub yy_upper: u8,
    pub yy_lower: u8,
    pub cr_upper: u8,
    pub cr_lower: u8,
    pub cb_upper: u8,
    pub cb_lower: u8,
}
#[test]
fn bindgen_test_layout_DISPMANX_CLAMP_KEYS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>(),
        6usize,
        concat!("Size of: ", stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).yy_upper as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(yy_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).yy_lower as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(yy_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).cr_upper as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(cr_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).cr_lower as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(cr_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).cb_upper as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(cb_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_1>())).cb_lower as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_1),
            "::",
            stringify!(cb_lower)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPMANX_CLAMP_KEYS_T__bindgen_ty_2 {
    pub red_upper: u8,
    pub red_lower: u8,
    pub blue_upper: u8,
    pub blue_lower: u8,
    pub green_upper: u8,
    pub green_lower: u8,
}
#[test]
fn bindgen_test_layout_DISPMANX_CLAMP_KEYS_T__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>(),
        6usize,
        concat!("Size of: ", stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).red_upper as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(red_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).red_lower as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(red_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).blue_upper as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(blue_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).blue_lower as *const _
                as usize
        },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(blue_lower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).green_upper as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(green_upper)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T__bindgen_ty_2>())).green_lower as *const _
                as usize
        },
        5usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T__bindgen_ty_2),
            "::",
            stringify!(green_lower)
        )
    );
}
#[test]
fn bindgen_test_layout_DISPMANX_CLAMP_KEYS_T() {
    assert_eq!(
        ::std::mem::size_of::<DISPMANX_CLAMP_KEYS_T>(),
        6usize,
        concat!("Size of: ", stringify!(DISPMANX_CLAMP_KEYS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPMANX_CLAMP_KEYS_T>(),
        1usize,
        concat!("Alignment of ", stringify!(DISPMANX_CLAMP_KEYS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T>())).yuv as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T),
            "::",
            stringify!(yuv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_KEYS_T>())).rgb as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_KEYS_T),
            "::",
            stringify!(rgb)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct DISPMANX_CLAMP_T {
    pub mode: DISPMANX_FLAGS_CLAMP_T,
    pub key_mask: DISPMANX_FLAGS_KEYMASK_T,
    pub key_value: DISPMANX_CLAMP_KEYS_T,
    pub replace_value: u32,
}
#[test]
fn bindgen_test_layout_DISPMANX_CLAMP_T() {
    assert_eq!(
        ::std::mem::size_of::<DISPMANX_CLAMP_T>(),
        20usize,
        concat!("Size of: ", stringify!(DISPMANX_CLAMP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPMANX_CLAMP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(DISPMANX_CLAMP_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_T>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_T>())).key_mask as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_T),
            "::",
            stringify!(key_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_T>())).key_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_T),
            "::",
            stringify!(key_value)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_CLAMP_T>())).replace_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_CLAMP_T),
            "::",
            stringify!(replace_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DISPMANX_MODEINFO_T {
    pub width: i32,
    pub height: i32,
    pub transform: DISPMANX_TRANSFORM_T,
    pub input_format: DISPLAY_INPUT_FORMAT_T,
    pub display_num: u32,
}
#[test]
fn bindgen_test_layout_DISPMANX_MODEINFO_T() {
    assert_eq!(
        ::std::mem::size_of::<DISPMANX_MODEINFO_T>(),
        20usize,
        concat!("Size of: ", stringify!(DISPMANX_MODEINFO_T))
    );
    assert_eq!(
        ::std::mem::align_of::<DISPMANX_MODEINFO_T>(),
        4usize,
        concat!("Alignment of ", stringify!(DISPMANX_MODEINFO_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_MODEINFO_T>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_MODEINFO_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_MODEINFO_T>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_MODEINFO_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_MODEINFO_T>())).transform as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_MODEINFO_T),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<DISPMANX_MODEINFO_T>())).input_format as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_MODEINFO_T),
            "::",
            stringify!(input_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DISPMANX_MODEINFO_T>())).display_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DISPMANX_MODEINFO_T),
            "::",
            stringify!(display_num)
        )
    );
}
pub type DISPMANX_CALLBACK_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(u: DISPMANX_UPDATE_HANDLE_T, arg: *mut ::std::os::raw::c_void),
>;
pub const VCHI_FLAGS_T_VCHI_FLAGS_NONE: VCHI_FLAGS_T = 0;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_OP_COMPLETE: VCHI_FLAGS_T = 1;
pub const VCHI_FLAGS_T_VCHI_FLAGS_CALLBACK_WHEN_OP_COMPLETE: VCHI_FLAGS_T = 2;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_QUEUED: VCHI_FLAGS_T = 4;
pub const VCHI_FLAGS_T_VCHI_FLAGS_ALLOW_PARTIAL: VCHI_FLAGS_T = 8;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BLOCK_UNTIL_DATA_READ: VCHI_FLAGS_T = 16;
pub const VCHI_FLAGS_T_VCHI_FLAGS_CALLBACK_WHEN_DATA_READ: VCHI_FLAGS_T = 32;
pub const VCHI_FLAGS_T_VCHI_FLAGS_ALIGN_SLOT: VCHI_FLAGS_T = 128;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_AUX_QUEUED: VCHI_FLAGS_T = 65536;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_AUX_COMPLETE: VCHI_FLAGS_T = 131072;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_DATA_QUEUED: VCHI_FLAGS_T = 262144;
pub const VCHI_FLAGS_T_VCHI_FLAGS_BULK_DATA_COMPLETE: VCHI_FLAGS_T = 524288;
pub const VCHI_FLAGS_T_VCHI_FLAGS_INTERNAL: VCHI_FLAGS_T = 16711680;
pub type VCHI_FLAGS_T = ::std::os::raw::c_uint;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_NOTHING: VCHI_CRC_CONTROL_T = -1;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_PER_SERVICE: VCHI_CRC_CONTROL_T = 0;
pub const VCHI_CRC_CONTROL_T_VCHI_CRC_EVERYTHING: VCHI_CRC_CONTROL_T = 1;
pub type VCHI_CRC_CONTROL_T = ::std::os::raw::c_int;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_REASON_MIN: VCHI_CALLBACK_REASON_T = 0;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_AVAILABLE: VCHI_CALLBACK_REASON_T = 1;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_SENT: VCHI_CALLBACK_REASON_T = 2;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_MSG_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 3;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_RECEIVED: VCHI_CALLBACK_REASON_T = 4;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_SENT: VCHI_CALLBACK_REASON_T = 5;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_RX_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 6;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_TX_SPACE_AVAILABLE: VCHI_CALLBACK_REASON_T = 7;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SERVICE_CLOSED: VCHI_CALLBACK_REASON_T = 8;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SENT_XOFF: VCHI_CALLBACK_REASON_T = 9;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_SENT_XON: VCHI_CALLBACK_REASON_T = 10;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_BULK_DATA_READ: VCHI_CALLBACK_REASON_T = 11;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_OFF: VCHI_CALLBACK_REASON_T = 12;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_SUSPENDED: VCHI_CALLBACK_REASON_T = 13;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_ON: VCHI_CALLBACK_REASON_T = 14;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_PEER_RESUMED: VCHI_CALLBACK_REASON_T = 15;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_FORCED_POWER_OFF: VCHI_CALLBACK_REASON_T = 16;
pub const VCHI_CALLBACK_REASON_T_VCHI_CALLBACK_REASON_MAX: VCHI_CALLBACK_REASON_T = 17;
pub type VCHI_CALLBACK_REASON_T = ::std::os::raw::c_uint;
pub type VCHI_CALLBACK_T = ::std::option::Option<
    unsafe extern "C" fn(
        callback_param: *mut ::std::os::raw::c_void,
        reason: VCHI_CALLBACK_REASON_T,
        handle: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct vchi_msg_vector {
    pub vec_base: *const ::std::os::raw::c_void,
    pub vec_len: i32,
}
#[test]
fn bindgen_test_layout_vchi_msg_vector() {
    assert_eq!(
        ::std::mem::size_of::<vchi_msg_vector>(),
        8usize,
        concat!("Size of: ", stringify!(vchi_msg_vector))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_msg_vector>(),
        4usize,
        concat!("Alignment of ", stringify!(vchi_msg_vector))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector>())).vec_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector),
            "::",
            stringify!(vec_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_msg_vector>())).vec_len as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_msg_vector),
            "::",
            stringify!(vec_len)
        )
    );
}
pub type VCHI_MSG_VECTOR_T = vchi_msg_vector;
pub type VCHI_CONNECTION_API_T = opaque_vchi_connection_api_t;
pub type VCHI_MESSAGE_DRIVER_T = opaque_vchi_message_driver_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_MSG_ITER_T {
    pub service: *mut opaque_vchi_service_t,
    pub last: *mut ::std::os::raw::c_void,
    pub next: *mut ::std::os::raw::c_void,
    pub remove: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCHI_MSG_ITER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_MSG_ITER_T>(),
        16usize,
        concat!("Size of: ", stringify!(VCHI_MSG_ITER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_MSG_ITER_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCHI_MSG_ITER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).service as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).last as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(last)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCHI_MSG_ITER_T>())).remove as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MSG_ITER_T),
            "::",
            stringify!(remove)
        )
    );
}
pub const message_event_type_MESSAGE_EVENT_NONE: message_event_type = 0;
pub const message_event_type_MESSAGE_EVENT_NOP: message_event_type = 1;
pub const message_event_type_MESSAGE_EVENT_MESSAGE: message_event_type = 2;
pub const message_event_type_MESSAGE_EVENT_SLOT_COMPLETE: message_event_type = 3;
pub const message_event_type_MESSAGE_EVENT_RX_BULK_PAUSED: message_event_type = 4;
pub const message_event_type_MESSAGE_EVENT_RX_BULK_COMPLETE: message_event_type = 5;
pub const message_event_type_MESSAGE_EVENT_TX_COMPLETE: message_event_type = 6;
pub const message_event_type_MESSAGE_EVENT_MSG_DISCARDED: message_event_type = 7;
pub type message_event_type = ::std::os::raw::c_uint;
pub use self::message_event_type as MESSAGE_EVENT_TYPE_T;
pub const vchi_msg_flags_VCHI_MSG_FLAGS_NONE: vchi_msg_flags = 0;
pub const vchi_msg_flags_VCHI_MSG_FLAGS_TERMINATE_DMA: vchi_msg_flags = 1;
pub type vchi_msg_flags = ::std::os::raw::c_uint;
pub use self::vchi_msg_flags as VCHI_MSG_FLAGS_T;
pub const message_tx_channel_MESSAGE_TX_CHANNEL_MESSAGE: message_tx_channel = 0;
pub const message_tx_channel_MESSAGE_TX_CHANNEL_BULK: message_tx_channel = 1;
pub type message_tx_channel = ::std::os::raw::c_uint;
pub use self::message_tx_channel as MESSAGE_TX_CHANNEL_T;
pub const message_rx_channel_MESSAGE_RX_CHANNEL_MESSAGE: message_rx_channel = 0;
pub const message_rx_channel_MESSAGE_RX_CHANNEL_BULK: message_rx_channel = 1;
pub type message_rx_channel = ::std::os::raw::c_uint;
pub use self::message_rx_channel as MESSAGE_RX_CHANNEL_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rx_msg_slot_info {
    pub next: *mut rx_msg_slot_info,
    pub addr: *mut u8,
    pub len: u32,
    pub write_ptr: u32,
    pub read_ptr: u32,
    pub active: ::std::os::raw::c_int,
    pub msgs_parsed: u32,
    pub msgs_released: u32,
    pub state: *mut ::std::os::raw::c_void,
    pub ref_count: [u8; 36usize],
}
#[test]
fn bindgen_test_layout_rx_msg_slot_info() {
    assert_eq!(
        ::std::mem::size_of::<rx_msg_slot_info>(),
        72usize,
        concat!("Size of: ", stringify!(rx_msg_slot_info))
    );
    assert_eq!(
        ::std::mem::align_of::<rx_msg_slot_info>(),
        4usize,
        concat!("Alignment of ", stringify!(rx_msg_slot_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).write_ptr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).read_ptr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).active as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).msgs_parsed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(msgs_parsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).msgs_released as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(msgs_released)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).state as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_msg_slot_info>())).ref_count as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_msg_slot_info),
            "::",
            stringify!(ref_count)
        )
    );
}
pub type RX_MSG_SLOTINFO_T = rx_msg_slot_info;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rx_bulk_slotinfo_t {
    pub next: *mut rx_bulk_slotinfo_t,
    pub blocking: *mut VCOS_SEMAPHORE_T,
    pub addr: *mut ::std::os::raw::c_void,
    pub len: u32,
    pub service: *mut ::std::os::raw::c_void,
    pub handle: *mut ::std::os::raw::c_void,
    pub flags: VCHI_FLAGS_T,
}
#[test]
fn bindgen_test_layout_rx_bulk_slotinfo_t() {
    assert_eq!(
        ::std::mem::size_of::<rx_bulk_slotinfo_t>(),
        28usize,
        concat!("Size of: ", stringify!(rx_bulk_slotinfo_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rx_bulk_slotinfo_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rx_bulk_slotinfo_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).blocking as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(blocking)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).service as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).handle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rx_bulk_slotinfo_t>())).flags as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rx_bulk_slotinfo_t),
            "::",
            stringify!(flags)
        )
    );
}
pub type RX_BULK_SLOTINFO_T = rx_bulk_slotinfo_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MESSAGE_EVENT_T {
    pub type_: MESSAGE_EVENT_TYPE_T,
    pub message: MESSAGE_EVENT_T__bindgen_ty_1,
    pub rx_msg: *mut RX_MSG_SLOTINFO_T,
    pub rx_bulk: *mut RX_BULK_SLOTINFO_T,
    pub tx_handle: *mut ::std::os::raw::c_void,
    pub tx_channel: MESSAGE_TX_CHANNEL_T,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MESSAGE_EVENT_T__bindgen_ty_1 {
    pub addr: *mut ::std::os::raw::c_void,
    pub slot_delta: u16,
    pub len: u32,
    pub slot: *mut RX_MSG_SLOTINFO_T,
    pub service: vcos_fourcc_t,
    pub tx_timestamp: u32,
    pub rx_timestamp: u32,
}
#[test]
fn bindgen_test_layout_MESSAGE_EVENT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<MESSAGE_EVENT_T__bindgen_ty_1>(),
        28usize,
        concat!("Size of: ", stringify!(MESSAGE_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<MESSAGE_EVENT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(MESSAGE_EVENT_T__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).slot_delta as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(slot_delta)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).slot as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).service as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(service)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).tx_timestamp as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(tx_timestamp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<MESSAGE_EVENT_T__bindgen_ty_1>())).rx_timestamp as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T__bindgen_ty_1),
            "::",
            stringify!(rx_timestamp)
        )
    );
}
#[test]
fn bindgen_test_layout_MESSAGE_EVENT_T() {
    assert_eq!(
        ::std::mem::size_of::<MESSAGE_EVENT_T>(),
        48usize,
        concat!("Size of: ", stringify!(MESSAGE_EVENT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<MESSAGE_EVENT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(MESSAGE_EVENT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).message as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(message)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).rx_msg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(rx_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).rx_bulk as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(rx_bulk)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).tx_handle as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(tx_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<MESSAGE_EVENT_T>())).tx_channel as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(MESSAGE_EVENT_T),
            "::",
            stringify!(tx_channel)
        )
    );
}
pub type VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T =
    ::std::option::Option<unsafe extern "C" fn(state: *mut ::std::os::raw::c_void)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCHI_MESSAGE_DRIVER_OPEN_T {
    pub event_callback: VCHI_MESSAGE_DRIVER_EVENT_CALLBACK_T,
}
#[test]
fn bindgen_test_layout_VCHI_MESSAGE_DRIVER_OPEN_T() {
    assert_eq!(
        ::std::mem::size_of::<VCHI_MESSAGE_DRIVER_OPEN_T>(),
        4usize,
        concat!("Size of: ", stringify!(VCHI_MESSAGE_DRIVER_OPEN_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCHI_MESSAGE_DRIVER_OPEN_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCHI_MESSAGE_DRIVER_OPEN_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCHI_MESSAGE_DRIVER_OPEN_T>())).event_callback as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCHI_MESSAGE_DRIVER_OPEN_T),
            "::",
            stringify!(event_callback)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_mhandle_t {
    _unused: [u8; 0],
}
pub type VCHI_MDRIVER_HANDLE_T = *mut opaque_mhandle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_message_driver_t {
    pub open: ::std::option::Option<
        unsafe extern "C" fn(
            params: *mut VCHI_MESSAGE_DRIVER_OPEN_T,
            state: *mut ::std::os::raw::c_void,
        ) -> *mut VCHI_MDRIVER_HANDLE_T,
    >,
    pub suspending:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub resumed:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub power_control: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            arg1: MESSAGE_TX_CHANNEL_T,
            enable: vcos_bool_t,
        ) -> i32,
    >,
    pub add_msg_rx_slot: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            slot: *mut RX_MSG_SLOTINFO_T,
        ) -> i32,
    >,
    pub add_bulk_rx: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            data: *mut ::std::os::raw::c_void,
            len: u32,
            slot: *mut RX_BULK_SLOTINFO_T,
        ) -> i32,
    >,
    pub send: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
            data: *const ::std::os::raw::c_void,
            len: u32,
            flags: VCHI_MSG_FLAGS_T,
            send_handle: *mut ::std::os::raw::c_void,
        ) -> i32,
    >,
    pub next_event: ::std::option::Option<
        unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T, event: *mut MESSAGE_EVENT_T),
    >,
    pub enable:
        ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T) -> i32>,
    pub form_message: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            service_id: vcos_fourcc_t,
            vector: *mut VCHI_MSG_VECTOR_T,
            count: u32,
            address: *mut ::std::os::raw::c_void,
            length_avail: u32,
            max_total_length: u32,
            pad_to_fill: vcos_bool_t,
            allow_partial: vcos_bool_t,
        ) -> i32,
    >,
    pub update_message: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            dest: *mut ::std::os::raw::c_void,
            slot_count: *mut i16,
        ) -> i32,
    >,
    pub buffer_aligned: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            tx: ::std::os::raw::c_int,
            uncached: ::std::os::raw::c_int,
            address: *const ::std::os::raw::c_void,
            length: u32,
        ) -> i32,
    >,
    pub allocate_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            length: *mut u32,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free_buffer: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            address: *mut ::std::os::raw::c_void,
        ),
    >,
    pub rx_slot_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            msg_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tx_slot_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            msg_size: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub tx_supports_terminate: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> vcos_bool_t,
    >,
    pub tx_bulk_chunk_size: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> u32,
    >,
    pub tx_alignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
        ) -> ::std::os::raw::c_int,
    >,
    pub rx_alignment: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *const VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_RX_CHANNEL_T,
        ) -> ::std::os::raw::c_int,
    >,
    pub form_bulk_aux: ::std::option::Option<
        unsafe extern "C" fn(
            handle: *mut VCHI_MDRIVER_HANDLE_T,
            channel: MESSAGE_TX_CHANNEL_T,
            data: *const ::std::os::raw::c_void,
            len: u32,
            chunk_size: u32,
            aux_data: *mut *const ::std::os::raw::c_void,
            aux_len: *mut i32,
        ),
    >,
    pub debug: ::std::option::Option<unsafe extern "C" fn(handle: *mut VCHI_MDRIVER_HANDLE_T)>,
}
#[test]
fn bindgen_test_layout_opaque_vchi_message_driver_t() {
    assert_eq!(
        ::std::mem::size_of::<opaque_vchi_message_driver_t>(),
        88usize,
        concat!("Size of: ", stringify!(opaque_vchi_message_driver_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opaque_vchi_message_driver_t>(),
        4usize,
        concat!("Alignment of ", stringify!(opaque_vchi_message_driver_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).open as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(open)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).suspending as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(suspending)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).resumed as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(resumed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).power_control as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(power_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).add_msg_rx_slot as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(add_msg_rx_slot)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).add_bulk_rx as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(add_bulk_rx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).send as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(send)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).next_event as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(next_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).enable as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(enable)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).form_message as *const _
                as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(form_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).update_message as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(update_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).buffer_aligned as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(buffer_aligned)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).allocate_buffer as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(allocate_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).free_buffer as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(free_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).rx_slot_size as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(rx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_slot_size as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_supports_terminate
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_supports_terminate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_bulk_chunk_size as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_bulk_chunk_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).tx_alignment as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(tx_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).rx_alignment as *const _
                as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(rx_alignment)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).form_bulk_aux as *const _
                as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(form_bulk_aux)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_message_driver_t>())).debug as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_message_driver_t),
            "::",
            stringify!(debug)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_connected_service_handle_t {
    _unused: [u8; 0],
}
pub type VCHI_CONNECTION_SERVICE_HANDLE_T = *mut opaque_vchi_connection_connected_service_handle_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_info_t {
    _unused: [u8; 0],
}
pub type VCHI_CONNECTION_STATE_T = opaque_vchi_connection_info_t;
pub type VCHI_CONNECTION_T = vchi_connection_t;
pub type VCHI_CONNECTION_INIT_T = ::std::option::Option<
    unsafe extern "C" fn(
        connection: *mut vchi_connection_t,
        driver: *const VCHI_MESSAGE_DRIVER_T,
    ) -> *mut VCHI_CONNECTION_STATE_T,
>;
pub type VCHI_CONNECTION_CRC_CONTROL_T = ::std::option::Option<
    unsafe extern "C" fn(
        state_handle: *mut VCHI_CONNECTION_STATE_T,
        control: VCHI_CRC_CONTROL_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_CONNECT_T = ::std::option::Option<
    unsafe extern "C" fn(
        state_handle: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        rx_fifo_size: u32,
        tx_fifo_size: u32,
        server: ::std::os::raw::c_int,
        callback: VCHI_CALLBACK_T,
        callback_param: *mut ::std::os::raw::c_void,
        want_crc: vcos_bool_t,
        want_unaligned_bulk_rx: vcos_bool_t,
        want_unaligned_bulk_tx: vcos_bool_t,
        service_handle: *mut VCHI_CONNECTION_SERVICE_HANDLE_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_DISCONNECT_T = ::std::option::Option<
    unsafe extern "C" fn(service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        vector: *mut VCHI_MSG_VECTOR_T,
        count: u32,
        flags: VCHI_FLAGS_T,
        msg_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut ::std::os::raw::c_void,
        max_data_size_to_read: u32,
        actual_msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
        flags: VCHI_FLAGS_T,
        message_handle: *mut *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        flags: VCHI_FLAGS_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_HELD_MSG_RELEASE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        message_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_HELD_MSG_INFO_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        message_handle: *mut ::std::os::raw::c_void,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut i32,
        tx_timestamp: *mut u32,
        rx_timestamp: *mut u32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *const VCHI_MSG_ITER_T,
    ) -> vcos_bool_t,
>;
pub type VCHI_CONNECTION_MSG_ITER_NEXT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        data: *mut *mut ::std::os::raw::c_void,
        msg_size: *mut u32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_REMOVE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
    ) -> i32,
>;
pub type VCHI_CONNECTION_MSG_ITER_HOLD_T = ::std::option::Option<
    unsafe extern "C" fn(
        service: VCHI_CONNECTION_SERVICE_HANDLE_T,
        iter: *mut VCHI_MSG_ITER_T,
        msg_handle: *mut *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data_src: *const ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        bulk_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        data_dst: *mut ::std::os::raw::c_void,
        data_size: u32,
        flags: VCHI_FLAGS_T,
        bulk_handle: *mut ::std::os::raw::c_void,
    ) -> i32,
>;
pub type VCHI_CONNECTION_SERVER_PRESENT = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        peer_flags: i32,
    ) -> i32,
>;
pub type VCHI_CONNECTION_RX_SLOTS_AVAILABLE = ::std::option::Option<
    unsafe extern "C" fn(state: *const VCHI_CONNECTION_STATE_T) -> ::std::os::raw::c_int,
>;
pub type VCHI_CONNECTION_RX_SLOT_SIZE =
    ::std::option::Option<unsafe extern "C" fn(state: *const VCHI_CONNECTION_STATE_T) -> u32>;
pub type VCHI_CONNECTION_RX_BULK_BUFFER_ADDED = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service: vcos_fourcc_t,
        length: u32,
        channel: MESSAGE_TX_CHANNEL_T,
        channel_params: u32,
        data_length: u32,
        data_offset: u32,
    ),
>;
pub type VCHI_CONNECTION_FLOW_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, service_id: vcos_fourcc_t, xoff: i32),
>;
pub type VCHI_CONNECTION_SERVER_AVAILABLE_REPLY = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        service_id: vcos_fourcc_t,
        flags: u32,
    ),
>;
pub type VCHI_CONNECTION_BULK_AUX_RECEIVED =
    ::std::option::Option<unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T)>;
pub type VCHI_CONNECTION_BULK_AUX_TRANSMITTED = ::std::option::Option<
    unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, handle: *mut ::std::os::raw::c_void),
>;
pub type VCHI_CONNECTION_INFO = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        protocol_version: u32,
        slot_size: u32,
        num_slots: u32,
        min_bulk_size: u32,
    ),
>;
pub type VCHI_CONNECTION_DISCONNECT =
    ::std::option::Option<unsafe extern "C" fn(state: *mut VCHI_CONNECTION_STATE_T, flags: u32)>;
pub type VCHI_CONNECTION_POWER_CONTROL = ::std::option::Option<
    unsafe extern "C" fn(
        state: *mut VCHI_CONNECTION_STATE_T,
        channel: MESSAGE_TX_CHANNEL_T,
        enable: vcos_bool_t,
    ),
>;
pub type VCHI_BUFFER_ALLOCATE = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        length: *mut u32,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type VCHI_BUFFER_FREE = ::std::option::Option<
    unsafe extern "C" fn(
        service_handle: VCHI_CONNECTION_SERVICE_HANDLE_T,
        address: *mut ::std::os::raw::c_void,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_connection_api_t {
    pub init: VCHI_CONNECTION_INIT_T,
    pub crc_control: VCHI_CONNECTION_CRC_CONTROL_T,
    pub service_connect: VCHI_CONNECTION_SERVICE_CONNECT_T,
    pub service_disconnect: VCHI_CONNECTION_SERVICE_DISCONNECT_T,
    pub service_queue_msg: VCHI_CONNECTION_SERVICE_QUEUE_MESSAGE_T,
    pub service_queue_msgv: VCHI_CONNECTION_SERVICE_QUEUE_MESSAGEV_T,
    pub service_dequeue_msg: VCHI_CONNECTION_SERVICE_DEQUEUE_MESSAGE_T,
    pub service_peek_msg: VCHI_CONNECTION_SERVICE_PEEK_MESSAGE_T,
    pub service_hold_msg: VCHI_CONNECTION_SERVICE_HOLD_MESSAGE_T,
    pub service_look_ahead_msg: VCHI_CONNECTION_SERVICE_LOOKAHEAD_MESSAGE_T,
    pub held_msg_release: VCHI_CONNECTION_HELD_MSG_RELEASE_T,
    pub held_msg_info: VCHI_CONNECTION_HELD_MSG_INFO_T,
    pub msg_iter_has_next: VCHI_CONNECTION_MSG_ITER_HAS_NEXT_T,
    pub msg_iter_next: VCHI_CONNECTION_MSG_ITER_NEXT_T,
    pub msg_iter_remove: VCHI_CONNECTION_MSG_ITER_REMOVE_T,
    pub msg_iter_hold: VCHI_CONNECTION_MSG_ITER_HOLD_T,
    pub bulk_queue_transmit: VCHI_CONNECTION_BULK_QUEUE_TRANSMIT_T,
    pub bulk_queue_receive: VCHI_CONNECTION_BULK_QUEUE_RECEIVE_T,
    pub server_present: VCHI_CONNECTION_SERVER_PRESENT,
    pub connection_rx_slots_available: VCHI_CONNECTION_RX_SLOTS_AVAILABLE,
    pub connection_rx_slot_size: VCHI_CONNECTION_RX_SLOT_SIZE,
    pub rx_bulk_buffer_added: VCHI_CONNECTION_RX_BULK_BUFFER_ADDED,
    pub flow_control: VCHI_CONNECTION_FLOW_CONTROL,
    pub server_available_reply: VCHI_CONNECTION_SERVER_AVAILABLE_REPLY,
    pub bulk_aux_received: VCHI_CONNECTION_BULK_AUX_RECEIVED,
    pub bulk_aux_transmitted: VCHI_CONNECTION_BULK_AUX_TRANSMITTED,
    pub connection_info: VCHI_CONNECTION_INFO,
    pub disconnect: VCHI_CONNECTION_DISCONNECT,
    pub power_control: VCHI_CONNECTION_POWER_CONTROL,
    pub buffer_allocate: VCHI_BUFFER_ALLOCATE,
    pub buffer_free: VCHI_BUFFER_FREE,
}
#[test]
fn bindgen_test_layout_opaque_vchi_connection_api_t() {
    assert_eq!(
        ::std::mem::size_of::<opaque_vchi_connection_api_t>(),
        124usize,
        concat!("Size of: ", stringify!(opaque_vchi_connection_api_t))
    );
    assert_eq!(
        ::std::mem::align_of::<opaque_vchi_connection_api_t>(),
        4usize,
        concat!("Alignment of ", stringify!(opaque_vchi_connection_api_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).init as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).crc_control as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(crc_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_connect as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_connect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_disconnect as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_queue_msg as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_queue_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_queue_msgv as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_queue_msgv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_dequeue_msg as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_dequeue_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_peek_msg as *const _
                as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_peek_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_hold_msg as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_hold_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).service_look_ahead_msg
                as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(service_look_ahead_msg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).held_msg_release as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(held_msg_release)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).held_msg_info as *const _
                as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(held_msg_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_has_next as *const _
                as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_has_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_next as *const _
                as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_remove as *const _
                as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_remove)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).msg_iter_hold as *const _
                as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(msg_iter_hold)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_queue_transmit as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_queue_transmit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_queue_receive as *const _
                as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_queue_receive)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).server_present as *const _
                as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(server_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_rx_slots_available
                as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_rx_slots_available)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_rx_slot_size
                as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_rx_slot_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).rx_bulk_buffer_added
                as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(rx_bulk_buffer_added)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).flow_control as *const _
                as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).server_available_reply
                as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(server_available_reply)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_aux_received as *const _
                as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_aux_received)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).bulk_aux_transmitted
                as *const _ as usize
        },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(bulk_aux_transmitted)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).connection_info as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(connection_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).disconnect as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(disconnect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).power_control as *const _
                as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(power_control)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).buffer_allocate as *const _
                as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(buffer_allocate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<opaque_vchi_connection_api_t>())).buffer_free as *const _
                as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(opaque_vchi_connection_api_t),
            "::",
            stringify!(buffer_free)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct vchi_connection_t {
    pub api: *const VCHI_CONNECTION_API_T,
    pub state: *mut VCHI_CONNECTION_STATE_T,
    pub sem: VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_vchi_connection_t() {
    assert_eq!(
        ::std::mem::size_of::<vchi_connection_t>(),
        24usize,
        concat!("Size of: ", stringify!(vchi_connection_t))
    );
    assert_eq!(
        ::std::mem::align_of::<vchi_connection_t>(),
        4usize,
        concat!("Alignment of ", stringify!(vchi_connection_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).api as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(api)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<vchi_connection_t>())).sem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(vchi_connection_t),
            "::",
            stringify!(sem)
        )
    );
}
pub type VCHI_MEM_HANDLE_T = i32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_service_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct opaque_vchi_instance_handle_t {
    _unused: [u8; 0],
}
pub type VCHI_INSTANCE_T = *mut opaque_vchi_instance_handle_t;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_PIXEL_ENCODING: HDMI_PROPERTY_T = 0;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_PIXEL_CLOCK_TYPE: HDMI_PROPERTY_T = 1;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_CONTENT_TYPE: HDMI_PROPERTY_T = 2;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_FUZZY_MATCH: HDMI_PROPERTY_T = 3;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_3D_STRUCTURE: HDMI_PROPERTY_T = 4;
pub const HDMI_PROPERTY_T_HDMI_PROPERTY_MAX: HDMI_PROPERTY_T = 5;
pub type HDMI_PROPERTY_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDMI_PROPERTY_PARAM_T {
    pub property: HDMI_PROPERTY_T,
    pub param1: u32,
    pub param2: u32,
}
#[test]
fn bindgen_test_layout_HDMI_PROPERTY_PARAM_T() {
    assert_eq!(
        ::std::mem::size_of::<HDMI_PROPERTY_PARAM_T>(),
        12usize,
        concat!("Size of: ", stringify!(HDMI_PROPERTY_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<HDMI_PROPERTY_PARAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(HDMI_PROPERTY_PARAM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_PROPERTY_PARAM_T>())).property as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_PROPERTY_PARAM_T),
            "::",
            stringify!(property)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_PROPERTY_PARAM_T>())).param1 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_PROPERTY_PARAM_T),
            "::",
            stringify!(param1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_PROPERTY_PARAM_T>())).param2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_PROPERTY_PARAM_T),
            "::",
            stringify!(param2)
        )
    );
}
pub const HDMI_RES_GROUP_T_HDMI_RES_GROUP_INVALID: HDMI_RES_GROUP_T = 0;
pub const HDMI_RES_GROUP_T_HDMI_RES_GROUP_CEA: HDMI_RES_GROUP_T = 1;
pub const HDMI_RES_GROUP_T_HDMI_RES_GROUP_DMT: HDMI_RES_GROUP_T = 2;
pub const HDMI_RES_GROUP_T_HDMI_RES_GROUP_CEA_3D: HDMI_RES_GROUP_T = 3;
pub const HDMI_RES_GROUP_T_HDMI_RES_GROUP_CUSTOM: HDMI_RES_GROUP_T = 4;
pub type HDMI_RES_GROUP_T = ::std::os::raw::c_uint;
pub const HDMI_ASPECT_T_HDMI_ASPECT_UNKNOWN: HDMI_ASPECT_T = 0;
pub const HDMI_ASPECT_T_HDMI_ASPECT_4_3: HDMI_ASPECT_T = 1;
pub const HDMI_ASPECT_T_HDMI_ASPECT_14_9: HDMI_ASPECT_T = 2;
pub const HDMI_ASPECT_T_HDMI_ASPECT_16_9: HDMI_ASPECT_T = 3;
pub const HDMI_ASPECT_T_HDMI_ASPECT_5_4: HDMI_ASPECT_T = 4;
pub const HDMI_ASPECT_T_HDMI_ASPECT_16_10: HDMI_ASPECT_T = 5;
pub const HDMI_ASPECT_T_HDMI_ASPECT_15_9: HDMI_ASPECT_T = 6;
pub const HDMI_ASPECT_T_HDMI_ASPECT_64_27: HDMI_ASPECT_T = 7;
pub const HDMI_ASPECT_T_HDMI_ASPECT_21_9: HDMI_ASPECT_T = 7;
pub const HDMI_ASPECT_T_HDMI_ASPECT_256_135: HDMI_ASPECT_T = 8;
pub type HDMI_ASPECT_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDMI_DISPLAY_OPTIONS_T {
    pub aspect: u16,
    pub vertical_bar_present: u16,
    pub left_bar_width: u16,
    pub right_bar_width: u16,
    pub horizontal_bar_present: u16,
    pub top_bar_height: u16,
    pub bottom_bar_height: u16,
    pub overscan_flags: u8,
}
#[test]
fn bindgen_test_layout_HDMI_DISPLAY_OPTIONS_T() {
    assert_eq!(
        ::std::mem::size_of::<HDMI_DISPLAY_OPTIONS_T>(),
        16usize,
        concat!("Size of: ", stringify!(HDMI_DISPLAY_OPTIONS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<HDMI_DISPLAY_OPTIONS_T>(),
        2usize,
        concat!("Alignment of ", stringify!(HDMI_DISPLAY_OPTIONS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).aspect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(aspect)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).vertical_bar_present as *const _
                as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(vertical_bar_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).left_bar_width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(left_bar_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).right_bar_width as *const _ as usize
        },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(right_bar_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).horizontal_bar_present as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(horizontal_bar_present)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).top_bar_height as *const _ as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(top_bar_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).bottom_bar_height as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(bottom_bar_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_OPTIONS_T>())).overscan_flags as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_OPTIONS_T),
            "::",
            stringify!(overscan_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HDMI_DISPLAY_STATE_T {
    pub state: u32,
    pub width: u32,
    pub height: u32,
    pub frame_rate: u16,
    pub scan_mode: u16,
    pub group: u32,
    pub mode: u32,
    pub pixel_rep: u16,
    pub aspect_ratio: u16,
    pub display_options: HDMI_DISPLAY_OPTIONS_T,
    pub pixel_encoding: u16,
    pub format_3d: u16,
}
#[test]
fn bindgen_test_layout_HDMI_DISPLAY_STATE_T() {
    assert_eq!(
        ::std::mem::size_of::<HDMI_DISPLAY_STATE_T>(),
        48usize,
        concat!("Size of: ", stringify!(HDMI_DISPLAY_STATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<HDMI_DISPLAY_STATE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(HDMI_DISPLAY_STATE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).frame_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).scan_mode as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(scan_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).group as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(group)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).mode as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).pixel_rep as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(pixel_rep)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).aspect_ratio as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(aspect_ratio)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).display_options as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(display_options)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).pixel_encoding as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(pixel_encoding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<HDMI_DISPLAY_STATE_T>())).format_3d as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(HDMI_DISPLAY_STATE_T),
            "::",
            stringify!(format_3d)
        )
    );
}
pub const HDMI_MODE_T_HDMI_MODE_OFF: HDMI_MODE_T = 0;
pub const HDMI_MODE_T_HDMI_MODE_DVI: HDMI_MODE_T = 1;
pub const HDMI_MODE_T_HDMI_MODE_HDMI: HDMI_MODE_T = 2;
pub const HDMI_MODE_T_HDMI_MODE_3D: HDMI_MODE_T = 3;
pub type HDMI_MODE_T = ::std::os::raw::c_uint;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_UNKNOWN: HDMI_SPD_TYPE_CODE_T = 0;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_STB: HDMI_SPD_TYPE_CODE_T = 1;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_DVD: HDMI_SPD_TYPE_CODE_T = 2;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_DVHS: HDMI_SPD_TYPE_CODE_T = 3;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_HDD_RECORDER: HDMI_SPD_TYPE_CODE_T = 4;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_DVC: HDMI_SPD_TYPE_CODE_T = 5;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_DSC: HDMI_SPD_TYPE_CODE_T = 6;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_VCD: HDMI_SPD_TYPE_CODE_T = 7;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_GAME: HDMI_SPD_TYPE_CODE_T = 8;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_PC: HDMI_SPD_TYPE_CODE_T = 9;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_BD: HDMI_SPD_TYPE_CODE_T = 10;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_SACD: HDMI_SPD_TYPE_CODE_T = 11;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_HDDVD: HDMI_SPD_TYPE_CODE_T = 12;
pub const HDMI_SPD_TYPE_CODE_T_HDMI_SPD_TYPE_PMP: HDMI_SPD_TYPE_CODE_T = 13;
pub type HDMI_SPD_TYPE_CODE_T = ::std::os::raw::c_uint;
pub const HDMI_INTERLACED_T_HDMI_NONINTERLACED: HDMI_INTERLACED_T = 0;
pub const HDMI_INTERLACED_T_HDMI_INTERLACED: HDMI_INTERLACED_T = 1;
pub type HDMI_INTERLACED_T = ::std::os::raw::c_uint;
pub const EDID_MODE_MATCH_FLAG_T_HDMI_MODE_MATCH_NONE: EDID_MODE_MATCH_FLAG_T = 0;
pub const EDID_MODE_MATCH_FLAG_T_HDMI_MODE_MATCH_FRAMERATE: EDID_MODE_MATCH_FLAG_T = 1;
pub const EDID_MODE_MATCH_FLAG_T_HDMI_MODE_MATCH_RESOLUTION: EDID_MODE_MATCH_FLAG_T = 2;
pub const EDID_MODE_MATCH_FLAG_T_HDMI_MODE_MATCH_SCANMODE: EDID_MODE_MATCH_FLAG_T = 4;
pub type EDID_MODE_MATCH_FLAG_T = ::std::os::raw::c_uint;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_eReferToHeader: EDID_AudioSampleRate = 0;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e32KHz: EDID_AudioSampleRate = 1;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e44KHz: EDID_AudioSampleRate = 2;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e48KHz: EDID_AudioSampleRate = 4;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e88KHz: EDID_AudioSampleRate = 8;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e96KHz: EDID_AudioSampleRate = 16;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e176KHz: EDID_AudioSampleRate = 32;
pub const EDID_AudioSampleRate_EDID_AudioSampleRate_e192KHz: EDID_AudioSampleRate = 64;
pub type EDID_AudioSampleRate = ::std::os::raw::c_uint;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_UNPLUGGED: VC_HDMI_NOTIFY_T = 1;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_ATTACHED: VC_HDMI_NOTIFY_T = 2;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_DVI: VC_HDMI_NOTIFY_T = 4;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_HDMI: VC_HDMI_NOTIFY_T = 8;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_HDCP_UNAUTH: VC_HDMI_NOTIFY_T = 16;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_HDCP_AUTH: VC_HDMI_NOTIFY_T = 32;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_HDCP_KEY_DOWNLOAD: VC_HDMI_NOTIFY_T = 64;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_HDCP_SRM_DOWNLOAD: VC_HDMI_NOTIFY_T = 128;
pub const VC_HDMI_NOTIFY_T_VC_HDMI_CHANGING_MODE: VC_HDMI_NOTIFY_T = 256;
pub type VC_HDMI_NOTIFY_T = ::std::os::raw::c_uint;
pub const SDTV_COLOUR__SDTV_COLOUR_UNKNOWN: SDTV_COLOUR_ = 0;
pub const SDTV_COLOUR__SDTV_COLOUR_RGB: SDTV_COLOUR_ = 4;
pub const SDTV_COLOUR__SDTV_COLOUR_YPRPB: SDTV_COLOUR_ = 8;
pub const SDTV_COLOUR__SDTV_COLOUR_FORCE_32BIT: SDTV_COLOUR_ = 2147483648;
pub type SDTV_COLOUR_ = ::std::os::raw::c_uint;
pub use self::SDTV_COLOUR_ as SDTV_COLOUR_T;
pub const SDTV_MODE_T__SDTV_MODE_NTSC: SDTV_MODE_T_ = 0;
pub const SDTV_MODE_T__SDTV_MODE_NTSC_J: SDTV_MODE_T_ = 1;
pub const SDTV_MODE_T__SDTV_MODE_PAL: SDTV_MODE_T_ = 2;
pub const SDTV_MODE_T__SDTV_MODE_PAL_M: SDTV_MODE_T_ = 3;
pub const SDTV_MODE_T__SDTV_MODE_FORMAT_MASK: SDTV_MODE_T_ = 3;
pub const SDTV_MODE_T__SDTV_MODE_OUTPUT_MASK: SDTV_MODE_T_ = 12;
pub const SDTV_MODE_T__SDTV_MODE_YPRPB_480i: SDTV_MODE_T_ = 8;
pub const SDTV_MODE_T__SDTV_MODE_RGB_480i: SDTV_MODE_T_ = 4;
pub const SDTV_MODE_T__SDTV_MODE_YPRPB_576i: SDTV_MODE_T_ = 10;
pub const SDTV_MODE_T__SDTV_MODE_RGB_576i: SDTV_MODE_T_ = 6;
pub const SDTV_MODE_T__SDTV_MODE_PROGRESSIVE: SDTV_MODE_T_ = 16;
pub const SDTV_MODE_T__SDTV_MODE_PAL_N: SDTV_MODE_T_ = 64;
pub const SDTV_MODE_T__SDTV_MODE_OFF: SDTV_MODE_T_ = 128;
pub const SDTV_MODE_T__SDTV_MODE_FORCE_32BIT: SDTV_MODE_T_ = 2147483648;
pub type SDTV_MODE_T_ = ::std::os::raw::c_uint;
pub use self::SDTV_MODE_T_ as SDTV_MODE_T;
pub const SDTV_ASPECT_T__SDTV_ASPECT_UNKNOWN: SDTV_ASPECT_T_ = 0;
pub const SDTV_ASPECT_T__SDTV_ASPECT_4_3: SDTV_ASPECT_T_ = 1;
pub const SDTV_ASPECT_T__SDTV_ASPECT_14_9: SDTV_ASPECT_T_ = 2;
pub const SDTV_ASPECT_T__SDTV_ASPECT_16_9: SDTV_ASPECT_T_ = 3;
pub const SDTV_ASPECT_T__SDTV_ASPECTFORCE_32BIT: SDTV_ASPECT_T_ = 2147483648;
pub type SDTV_ASPECT_T_ = ::std::os::raw::c_uint;
pub use self::SDTV_ASPECT_T_ as SDTV_ASPECT_T;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDTV_OPTIONS_T_ {
    pub aspect: SDTV_ASPECT_T,
}
#[test]
fn bindgen_test_layout_SDTV_OPTIONS_T_() {
    assert_eq!(
        ::std::mem::size_of::<SDTV_OPTIONS_T_>(),
        4usize,
        concat!("Size of: ", stringify!(SDTV_OPTIONS_T_))
    );
    assert_eq!(
        ::std::mem::align_of::<SDTV_OPTIONS_T_>(),
        4usize,
        concat!("Alignment of ", stringify!(SDTV_OPTIONS_T_))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_OPTIONS_T_>())).aspect as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_OPTIONS_T_),
            "::",
            stringify!(aspect)
        )
    );
}
pub type SDTV_OPTIONS_T = SDTV_OPTIONS_T_;
pub const SDTV_CP_MODE_T_SDTV_CP_NONE: SDTV_CP_MODE_T = 0;
pub const SDTV_CP_MODE_T_SDTV_CP_MACROVISION_TYPE1: SDTV_CP_MODE_T = 1;
pub const SDTV_CP_MODE_T_SDTV_CP_MACROVISION_TYPE2: SDTV_CP_MODE_T = 2;
pub const SDTV_CP_MODE_T_SDTV_CP_MACROVISION_TYPE3: SDTV_CP_MODE_T = 3;
pub const SDTV_CP_MODE_T_SDTV_CP_MACROVISION_TEST1: SDTV_CP_MODE_T = 4;
pub const SDTV_CP_MODE_T_SDTV_CP_MACROVISION_TEST2: SDTV_CP_MODE_T = 5;
pub const SDTV_CP_MODE_T_SDTV_CP_CGMS_COPYFREE: SDTV_CP_MODE_T = 6;
pub const SDTV_CP_MODE_T_SDTV_CP_CGMS_COPYNOMORE: SDTV_CP_MODE_T = 7;
pub const SDTV_CP_MODE_T_SDTV_CP_CGMS_COPYONCE: SDTV_CP_MODE_T = 8;
pub const SDTV_CP_MODE_T_SDTV_CP_CGMS_COPYNEVER: SDTV_CP_MODE_T = 9;
pub const SDTV_CP_MODE_T_SDTV_CP_WSS_COPYFREE: SDTV_CP_MODE_T = 10;
pub const SDTV_CP_MODE_T_SDTV_CP_WSS_COPYRIGHT_COPYFREE: SDTV_CP_MODE_T = 11;
pub const SDTV_CP_MODE_T_SDTV_CP_WSS_NOCOPY: SDTV_CP_MODE_T = 12;
pub const SDTV_CP_MODE_T_SDTV_CP_WSS_COPYRIGHT_NOCOPY: SDTV_CP_MODE_T = 13;
pub const SDTV_CP_MODE_T_SDTV_CP_FORCE_32BIT: SDTV_CP_MODE_T = 2147483648;
pub type SDTV_CP_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SDTV_DISPLAY_STATE_T {
    pub state: u32,
    pub width: u32,
    pub height: u32,
    pub frame_rate: u16,
    pub scan_mode: u16,
    pub mode: SDTV_MODE_T,
    pub display_options: SDTV_OPTIONS_T,
    pub colour: SDTV_COLOUR_T,
    pub cp_mode: SDTV_CP_MODE_T,
}
#[test]
fn bindgen_test_layout_SDTV_DISPLAY_STATE_T() {
    assert_eq!(
        ::std::mem::size_of::<SDTV_DISPLAY_STATE_T>(),
        32usize,
        concat!("Size of: ", stringify!(SDTV_DISPLAY_STATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<SDTV_DISPLAY_STATE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(SDTV_DISPLAY_STATE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).frame_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).scan_mode as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(scan_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).mode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).display_options as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(display_options)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).colour as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(colour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<SDTV_DISPLAY_STATE_T>())).cp_mode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(SDTV_DISPLAY_STATE_T),
            "::",
            stringify!(cp_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TV_GET_STATE_RESP_T {
    pub state: u32,
    pub width: u32,
    pub height: u32,
    pub frame_rate: u16,
    pub scan_mode: u16,
}
#[test]
fn bindgen_test_layout_TV_GET_STATE_RESP_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_GET_STATE_RESP_T>(),
        16usize,
        concat!("Size of: ", stringify!(TV_GET_STATE_RESP_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_GET_STATE_RESP_T>(),
        4usize,
        concat!("Alignment of ", stringify!(TV_GET_STATE_RESP_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_GET_STATE_RESP_T>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_GET_STATE_RESP_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_GET_STATE_RESP_T>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_GET_STATE_RESP_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_GET_STATE_RESP_T>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_GET_STATE_RESP_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_GET_STATE_RESP_T>())).frame_rate as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_GET_STATE_RESP_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_GET_STATE_RESP_T>())).scan_mode as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_GET_STATE_RESP_T),
            "::",
            stringify!(scan_mode)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TV_SUPPORTED_MODE_NEW_T {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize]>,
    pub frame_rate: u16,
    pub width: u16,
    pub height: u16,
    pub pixel_freq: u32,
    pub struct_3d_mask: u32,
}
#[test]
fn bindgen_test_layout_TV_SUPPORTED_MODE_NEW_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_SUPPORTED_MODE_NEW_T>(),
        20usize,
        concat!("Size of: ", stringify!(TV_SUPPORTED_MODE_NEW_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_SUPPORTED_MODE_NEW_T>(),
        4usize,
        concat!("Alignment of ", stringify!(TV_SUPPORTED_MODE_NEW_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_SUPPORTED_MODE_NEW_T>())).frame_rate as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_NEW_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_SUPPORTED_MODE_NEW_T>())).width as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_NEW_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_SUPPORTED_MODE_NEW_T>())).height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_NEW_T),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_SUPPORTED_MODE_NEW_T>())).pixel_freq as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_NEW_T),
            "::",
            stringify!(pixel_freq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_SUPPORTED_MODE_NEW_T>())).struct_3d_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_NEW_T),
            "::",
            stringify!(struct_3d_mask)
        )
    );
}
impl TV_SUPPORTED_MODE_NEW_T {
    #[inline]
    pub fn scan_mode(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_scan_mode(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn native(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_native(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn group(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_group(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn code(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(5usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_code(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(5usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn pixel_rep(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(12usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_pixel_rep(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(12usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn aspect_ratio(&self) -> u32 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(15usize, 5u8) as u32) }
    }
    #[inline]
    pub fn set_aspect_ratio(&mut self, val: u32) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(15usize, 5u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scan_mode: u32,
        native: u32,
        group: u32,
        code: u32,
        pixel_rep: u32,
        aspect_ratio: u32,
    ) -> __BindgenBitfieldUnit<[u8; 3usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scan_mode: u32 = unsafe { ::std::mem::transmute(scan_mode) };
            scan_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let native: u32 = unsafe { ::std::mem::transmute(native) };
            native as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let group: u32 = unsafe { ::std::mem::transmute(group) };
            group as u64
        });
        __bindgen_bitfield_unit.set(5usize, 7u8, {
            let code: u32 = unsafe { ::std::mem::transmute(code) };
            code as u64
        });
        __bindgen_bitfield_unit.set(12usize, 3u8, {
            let pixel_rep: u32 = unsafe { ::std::mem::transmute(pixel_rep) };
            pixel_rep as u64
        });
        __bindgen_bitfield_unit.set(15usize, 5u8, {
            let aspect_ratio: u32 = unsafe { ::std::mem::transmute(aspect_ratio) };
            aspect_ratio as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TV_SUPPORTED_MODE_T {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize]>,
    pub frame_rate: u16,
    pub width: u16,
    pub height: u16,
}
#[test]
fn bindgen_test_layout_TV_SUPPORTED_MODE_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_SUPPORTED_MODE_T>(),
        8usize,
        concat!("Size of: ", stringify!(TV_SUPPORTED_MODE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_SUPPORTED_MODE_T>(),
        2usize,
        concat!("Alignment of ", stringify!(TV_SUPPORTED_MODE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_SUPPORTED_MODE_T>())).frame_rate as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_T),
            "::",
            stringify!(frame_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_SUPPORTED_MODE_T>())).width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_T),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_SUPPORTED_MODE_T>())).height as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_SUPPORTED_MODE_T),
            "::",
            stringify!(height)
        )
    );
}
impl TV_SUPPORTED_MODE_T {
    #[inline]
    pub fn scan_mode(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_scan_mode(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn native(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u16) }
    }
    #[inline]
    pub fn set_native(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn code(&self) -> u16 {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(2usize, 7u8) as u16) }
    }
    #[inline]
    pub fn set_code(&mut self, val: u16) {
        unsafe {
            let val: u16 = ::std::mem::transmute(val);
            self._bitfield_1.set(2usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        scan_mode: u16,
        native: u16,
        code: u16,
    ) -> __BindgenBitfieldUnit<[u8; 2usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 2usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let scan_mode: u16 = unsafe { ::std::mem::transmute(scan_mode) };
            scan_mode as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let native: u16 = unsafe { ::std::mem::transmute(native) };
            native as u64
        });
        __bindgen_bitfield_unit.set(2usize, 7u8, {
            let code: u16 = unsafe { ::std::mem::transmute(code) };
            code as u64
        });
        __bindgen_bitfield_unit
    }
}
pub const TV_TEST_MODE_T_TV_TEST_MODE_DISABLED: TV_TEST_MODE_T = 0;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SOLID_BACKGND: TV_TEST_MODE_T = 1;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SOLID_VERTICAL: TV_TEST_MODE_T = 2;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SHADED_VERTICAL: TV_TEST_MODE_T = 3;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SHADED_WHITE_V: TV_TEST_MODE_T = 4;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SHADED_WHITE_H: TV_TEST_MODE_T = 5;
pub const TV_TEST_MODE_T_TV_TEST_MODE_SHADED_RGB: TV_TEST_MODE_T = 6;
pub const TV_TEST_MODE_T_TV_TEST_MODE_WALKING: TV_TEST_MODE_T = 7;
pub const TV_TEST_MODE_T_TV_TEST_MODE_DELAYED: TV_TEST_MODE_T = 8;
pub const TV_TEST_MODE_T_TV_TEST_MODE_HVD: TV_TEST_MODE_T = 9;
pub const TV_TEST_MODE_T_TV_TEST_MODE_ODD_CH: TV_TEST_MODE_T = 10;
pub const TV_TEST_MODE_T_TV_TEST_MODE_EVEN_CH: TV_TEST_MODE_T = 11;
pub const TV_TEST_MODE_T_TV_TEST_MODE_32x32: TV_TEST_MODE_T = 12;
pub const TV_TEST_MODE_T_TV_TEST_MODE_WYCGMRBK_SOLID: TV_TEST_MODE_T = 13;
pub const TV_TEST_MODE_T_TV_TEST_MODE_WYCGMRBK_SHADED: TV_TEST_MODE_T = 14;
pub const TV_TEST_MODE_T_TV_TEST_MODE_32x32_DIAGONAL: TV_TEST_MODE_T = 15;
pub type TV_TEST_MODE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TV_DISPLAY_STATE_T {
    pub state: u32,
    pub display: TV_DISPLAY_STATE_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TV_DISPLAY_STATE_T__bindgen_ty_1 {
    pub sdtv: SDTV_DISPLAY_STATE_T,
    pub hdmi: HDMI_DISPLAY_STATE_T,
}
#[test]
fn bindgen_test_layout_TV_DISPLAY_STATE_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<TV_DISPLAY_STATE_T__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(TV_DISPLAY_STATE_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_DISPLAY_STATE_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TV_DISPLAY_STATE_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_DISPLAY_STATE_T__bindgen_ty_1>())).sdtv as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DISPLAY_STATE_T__bindgen_ty_1),
            "::",
            stringify!(sdtv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_DISPLAY_STATE_T__bindgen_ty_1>())).hdmi as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DISPLAY_STATE_T__bindgen_ty_1),
            "::",
            stringify!(hdmi)
        )
    );
}
#[test]
fn bindgen_test_layout_TV_DISPLAY_STATE_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_DISPLAY_STATE_T>(),
        52usize,
        concat!("Size of: ", stringify!(TV_DISPLAY_STATE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_DISPLAY_STATE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(TV_DISPLAY_STATE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_DISPLAY_STATE_T>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DISPLAY_STATE_T),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_DISPLAY_STATE_T>())).display as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DISPLAY_STATE_T),
            "::",
            stringify!(display)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TV_DEVICE_ID_T {
    pub vendor: [::std::os::raw::c_char; 4usize],
    pub monitor_name: [::std::os::raw::c_char; 14usize],
    pub serial_num: u32,
}
#[test]
fn bindgen_test_layout_TV_DEVICE_ID_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_DEVICE_ID_T>(),
        24usize,
        concat!("Size of: ", stringify!(TV_DEVICE_ID_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_DEVICE_ID_T>(),
        4usize,
        concat!("Alignment of ", stringify!(TV_DEVICE_ID_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_DEVICE_ID_T>())).vendor as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DEVICE_ID_T),
            "::",
            stringify!(vendor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_DEVICE_ID_T>())).monitor_name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DEVICE_ID_T),
            "::",
            stringify!(monitor_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TV_DEVICE_ID_T>())).serial_num as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_DEVICE_ID_T),
            "::",
            stringify!(serial_num)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TV_ATTACHED_DEVICES_T {
    pub num_attached: i32,
    pub display_number: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_TV_ATTACHED_DEVICES_T() {
    assert_eq!(
        ::std::mem::size_of::<TV_ATTACHED_DEVICES_T>(),
        20usize,
        concat!("Size of: ", stringify!(TV_ATTACHED_DEVICES_T))
    );
    assert_eq!(
        ::std::mem::align_of::<TV_ATTACHED_DEVICES_T>(),
        4usize,
        concat!("Alignment of ", stringify!(TV_ATTACHED_DEVICES_T))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_ATTACHED_DEVICES_T>())).num_attached as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_ATTACHED_DEVICES_T),
            "::",
            stringify!(num_attached)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TV_ATTACHED_DEVICES_T>())).display_number as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TV_ATTACHED_DEVICES_T),
            "::",
            stringify!(display_number)
        )
    );
}
pub type TVSERVICE_CALLBACK_T = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        reason: u32,
        param1: u32,
        param2: u32,
    ),
>;
pub const CEC_AllDevices_CEC_AllDevices_eTV: CEC_AllDevices = 0;
pub const CEC_AllDevices_CEC_AllDevices_eRec1: CEC_AllDevices = 1;
pub const CEC_AllDevices_CEC_AllDevices_eRec2: CEC_AllDevices = 2;
pub const CEC_AllDevices_CEC_AllDevices_eSTB1: CEC_AllDevices = 3;
pub const CEC_AllDevices_CEC_AllDevices_eDVD1: CEC_AllDevices = 4;
pub const CEC_AllDevices_CEC_AllDevices_eAudioSystem: CEC_AllDevices = 5;
pub const CEC_AllDevices_CEC_AllDevices_eSTB2: CEC_AllDevices = 6;
pub const CEC_AllDevices_CEC_AllDevices_eSTB3: CEC_AllDevices = 7;
pub const CEC_AllDevices_CEC_AllDevices_eDVD2: CEC_AllDevices = 8;
pub const CEC_AllDevices_CEC_AllDevices_eRec3: CEC_AllDevices = 9;
pub const CEC_AllDevices_CEC_AllDevices_eSTB4: CEC_AllDevices = 10;
pub const CEC_AllDevices_CEC_AllDevices_eDVD3: CEC_AllDevices = 11;
pub const CEC_AllDevices_CEC_AllDevices_eRsvd3: CEC_AllDevices = 12;
pub const CEC_AllDevices_CEC_AllDevices_eRsvd4: CEC_AllDevices = 13;
pub const CEC_AllDevices_CEC_AllDevices_eFreeUse: CEC_AllDevices = 14;
pub const CEC_AllDevices_CEC_AllDevices_eUnRegistered: CEC_AllDevices = 15;
pub type CEC_AllDevices = ::std::os::raw::c_uint;
pub use self::CEC_AllDevices as CEC_AllDevices_T;
pub const CEC_DeviceTypes_CEC_DeviceType_TV: CEC_DeviceTypes = 0;
pub const CEC_DeviceTypes_CEC_DeviceType_Rec: CEC_DeviceTypes = 1;
pub const CEC_DeviceTypes_CEC_DeviceType_Reserved: CEC_DeviceTypes = 2;
pub const CEC_DeviceTypes_CEC_DeviceType_Tuner: CEC_DeviceTypes = 3;
pub const CEC_DeviceTypes_CEC_DeviceType_Playback: CEC_DeviceTypes = 4;
pub const CEC_DeviceTypes_CEC_DeviceType_Audio: CEC_DeviceTypes = 5;
pub const CEC_DeviceTypes_CEC_DeviceType_Switch: CEC_DeviceTypes = 6;
pub const CEC_DeviceTypes_CEC_DeviceType_VidProc: CEC_DeviceTypes = 7;
pub const CEC_DeviceTypes_CEC_DeviceType_Invalid: CEC_DeviceTypes = 15;
pub type CEC_DeviceTypes = ::std::os::raw::c_uint;
pub use self::CEC_DeviceTypes as CEC_DEVICE_TYPE_T;
pub const CEC_OPCODE_T_CEC_Opcode_FeatureAbort: CEC_OPCODE_T = 0;
pub const CEC_OPCODE_T_CEC_Opcode_ImageViewOn: CEC_OPCODE_T = 4;
pub const CEC_OPCODE_T_CEC_Opcode_TunerStepIncrement: CEC_OPCODE_T = 5;
pub const CEC_OPCODE_T_CEC_Opcode_TunerStepDecrement: CEC_OPCODE_T = 6;
pub const CEC_OPCODE_T_CEC_Opcode_TunerDeviceStatus: CEC_OPCODE_T = 7;
pub const CEC_OPCODE_T_CEC_Opcode_GiveTunerDeviceStatus: CEC_OPCODE_T = 8;
pub const CEC_OPCODE_T_CEC_Opcode_RecordOn: CEC_OPCODE_T = 9;
pub const CEC_OPCODE_T_CEC_Opcode_RecordStatus: CEC_OPCODE_T = 10;
pub const CEC_OPCODE_T_CEC_Opcode_RecordOff: CEC_OPCODE_T = 11;
pub const CEC_OPCODE_T_CEC_Opcode_TextViewOn: CEC_OPCODE_T = 13;
pub const CEC_OPCODE_T_CEC_Opcode_RecordTVScreen: CEC_OPCODE_T = 15;
pub const CEC_OPCODE_T_CEC_Opcode_GiveDeckStatus: CEC_OPCODE_T = 26;
pub const CEC_OPCODE_T_CEC_Opcode_DeckStatus: CEC_OPCODE_T = 27;
pub const CEC_OPCODE_T_CEC_Opcode_SetMenuLanguage: CEC_OPCODE_T = 50;
pub const CEC_OPCODE_T_CEC_Opcode_ClearAnalogTimer: CEC_OPCODE_T = 51;
pub const CEC_OPCODE_T_CEC_Opcode_SetAnalogTimer: CEC_OPCODE_T = 52;
pub const CEC_OPCODE_T_CEC_Opcode_TimerStatus: CEC_OPCODE_T = 53;
pub const CEC_OPCODE_T_CEC_Opcode_Standby: CEC_OPCODE_T = 54;
pub const CEC_OPCODE_T_CEC_Opcode_Play: CEC_OPCODE_T = 65;
pub const CEC_OPCODE_T_CEC_Opcode_DeckControl: CEC_OPCODE_T = 66;
pub const CEC_OPCODE_T_CEC_Opcode_TimerClearedStatus: CEC_OPCODE_T = 67;
pub const CEC_OPCODE_T_CEC_Opcode_UserControlPressed: CEC_OPCODE_T = 68;
pub const CEC_OPCODE_T_CEC_Opcode_UserControlReleased: CEC_OPCODE_T = 69;
pub const CEC_OPCODE_T_CEC_Opcode_GiveOSDName: CEC_OPCODE_T = 70;
pub const CEC_OPCODE_T_CEC_Opcode_SetOSDName: CEC_OPCODE_T = 71;
pub const CEC_OPCODE_T_CEC_Opcode_SetOSDString: CEC_OPCODE_T = 100;
pub const CEC_OPCODE_T_CEC_Opcode_SetTimerProgramTitle: CEC_OPCODE_T = 103;
pub const CEC_OPCODE_T_CEC_Opcode_SystemAudioModeRequest: CEC_OPCODE_T = 112;
pub const CEC_OPCODE_T_CEC_Opcode_GiveAudioStatus: CEC_OPCODE_T = 113;
pub const CEC_OPCODE_T_CEC_Opcode_SetSystemAudioMode: CEC_OPCODE_T = 114;
pub const CEC_OPCODE_T_CEC_Opcode_ReportAudioStatus: CEC_OPCODE_T = 122;
pub const CEC_OPCODE_T_CEC_Opcode_GiveSystemAudioModeStatus: CEC_OPCODE_T = 125;
pub const CEC_OPCODE_T_CEC_Opcode_SystemAudioModeStatus: CEC_OPCODE_T = 126;
pub const CEC_OPCODE_T_CEC_Opcode_RoutingChange: CEC_OPCODE_T = 128;
pub const CEC_OPCODE_T_CEC_Opcode_RoutingInformation: CEC_OPCODE_T = 129;
pub const CEC_OPCODE_T_CEC_Opcode_ActiveSource: CEC_OPCODE_T = 130;
pub const CEC_OPCODE_T_CEC_Opcode_GivePhysicalAddress: CEC_OPCODE_T = 131;
pub const CEC_OPCODE_T_CEC_Opcode_ReportPhysicalAddress: CEC_OPCODE_T = 132;
pub const CEC_OPCODE_T_CEC_Opcode_RequestActiveSource: CEC_OPCODE_T = 133;
pub const CEC_OPCODE_T_CEC_Opcode_SetStreamPath: CEC_OPCODE_T = 134;
pub const CEC_OPCODE_T_CEC_Opcode_DeviceVendorID: CEC_OPCODE_T = 135;
pub const CEC_OPCODE_T_CEC_Opcode_VendorCommand: CEC_OPCODE_T = 137;
pub const CEC_OPCODE_T_CEC_Opcode_VendorRemoteButtonDown: CEC_OPCODE_T = 138;
pub const CEC_OPCODE_T_CEC_Opcode_VendorRemoteButtonUp: CEC_OPCODE_T = 139;
pub const CEC_OPCODE_T_CEC_Opcode_GiveDeviceVendorID: CEC_OPCODE_T = 140;
pub const CEC_OPCODE_T_CEC_Opcode_MenuRequest: CEC_OPCODE_T = 141;
pub const CEC_OPCODE_T_CEC_Opcode_MenuStatus: CEC_OPCODE_T = 142;
pub const CEC_OPCODE_T_CEC_Opcode_GiveDevicePowerStatus: CEC_OPCODE_T = 143;
pub const CEC_OPCODE_T_CEC_Opcode_ReportPowerStatus: CEC_OPCODE_T = 144;
pub const CEC_OPCODE_T_CEC_Opcode_GetMenuLanguage: CEC_OPCODE_T = 145;
pub const CEC_OPCODE_T_CEC_Opcode_SelectAnalogService: CEC_OPCODE_T = 146;
pub const CEC_OPCODE_T_CEC_Opcode_SelectDigitalService: CEC_OPCODE_T = 147;
pub const CEC_OPCODE_T_CEC_Opcode_SetDigitalTimer: CEC_OPCODE_T = 151;
pub const CEC_OPCODE_T_CEC_Opcode_ClearDigitalTimer: CEC_OPCODE_T = 153;
pub const CEC_OPCODE_T_CEC_Opcode_SetAudioRate: CEC_OPCODE_T = 154;
pub const CEC_OPCODE_T_CEC_Opcode_InactiveSource: CEC_OPCODE_T = 157;
pub const CEC_OPCODE_T_CEC_Opcode_CECVersion: CEC_OPCODE_T = 158;
pub const CEC_OPCODE_T_CEC_Opcode_GetCECVersion: CEC_OPCODE_T = 159;
pub const CEC_OPCODE_T_CEC_Opcode_VendorCommandWithID: CEC_OPCODE_T = 160;
pub const CEC_OPCODE_T_CEC_Opcode_ClearExternalTimer: CEC_OPCODE_T = 161;
pub const CEC_OPCODE_T_CEC_Opcode_SetExternalTimer: CEC_OPCODE_T = 162;
pub const CEC_OPCODE_T_CEC_Opcode_ReportShortAudioDescriptor: CEC_OPCODE_T = 163;
pub const CEC_OPCODE_T_CEC_Opcode_RequestShortAudioDescriptor: CEC_OPCODE_T = 164;
pub const CEC_OPCODE_T_CEC_Opcode_InitARC: CEC_OPCODE_T = 192;
pub const CEC_OPCODE_T_CEC_Opcode_ReportARCInited: CEC_OPCODE_T = 193;
pub const CEC_OPCODE_T_CEC_Opcode_ReportARCTerminated: CEC_OPCODE_T = 194;
pub const CEC_OPCODE_T_CEC_Opcode_RequestARCInit: CEC_OPCODE_T = 195;
pub const CEC_OPCODE_T_CEC_Opcode_RequestARCTermination: CEC_OPCODE_T = 196;
pub const CEC_OPCODE_T_CEC_Opcode_TerminateARC: CEC_OPCODE_T = 197;
pub const CEC_OPCODE_T_CEC_Opcode_CDC: CEC_OPCODE_T = 248;
pub const CEC_OPCODE_T_CEC_Opcode_Abort: CEC_OPCODE_T = 255;
pub type CEC_OPCODE_T = ::std::os::raw::c_uint;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Unrecognised_Opcode: CEC_ABORT_REASON_T = 0;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Wrong_Mode: CEC_ABORT_REASON_T = 1;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Cannot_Provide_Source: CEC_ABORT_REASON_T = 2;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Invalid_Operand: CEC_ABORT_REASON_T = 3;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Refused: CEC_ABORT_REASON_T = 4;
pub const CEC_ABORT_REASON_T_CEC_Abort_Reason_Undetermined: CEC_ABORT_REASON_T = 5;
pub type CEC_ABORT_REASON_T = ::std::os::raw::c_uint;
pub const CEC_DISPLAY_CONTROL_T_CEC_DISPLAY_CONTROL_DEFAULT_TIME: CEC_DISPLAY_CONTROL_T = 0;
pub const CEC_DISPLAY_CONTROL_T_CEC_DISPLAY_CONTROL_UNTIL_CLEARED: CEC_DISPLAY_CONTROL_T = 64;
pub const CEC_DISPLAY_CONTROL_T_CEC_DISPLAY_CONTROL_CLEAR_PREV_MSG: CEC_DISPLAY_CONTROL_T = 128;
pub type CEC_DISPLAY_CONTROL_T = ::std::os::raw::c_uint;
pub const CEC_MENU_STATE_T_CEC_MENU_STATE_ACTIVATED: CEC_MENU_STATE_T = 0;
pub const CEC_MENU_STATE_T_CEC_MENU_STATE_DEACTIVATED: CEC_MENU_STATE_T = 1;
pub const CEC_MENU_STATE_T_CEC_MENU_STATE_QUERY: CEC_MENU_STATE_T = 2;
pub type CEC_MENU_STATE_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VC_CEC_TOPOLOGY_T {
    pub active_mask: u16,
    pub num_devices: u16,
    pub device_attr: [u32; 16usize],
}
#[test]
fn bindgen_test_layout_VC_CEC_TOPOLOGY_T() {
    assert_eq!(
        ::std::mem::size_of::<VC_CEC_TOPOLOGY_T>(),
        68usize,
        concat!("Size of: ", stringify!(VC_CEC_TOPOLOGY_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VC_CEC_TOPOLOGY_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VC_CEC_TOPOLOGY_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_TOPOLOGY_T>())).active_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_TOPOLOGY_T),
            "::",
            stringify!(active_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_TOPOLOGY_T>())).num_devices as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_TOPOLOGY_T),
            "::",
            stringify!(num_devices)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_TOPOLOGY_T>())).device_attr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_TOPOLOGY_T),
            "::",
            stringify!(device_attr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VC_CEC_MESSAGE_T {
    pub length: u32,
    pub initiator: CEC_AllDevices_T,
    pub follower: CEC_AllDevices_T,
    pub payload: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_VC_CEC_MESSAGE_T() {
    assert_eq!(
        ::std::mem::size_of::<VC_CEC_MESSAGE_T>(),
        28usize,
        concat!("Size of: ", stringify!(VC_CEC_MESSAGE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VC_CEC_MESSAGE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VC_CEC_MESSAGE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_MESSAGE_T>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_MESSAGE_T),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_MESSAGE_T>())).initiator as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_MESSAGE_T),
            "::",
            stringify!(initiator)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_MESSAGE_T>())).follower as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_MESSAGE_T),
            "::",
            stringify!(follower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VC_CEC_MESSAGE_T>())).payload as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VC_CEC_MESSAGE_T),
            "::",
            stringify!(payload)
        )
    );
}
pub type CECSERVICE_CALLBACK_T = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        reason: u32,
        param1: u32,
        param2: u32,
        param3: u32,
        param4: u32,
    ),
>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_IMPL_T {
    pub _address: u8,
}
extern crate libloading;
pub struct libbcm_host {
    __library: ::libloading::Library,
    pub bcm_host_init: unsafe extern "C" fn(),
    pub bcm_host_deinit: unsafe extern "C" fn(),
    pub graphics_get_display_size:
        unsafe extern "C" fn(display_number: u16, width: *mut u32, height: *mut u32) -> i32,
    pub bcm_host_get_peripheral_address: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub bcm_host_get_peripheral_size: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub bcm_host_get_sdram_address: unsafe extern "C" fn() -> ::std::os::raw::c_uint,
    pub vcos_pthreads_logging_assert: unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_verify_bkpts_enabled: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_verify_bkpts_enable:
        unsafe extern "C" fn(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    pub vcos_abort: unsafe extern "C" fn(),
    pub vcos_backtrace_self: unsafe extern "C" fn(),
    pub vcos_generic_event_flags_create: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_event_flags_set: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ),
    pub vcos_generic_event_flags_delete: unsafe extern "C" fn(arg1: *mut VCOS_EVENT_FLAGS_T),
    pub vcos_generic_event_flags_get: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_init: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_create_on_heap: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_extend: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_alloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_calloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_free: unsafe extern "C" fn(block: *mut ::std::os::raw::c_void),
    pub vcos_generic_blockpool_available_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_used_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_delete: unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T),
    pub vcos_generic_blockpool_elem_to_handle:
        unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> u32,
    pub vcos_generic_blockpool_elem_from_handle:
        unsafe extern "C" fn(
            pool: *mut VCOS_BLOCKPOOL_T,
            handle: u32,
        ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_is_valid_elem: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32,
    pub vcos_generic_mem_alloc: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_calloc: unsafe extern "C" fn(
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_free: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
    pub vcos_generic_mem_alloc_aligned: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_pthreads_map_error:
        unsafe extern "C" fn(error: ::std::os::raw::c_int) -> VCOS_STATUS_T,
    pub vcos_pthreads_map_errno: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_thread_at_exit: unsafe extern "C" fn(
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_dummy_thread_create: unsafe extern "C" fn() -> *mut VCOS_THREAD_T,
    pub vcos_getmicrosecs64_internal: unsafe extern "C" fn() -> u64,
    pub vcos_pthreads_timer_create: unsafe extern "C" fn(
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_pthreads_timer_set:
        unsafe extern "C" fn(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED),
    pub vcos_pthreads_timer_cancel: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_pthreads_timer_delete: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_generic_reentrant_mutex_create: unsafe extern "C" fn(
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_reentrant_mutex_delete: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_lock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_unlock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_named_semaphore_create: unsafe extern "C" fn(
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_named_semaphore_delete: unsafe extern "C" fn(sem: *mut VCOS_NAMED_SEMAPHORE_T),
    pub vcos_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_deinit: unsafe extern "C" fn(),
    pub vcos_global_lock: unsafe extern "C" fn(),
    pub vcos_global_unlock: unsafe extern "C" fn(),
    pub vcos_set_args:
        unsafe extern "C" fn(argc: ::std::os::raw::c_int, argv: *mut *const ::std::os::raw::c_char),
    pub vcos_get_argc: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_get_argv: unsafe extern "C" fn() -> *mut *const ::std::os::raw::c_char,
    pub vcos_platform_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_platform_deinit: unsafe extern "C" fn(),
    pub vcos_have_rtos: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_thread_create: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_exit: unsafe extern "C" fn(data: *mut ::std::os::raw::c_void),
    pub vcos_thread_join:
        unsafe extern "C" fn(thread: *mut VCOS_THREAD_T, pData: *mut *mut ::std::os::raw::c_void),
    pub vcos_thread_create_classic: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_get_name:
        unsafe extern "C" fn(thread: *const VCOS_THREAD_T) -> *const ::std::os::raw::c_char,
    pub vcos_kcalloc: unsafe extern "C" fn(
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_kfree: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
    pub vcos_log_level_to_string:
        unsafe extern "C" fn(level: VCOS_LOG_LEVEL_T) -> *const ::std::os::raw::c_char,
    pub vcos_string_to_log_level: unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T,
    pub vcos_log_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_vlog_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_set_vlog_impl: unsafe extern "C" fn(vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T),
    pub vcos_vlog_default_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_logging_init: unsafe extern "C" fn(),
    pub vcos_log_register:
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char, category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_unregister: unsafe extern "C" fn(category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_get_default_category: unsafe extern "C" fn() -> *const VCOS_LOG_CAT_T,
    pub vcos_set_log_options: unsafe extern "C" fn(opt: *const ::std::os::raw::c_char),
    pub vcos_log_set_level_all: unsafe extern "C" fn(levels: *mut ::std::os::raw::c_char),
    pub vcos_log_dump_mem_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ),
    pub vcos_cmd_error:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_printf:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_vprintf: unsafe extern "C" fn(
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_cmd_always_log_output: unsafe extern "C" fn(log_category: *mut VCOS_LOG_CAT_T),
    pub vcos_cmd_usage: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T),
    pub vcos_cmd_register: unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_register_multiple:
        unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_execute: unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_cmd_shutdown: unsafe extern "C" fn(),
    pub vcos_log_assert_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_set_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_status_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_test_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_vsnprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int,
    pub vcos_snprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
    pub vcos_safe_vsprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t,
    pub vcos_safe_sprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> size_t,
    pub vcos_safe_strcpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_safe_strncpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_thread_attr_init: unsafe extern "C" fn(attrs: *mut VCOS_THREAD_ATTR_T),
    pub vcos_timer_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_once: unsafe extern "C" fn(
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T,
    pub vc_dispman_init: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_dispmanx_stop: unsafe extern "C" fn(),
    pub vc_dispmanx_rect_set: unsafe extern "C" fn(
        rect: *mut VC_RECT_T,
        x_offset: u32,
        y_offset: u32,
        width: u32,
        height: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_create: unsafe extern "C" fn(
        type_: VC_IMAGE_TYPE_T,
        width: u32,
        height: u32,
        native_image_handle: *mut u32,
    ) -> DISPMANX_RESOURCE_HANDLE_T,
    pub vc_dispmanx_resource_write_data: unsafe extern "C" fn(
        res: DISPMANX_RESOURCE_HANDLE_T,
        src_type: VC_IMAGE_TYPE_T,
        src_pitch: ::std::os::raw::c_int,
        src_address: *mut ::std::os::raw::c_void,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_write_data_handle: unsafe extern "C" fn(
        res: DISPMANX_RESOURCE_HANDLE_T,
        src_type: VC_IMAGE_TYPE_T,
        src_pitch: ::std::os::raw::c_int,
        handle: VCHI_MEM_HANDLE_T,
        offset: u32,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_read_data: unsafe extern "C" fn(
        handle: DISPMANX_RESOURCE_HANDLE_T,
        p_rect: *const VC_RECT_T,
        dst_address: *mut ::std::os::raw::c_void,
        dst_pitch: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_delete:
        unsafe extern "C" fn(res: DISPMANX_RESOURCE_HANDLE_T) -> ::std::os::raw::c_int,
    pub vc_dispmanx_display_open: unsafe extern "C" fn(device: u32) -> DISPMANX_DISPLAY_HANDLE_T,
    pub vc_dispmanx_display_open_mode:
        unsafe extern "C" fn(device: u32, mode: u32) -> DISPMANX_DISPLAY_HANDLE_T,
    pub vc_dispmanx_display_open_offscreen: unsafe extern "C" fn(
        dest: DISPMANX_RESOURCE_HANDLE_T,
        orientation: DISPMANX_TRANSFORM_T,
    ) -> DISPMANX_DISPLAY_HANDLE_T,
    pub vc_dispmanx_display_reconfigure: unsafe extern "C" fn(
        display: DISPMANX_DISPLAY_HANDLE_T,
        mode: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_display_set_destination: unsafe extern "C" fn(
        display: DISPMANX_DISPLAY_HANDLE_T,
        dest: DISPMANX_RESOURCE_HANDLE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_display_set_background: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        display: DISPMANX_DISPLAY_HANDLE_T,
        red: u8,
        green: u8,
        blue: u8,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_display_get_info: unsafe extern "C" fn(
        display: DISPMANX_DISPLAY_HANDLE_T,
        pinfo: *mut DISPMANX_MODEINFO_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_display_close:
        unsafe extern "C" fn(display: DISPMANX_DISPLAY_HANDLE_T) -> ::std::os::raw::c_int,
    pub vc_dispmanx_update_start: unsafe extern "C" fn(priority: i32) -> DISPMANX_UPDATE_HANDLE_T,
    pub vc_dispmanx_element_add: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        display: DISPMANX_DISPLAY_HANDLE_T,
        layer: i32,
        dest_rect: *const VC_RECT_T,
        src: DISPMANX_RESOURCE_HANDLE_T,
        src_rect: *const VC_RECT_T,
        protection: DISPMANX_PROTECTION_T,
        alpha: *mut VC_DISPMANX_ALPHA_T,
        clamp: *mut DISPMANX_CLAMP_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> DISPMANX_ELEMENT_HANDLE_T,
    pub vc_dispmanx_element_change_source: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        src: DISPMANX_RESOURCE_HANDLE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_element_change_layer: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        layer: i32,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_element_modified: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_element_remove: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_update_submit: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        cb_func: DISPMANX_CALLBACK_FUNC_T,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_update_submit_sync:
        unsafe extern "C" fn(update: DISPMANX_UPDATE_HANDLE_T) -> ::std::os::raw::c_int,
    pub vc_dispmanx_query_image_formats:
        unsafe extern "C" fn(supported_formats: *mut u32) -> ::std::os::raw::c_int,
    pub vc_dispmanx_element_change_attributes: unsafe extern "C" fn(
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        change_flags: u32,
        layer: i32,
        opacity: u8,
        dest_rect: *const VC_RECT_T,
        src_rect: *const VC_RECT_T,
        mask: DISPMANX_RESOURCE_HANDLE_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_get_image_handle:
        unsafe extern "C" fn(res: DISPMANX_RESOURCE_HANDLE_T) -> u32,
    pub vc_vchi_dispmanx_init: unsafe extern "C" fn(
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ),
    pub vc_dispmanx_snapshot: unsafe extern "C" fn(
        display: DISPMANX_DISPLAY_HANDLE_T,
        snapshot_resource: DISPMANX_RESOURCE_HANDLE_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_resource_set_palette: unsafe extern "C" fn(
        handle: DISPMANX_RESOURCE_HANDLE_T,
        src_address: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_dispmanx_vsync_callback: unsafe extern "C" fn(
        display: DISPMANX_DISPLAY_HANDLE_T,
        cb_func: DISPMANX_CALLBACK_FUNC_T,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
    pub vc_vchi_tv_init: unsafe extern "C" fn(
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_vchi_tv_stop: unsafe extern "C" fn(),
    pub vc_tv_register_callback: unsafe extern "C" fn(
        callback: TVSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ),
    pub vc_tv_unregister_callback: unsafe extern "C" fn(callback: TVSERVICE_CALLBACK_T),
    pub vc_tv_unregister_callback_full: unsafe extern "C" fn(
        callback: TVSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ),
    pub vc_tv_get_state:
        unsafe extern "C" fn(tvstate: *mut TV_GET_STATE_RESP_T) -> ::std::os::raw::c_int,
    pub vc_tv_get_state_id: unsafe extern "C" fn(
        display_id: u32,
        tvstate: *mut TV_GET_STATE_RESP_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_get_display_state:
        unsafe extern "C" fn(tvstate: *mut TV_DISPLAY_STATE_T) -> ::std::os::raw::c_int,
    pub vc_tv_get_display_state_id: unsafe extern "C" fn(
        display_id: u32,
        tvstate: *mut TV_DISPLAY_STATE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_preferred: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_preferred_id:
        unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_preferred_3d: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_preferred_3d_id:
        unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_best: unsafe extern "C" fn(
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_best_id: unsafe extern "C" fn(
        display_id: u32,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_best_3d: unsafe extern "C" fn(
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_best_3d_id: unsafe extern "C" fn(
        display_id: u32,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_explicit_new: unsafe extern "C" fn(
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_explicit_new_id: unsafe extern "C" fn(
        display_id: u32,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_sdtv_power_on: unsafe extern "C" fn(
        mode: SDTV_MODE_T,
        options: *mut SDTV_OPTIONS_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_sdtv_power_on_id: unsafe extern "C" fn(
        display_id: u32,
        mode: SDTV_MODE_T,
        options: *mut SDTV_OPTIONS_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_power_off: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_power_off_id: unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_supported_modes_new: unsafe extern "C" fn(
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_NEW_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_supported_modes_new_id: unsafe extern "C" fn(
        display_id: u32,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_NEW_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_mode_supported:
        unsafe extern "C" fn(group: HDMI_RES_GROUP_T, mode: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_mode_supported_id: unsafe extern "C" fn(
        display_d: u32,
        group: HDMI_RES_GROUP_T,
        mode: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_audio_supported: unsafe extern "C" fn(
        audio_format: u32,
        num_channels: u32,
        fs: EDID_AudioSampleRate,
        bitrate: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_audio_supported_id: unsafe extern "C" fn(
        display_id: u32,
        audio_format: u32,
        num_channels: u32,
        fs: EDID_AudioSampleRate,
        bitrate: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_enable_copyprotect:
        unsafe extern "C" fn(cp_mode: u32, timeout: u32) -> ::std::os::raw::c_int,
    pub vc_tv_enable_copyprotect_id:
        unsafe extern "C" fn(display_id: u32, cp_mode: u32, timeout: u32) -> ::std::os::raw::c_int,
    pub vc_tv_disable_copyprotect: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_disable_copyprotect_id:
        unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_show_info: unsafe extern "C" fn(show: u32) -> ::std::os::raw::c_int,
    pub vc_tv_show_info_id:
        unsafe extern "C" fn(display_id: u32, show: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_av_latency: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_av_latency_id:
        unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_hdcp_key: unsafe extern "C" fn(key: *const u8) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_hdcp_key_id:
        unsafe extern "C" fn(display_id: u32, key: *const u8) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_hdcp_revoked_list:
        unsafe extern "C" fn(list: *const u8, num_keys: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_hdcp_revoked_list_id: unsafe extern "C" fn(
        display_id: u32,
        list: *const u8,
        num_keys: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_spd: unsafe extern "C" fn(
        manufacturer: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: HDMI_SPD_TYPE_CODE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_spd_id: unsafe extern "C" fn(
        display_id: u32,
        manufacturer: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: HDMI_SPD_TYPE_CODE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_display_options: unsafe extern "C" fn(
        aspect: HDMI_ASPECT_T,
        left_bar_width: u32,
        right_bar_width: u32,
        top_bar_height: u32,
        bottom_bar_height: u32,
        overscan_flags: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_display_options_id: unsafe extern "C" fn(
        display_id: u32,
        aspect: HDMI_ASPECT_T,
        left_bar_width: u32,
        right_bar_width: u32,
        top_bar_height: u32,
        bottom_bar_height: u32,
        overscan_flags: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_test_mode_start:
        unsafe extern "C" fn(colour: u32, test_mode: TV_TEST_MODE_T) -> ::std::os::raw::c_int,
    pub vc_tv_test_mode_start_id: unsafe extern "C" fn(
        display_id: u32,
        colour: u32,
        test_mode: TV_TEST_MODE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_test_mode_stop: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_tv_test_mode_stop_id: unsafe extern "C" fn(display_id: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_ddc_read:
        unsafe extern "C" fn(offset: u32, length: u32, buffer: *mut u8) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_ddc_read_id: unsafe extern "C" fn(
        display_id: u32,
        offset: u32,
        length: u32,
        buffer: *mut u8,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_attached: unsafe extern "C" fn(attached: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_attached_id:
        unsafe extern "C" fn(display_id: u32, attached: u32) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_property:
        unsafe extern "C" fn(property: *const HDMI_PROPERTY_PARAM_T) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_set_property_id: unsafe extern "C" fn(
        display_id: u32,
        property: *const HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_property:
        unsafe extern "C" fn(property: *mut HDMI_PROPERTY_PARAM_T) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_property_id: unsafe extern "C" fn(
        display_id: u32,
        property: *mut HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_notification_name:
        unsafe extern "C" fn(reason: VC_HDMI_NOTIFY_T) -> *const ::std::os::raw::c_char,
    pub vc_tv_notification_name_id: unsafe extern "C" fn(
        display_id: u32,
        reason: VC_HDMI_NOTIFY_T,
    ) -> *const ::std::os::raw::c_char,
    pub vc_tv_get_device_id: unsafe extern "C" fn(id: *mut TV_DEVICE_ID_T) -> ::std::os::raw::c_int,
    pub vc_tv_get_device_id_id:
        unsafe extern "C" fn(display_id: u32, id: *mut TV_DEVICE_ID_T) -> ::std::os::raw::c_int,
    pub vc_tv_get_attached_devices:
        unsafe extern "C" fn(devices: *mut TV_ATTACHED_DEVICES_T) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_supported_modes: unsafe extern "C" fn(
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_get_supported_modes_id: unsafe extern "C" fn(
        display_id: u32,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_explicit: unsafe extern "C" fn(
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_tv_hdmi_power_on_explicit_id: unsafe extern "C" fn(
        display_id: u32,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_vchi_cec_init: unsafe extern "C" fn(
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ),
    pub vc_vchi_cec_stop: unsafe extern "C" fn(),
    pub vc_cec_register_callback: unsafe extern "C" fn(
        callback: CECSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ),
    pub vc_cec_register_command:
        unsafe extern "C" fn(opcode: CEC_OPCODE_T) -> ::std::os::raw::c_int,
    pub vc_cec_register_all: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_cec_deregister_command:
        unsafe extern "C" fn(opcode: CEC_OPCODE_T) -> ::std::os::raw::c_int,
    pub vc_cec_deregister_all: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_cec_send_message: unsafe extern "C" fn(
        follower: u32,
        payload: *const u8,
        length: u32,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_get_logical_address:
        unsafe extern "C" fn(logical_address: *mut CEC_AllDevices_T) -> ::std::os::raw::c_int,
    pub vc_cec_alloc_logical_address: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_cec_release_logical_address: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_cec_get_topology:
        unsafe extern "C" fn(topology: *mut VC_CEC_TOPOLOGY_T) -> ::std::os::raw::c_int,
    pub vc_cec_set_vendor_id: unsafe extern "C" fn(id: u32) -> ::std::os::raw::c_int,
    pub vc_cec_set_osd_name:
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int,
    pub vc_cec_get_physical_address:
        unsafe extern "C" fn(physical_address: *mut u16) -> ::std::os::raw::c_int,
    pub vc_cec_get_vendor_id: unsafe extern "C" fn(
        logical_address: CEC_AllDevices_T,
        vendor_id: *mut u32,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_device_type:
        unsafe extern "C" fn(logical_address: CEC_AllDevices_T) -> CEC_DEVICE_TYPE_T,
    pub vc_cec_send_message2:
        unsafe extern "C" fn(message: *const VC_CEC_MESSAGE_T) -> ::std::os::raw::c_int,
    pub vc_cec_param2message: unsafe extern "C" fn(
        reason: u32,
        param1: u32,
        param2: u32,
        param3: u32,
        param4: u32,
        message: *mut VC_CEC_MESSAGE_T,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_poll_address:
        unsafe extern "C" fn(logical_address: CEC_AllDevices_T) -> ::std::os::raw::c_int,
    pub vc_cec_set_logical_address: unsafe extern "C" fn(
        logical_address: CEC_AllDevices_T,
        device_type: CEC_DEVICE_TYPE_T,
        vendor_id: u32,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_add_device: unsafe extern "C" fn(
        logical_address: CEC_AllDevices_T,
        physical_address: u16,
        device_type: CEC_DEVICE_TYPE_T,
        last_device: vcos_bool_t,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_set_passive: unsafe extern "C" fn(enabled: vcos_bool_t) -> ::std::os::raw::c_int,
    pub vc_cec_send_FeatureAbort: unsafe extern "C" fn(
        follower: u32,
        opcode: CEC_OPCODE_T,
        reason: CEC_ABORT_REASON_T,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_send_ActiveSource:
        unsafe extern "C" fn(physical_address: u16, is_reply: vcos_bool_t) -> ::std::os::raw::c_int,
    pub vc_cec_send_ImageViewOn:
        unsafe extern "C" fn(follower: u32, is_reply: vcos_bool_t) -> ::std::os::raw::c_int,
    pub vc_cec_send_SetOSDString: unsafe extern "C" fn(
        follower: u32,
        disp_ctrl: CEC_DISPLAY_CONTROL_T,
        string: *const ::std::os::raw::c_char,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_send_Standby:
        unsafe extern "C" fn(follower: u32, is_reply: vcos_bool_t) -> ::std::os::raw::c_int,
    pub vc_cec_send_MenuStatus: unsafe extern "C" fn(
        follower: u32,
        menu_state: CEC_MENU_STATE_T,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int,
    pub vc_cec_send_ReportPhysicalAddress: unsafe extern "C" fn(
        physical_address: u16,
        device_type: CEC_DEVICE_TYPE_T,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int,
    pub vc_os_close: unsafe extern "C" fn(),
    pub vc_vchi_gencmd_init: unsafe extern "C" fn(
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ),
    pub vc_gencmd_init: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vc_gencmd_stop: unsafe extern "C" fn(),
    pub vc_gencmd_send:
        unsafe extern "C" fn(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int,
    pub vc_gencmd_read_response: unsafe extern "C" fn(
        response: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd: unsafe extern "C" fn(
        response: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_string_property: unsafe extern "C" fn(
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_number_property: unsafe extern "C" fn(
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        number: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub vc_gencmd_until: unsafe extern "C" fn(
        cmd: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        error_string: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
    pub bcm_host_get_model_type: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_model_pi4: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_fkms_active: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_is_kms_active: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub bcm_host_get_processor_id: unsafe extern "C" fn() -> ::std::os::raw::c_int,
}
impl libbcm_host {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let bcm_host_init = __library.get(b"bcm_host_init\0").map(|sym| *sym)?;
        let bcm_host_deinit = __library.get(b"bcm_host_deinit\0").map(|sym| *sym)?;
        let graphics_get_display_size = __library
            .get(b"graphics_get_display_size\0")
            .map(|sym| *sym)?;
        let bcm_host_get_peripheral_address = __library
            .get(b"bcm_host_get_peripheral_address\0")
            .map(|sym| *sym)?;
        let bcm_host_get_peripheral_size = __library
            .get(b"bcm_host_get_peripheral_size\0")
            .map(|sym| *sym)?;
        let bcm_host_get_sdram_address = __library
            .get(b"bcm_host_get_sdram_address\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_logging_assert = __library
            .get(b"vcos_pthreads_logging_assert\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enabled = __library
            .get(b"vcos_verify_bkpts_enabled\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enable = __library
            .get(b"vcos_verify_bkpts_enable\0")
            .map(|sym| *sym)?;
        let vcos_abort = __library.get(b"vcos_abort\0").map(|sym| *sym)?;
        let vcos_backtrace_self = __library.get(b"vcos_backtrace_self\0").map(|sym| *sym)?;
        let vcos_generic_event_flags_create = __library
            .get(b"vcos_generic_event_flags_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_set = __library
            .get(b"vcos_generic_event_flags_set\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_delete = __library
            .get(b"vcos_generic_event_flags_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_get = __library
            .get(b"vcos_generic_event_flags_get\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_init = __library
            .get(b"vcos_generic_blockpool_init\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_create_on_heap = __library
            .get(b"vcos_generic_blockpool_create_on_heap\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_extend = __library
            .get(b"vcos_generic_blockpool_extend\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_alloc = __library
            .get(b"vcos_generic_blockpool_alloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_calloc = __library
            .get(b"vcos_generic_blockpool_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_free = __library
            .get(b"vcos_generic_blockpool_free\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_available_count = __library
            .get(b"vcos_generic_blockpool_available_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_used_count = __library
            .get(b"vcos_generic_blockpool_used_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_delete = __library
            .get(b"vcos_generic_blockpool_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_to_handle = __library
            .get(b"vcos_generic_blockpool_elem_to_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_from_handle = __library
            .get(b"vcos_generic_blockpool_elem_from_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_is_valid_elem = __library
            .get(b"vcos_generic_blockpool_is_valid_elem\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_alloc = __library.get(b"vcos_generic_mem_alloc\0").map(|sym| *sym)?;
        let vcos_generic_mem_calloc = __library
            .get(b"vcos_generic_mem_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_free = __library.get(b"vcos_generic_mem_free\0").map(|sym| *sym)?;
        let vcos_generic_mem_alloc_aligned = __library
            .get(b"vcos_generic_mem_alloc_aligned\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_error = __library
            .get(b"vcos_pthreads_map_error\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_errno = __library
            .get(b"vcos_pthreads_map_errno\0")
            .map(|sym| *sym)?;
        let vcos_thread_at_exit = __library.get(b"vcos_thread_at_exit\0").map(|sym| *sym)?;
        let vcos_dummy_thread_create = __library
            .get(b"vcos_dummy_thread_create\0")
            .map(|sym| *sym)?;
        let vcos_getmicrosecs64_internal = __library
            .get(b"vcos_getmicrosecs64_internal\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_create = __library
            .get(b"vcos_pthreads_timer_create\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_set = __library
            .get(b"vcos_pthreads_timer_set\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_cancel = __library
            .get(b"vcos_pthreads_timer_cancel\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_delete = __library
            .get(b"vcos_pthreads_timer_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_create = __library
            .get(b"vcos_generic_reentrant_mutex_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_delete = __library
            .get(b"vcos_generic_reentrant_mutex_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_lock = __library
            .get(b"vcos_generic_reentrant_mutex_lock\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_unlock = __library
            .get(b"vcos_generic_reentrant_mutex_unlock\0")
            .map(|sym| *sym)?;
        let vcos_generic_named_semaphore_create = __library
            .get(b"vcos_generic_named_semaphore_create\0")
            .map(|sym| *sym)?;
        let vcos_named_semaphore_delete = __library
            .get(b"vcos_named_semaphore_delete\0")
            .map(|sym| *sym)?;
        let vcos_init = __library.get(b"vcos_init\0").map(|sym| *sym)?;
        let vcos_deinit = __library.get(b"vcos_deinit\0").map(|sym| *sym)?;
        let vcos_global_lock = __library.get(b"vcos_global_lock\0").map(|sym| *sym)?;
        let vcos_global_unlock = __library.get(b"vcos_global_unlock\0").map(|sym| *sym)?;
        let vcos_set_args = __library.get(b"vcos_set_args\0").map(|sym| *sym)?;
        let vcos_get_argc = __library.get(b"vcos_get_argc\0").map(|sym| *sym)?;
        let vcos_get_argv = __library.get(b"vcos_get_argv\0").map(|sym| *sym)?;
        let vcos_platform_init = __library.get(b"vcos_platform_init\0").map(|sym| *sym)?;
        let vcos_platform_deinit = __library.get(b"vcos_platform_deinit\0").map(|sym| *sym)?;
        let vcos_have_rtos = __library.get(b"vcos_have_rtos\0").map(|sym| *sym)?;
        let vcos_thread_create = __library.get(b"vcos_thread_create\0").map(|sym| *sym)?;
        let vcos_thread_exit = __library.get(b"vcos_thread_exit\0").map(|sym| *sym)?;
        let vcos_thread_join = __library.get(b"vcos_thread_join\0").map(|sym| *sym)?;
        let vcos_thread_create_classic = __library
            .get(b"vcos_thread_create_classic\0")
            .map(|sym| *sym)?;
        let vcos_thread_get_name = __library.get(b"vcos_thread_get_name\0").map(|sym| *sym)?;
        let vcos_kcalloc = __library.get(b"vcos_kcalloc\0").map(|sym| *sym)?;
        let vcos_kfree = __library.get(b"vcos_kfree\0").map(|sym| *sym)?;
        let vcos_log_level_to_string = __library
            .get(b"vcos_log_level_to_string\0")
            .map(|sym| *sym)?;
        let vcos_string_to_log_level = __library
            .get(b"vcos_string_to_log_level\0")
            .map(|sym| *sym)?;
        let vcos_log_impl = __library.get(b"vcos_log_impl\0").map(|sym| *sym)?;
        let vcos_vlog_impl = __library.get(b"vcos_vlog_impl\0").map(|sym| *sym)?;
        let vcos_set_vlog_impl = __library.get(b"vcos_set_vlog_impl\0").map(|sym| *sym)?;
        let vcos_vlog_default_impl = __library.get(b"vcos_vlog_default_impl\0").map(|sym| *sym)?;
        let vcos_logging_init = __library.get(b"vcos_logging_init\0").map(|sym| *sym)?;
        let vcos_log_register = __library.get(b"vcos_log_register\0").map(|sym| *sym)?;
        let vcos_log_unregister = __library.get(b"vcos_log_unregister\0").map(|sym| *sym)?;
        let vcos_log_get_default_category = __library
            .get(b"vcos_log_get_default_category\0")
            .map(|sym| *sym)?;
        let vcos_set_log_options = __library.get(b"vcos_set_log_options\0").map(|sym| *sym)?;
        let vcos_log_set_level_all = __library.get(b"vcos_log_set_level_all\0").map(|sym| *sym)?;
        let vcos_log_dump_mem_impl = __library.get(b"vcos_log_dump_mem_impl\0").map(|sym| *sym)?;
        let vcos_cmd_error = __library.get(b"vcos_cmd_error\0").map(|sym| *sym)?;
        let vcos_cmd_printf = __library.get(b"vcos_cmd_printf\0").map(|sym| *sym)?;
        let vcos_cmd_vprintf = __library.get(b"vcos_cmd_vprintf\0").map(|sym| *sym)?;
        let vcos_cmd_always_log_output = __library
            .get(b"vcos_cmd_always_log_output\0")
            .map(|sym| *sym)?;
        let vcos_cmd_usage = __library.get(b"vcos_cmd_usage\0").map(|sym| *sym)?;
        let vcos_cmd_register = __library.get(b"vcos_cmd_register\0").map(|sym| *sym)?;
        let vcos_cmd_register_multiple = __library
            .get(b"vcos_cmd_register_multiple\0")
            .map(|sym| *sym)?;
        let vcos_cmd_execute = __library.get(b"vcos_cmd_execute\0").map(|sym| *sym)?;
        let vcos_cmd_shutdown = __library.get(b"vcos_cmd_shutdown\0").map(|sym| *sym)?;
        let vcos_log_assert_cmd = __library.get(b"vcos_log_assert_cmd\0").map(|sym| *sym)?;
        let vcos_log_set_cmd = __library.get(b"vcos_log_set_cmd\0").map(|sym| *sym)?;
        let vcos_log_status_cmd = __library.get(b"vcos_log_status_cmd\0").map(|sym| *sym)?;
        let vcos_log_test_cmd = __library.get(b"vcos_log_test_cmd\0").map(|sym| *sym)?;
        let vcos_vsnprintf = __library.get(b"vcos_vsnprintf\0").map(|sym| *sym)?;
        let vcos_snprintf = __library.get(b"vcos_snprintf\0").map(|sym| *sym)?;
        let vcos_safe_vsprintf = __library.get(b"vcos_safe_vsprintf\0").map(|sym| *sym)?;
        let vcos_safe_sprintf = __library.get(b"vcos_safe_sprintf\0").map(|sym| *sym)?;
        let vcos_safe_strcpy = __library.get(b"vcos_safe_strcpy\0").map(|sym| *sym)?;
        let vcos_safe_strncpy = __library.get(b"vcos_safe_strncpy\0").map(|sym| *sym)?;
        let vcos_thread_attr_init = __library.get(b"vcos_thread_attr_init\0").map(|sym| *sym)?;
        let vcos_timer_init = __library.get(b"vcos_timer_init\0").map(|sym| *sym)?;
        let vcos_once = __library.get(b"vcos_once\0").map(|sym| *sym)?;
        let vc_dispman_init = __library.get(b"vc_dispman_init\0").map(|sym| *sym)?;
        let vc_dispmanx_stop = __library.get(b"vc_dispmanx_stop\0").map(|sym| *sym)?;
        let vc_dispmanx_rect_set = __library.get(b"vc_dispmanx_rect_set\0").map(|sym| *sym)?;
        let vc_dispmanx_resource_create = __library
            .get(b"vc_dispmanx_resource_create\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_resource_write_data = __library
            .get(b"vc_dispmanx_resource_write_data\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_resource_write_data_handle = __library
            .get(b"vc_dispmanx_resource_write_data_handle\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_resource_read_data = __library
            .get(b"vc_dispmanx_resource_read_data\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_resource_delete = __library
            .get(b"vc_dispmanx_resource_delete\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_open = __library
            .get(b"vc_dispmanx_display_open\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_open_mode = __library
            .get(b"vc_dispmanx_display_open_mode\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_open_offscreen = __library
            .get(b"vc_dispmanx_display_open_offscreen\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_reconfigure = __library
            .get(b"vc_dispmanx_display_reconfigure\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_set_destination = __library
            .get(b"vc_dispmanx_display_set_destination\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_set_background = __library
            .get(b"vc_dispmanx_display_set_background\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_get_info = __library
            .get(b"vc_dispmanx_display_get_info\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_display_close = __library
            .get(b"vc_dispmanx_display_close\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_update_start = __library
            .get(b"vc_dispmanx_update_start\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_add = __library
            .get(b"vc_dispmanx_element_add\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_change_source = __library
            .get(b"vc_dispmanx_element_change_source\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_change_layer = __library
            .get(b"vc_dispmanx_element_change_layer\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_modified = __library
            .get(b"vc_dispmanx_element_modified\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_remove = __library
            .get(b"vc_dispmanx_element_remove\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_update_submit = __library
            .get(b"vc_dispmanx_update_submit\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_update_submit_sync = __library
            .get(b"vc_dispmanx_update_submit_sync\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_query_image_formats = __library
            .get(b"vc_dispmanx_query_image_formats\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_element_change_attributes = __library
            .get(b"vc_dispmanx_element_change_attributes\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_resource_get_image_handle = __library
            .get(b"vc_dispmanx_resource_get_image_handle\0")
            .map(|sym| *sym)?;
        let vc_vchi_dispmanx_init = __library.get(b"vc_vchi_dispmanx_init\0").map(|sym| *sym)?;
        let vc_dispmanx_snapshot = __library.get(b"vc_dispmanx_snapshot\0").map(|sym| *sym)?;
        let vc_dispmanx_resource_set_palette = __library
            .get(b"vc_dispmanx_resource_set_palette\0")
            .map(|sym| *sym)?;
        let vc_dispmanx_vsync_callback = __library
            .get(b"vc_dispmanx_vsync_callback\0")
            .map(|sym| *sym)?;
        let vc_vchi_tv_init = __library.get(b"vc_vchi_tv_init\0").map(|sym| *sym)?;
        let vc_vchi_tv_stop = __library.get(b"vc_vchi_tv_stop\0").map(|sym| *sym)?;
        let vc_tv_register_callback = __library
            .get(b"vc_tv_register_callback\0")
            .map(|sym| *sym)?;
        let vc_tv_unregister_callback = __library
            .get(b"vc_tv_unregister_callback\0")
            .map(|sym| *sym)?;
        let vc_tv_unregister_callback_full = __library
            .get(b"vc_tv_unregister_callback_full\0")
            .map(|sym| *sym)?;
        let vc_tv_get_state = __library.get(b"vc_tv_get_state\0").map(|sym| *sym)?;
        let vc_tv_get_state_id = __library.get(b"vc_tv_get_state_id\0").map(|sym| *sym)?;
        let vc_tv_get_display_state = __library
            .get(b"vc_tv_get_display_state\0")
            .map(|sym| *sym)?;
        let vc_tv_get_display_state_id = __library
            .get(b"vc_tv_get_display_state_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_preferred = __library
            .get(b"vc_tv_hdmi_power_on_preferred\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_preferred_id = __library
            .get(b"vc_tv_hdmi_power_on_preferred_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_preferred_3d = __library
            .get(b"vc_tv_hdmi_power_on_preferred_3d\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_preferred_3d_id = __library
            .get(b"vc_tv_hdmi_power_on_preferred_3d_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_best = __library
            .get(b"vc_tv_hdmi_power_on_best\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_best_id = __library
            .get(b"vc_tv_hdmi_power_on_best_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_best_3d = __library
            .get(b"vc_tv_hdmi_power_on_best_3d\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_best_3d_id = __library
            .get(b"vc_tv_hdmi_power_on_best_3d_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_explicit_new = __library
            .get(b"vc_tv_hdmi_power_on_explicit_new\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_explicit_new_id = __library
            .get(b"vc_tv_hdmi_power_on_explicit_new_id\0")
            .map(|sym| *sym)?;
        let vc_tv_sdtv_power_on = __library.get(b"vc_tv_sdtv_power_on\0").map(|sym| *sym)?;
        let vc_tv_sdtv_power_on_id = __library.get(b"vc_tv_sdtv_power_on_id\0").map(|sym| *sym)?;
        let vc_tv_power_off = __library.get(b"vc_tv_power_off\0").map(|sym| *sym)?;
        let vc_tv_power_off_id = __library.get(b"vc_tv_power_off_id\0").map(|sym| *sym)?;
        let vc_tv_hdmi_get_supported_modes_new = __library
            .get(b"vc_tv_hdmi_get_supported_modes_new\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_supported_modes_new_id = __library
            .get(b"vc_tv_hdmi_get_supported_modes_new_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_mode_supported = __library
            .get(b"vc_tv_hdmi_mode_supported\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_mode_supported_id = __library
            .get(b"vc_tv_hdmi_mode_supported_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_audio_supported = __library
            .get(b"vc_tv_hdmi_audio_supported\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_audio_supported_id = __library
            .get(b"vc_tv_hdmi_audio_supported_id\0")
            .map(|sym| *sym)?;
        let vc_tv_enable_copyprotect = __library
            .get(b"vc_tv_enable_copyprotect\0")
            .map(|sym| *sym)?;
        let vc_tv_enable_copyprotect_id = __library
            .get(b"vc_tv_enable_copyprotect_id\0")
            .map(|sym| *sym)?;
        let vc_tv_disable_copyprotect = __library
            .get(b"vc_tv_disable_copyprotect\0")
            .map(|sym| *sym)?;
        let vc_tv_disable_copyprotect_id = __library
            .get(b"vc_tv_disable_copyprotect_id\0")
            .map(|sym| *sym)?;
        let vc_tv_show_info = __library.get(b"vc_tv_show_info\0").map(|sym| *sym)?;
        let vc_tv_show_info_id = __library.get(b"vc_tv_show_info_id\0").map(|sym| *sym)?;
        let vc_tv_hdmi_get_av_latency = __library
            .get(b"vc_tv_hdmi_get_av_latency\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_av_latency_id = __library
            .get(b"vc_tv_hdmi_get_av_latency_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_hdcp_key = __library
            .get(b"vc_tv_hdmi_set_hdcp_key\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_hdcp_key_id = __library
            .get(b"vc_tv_hdmi_set_hdcp_key_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_hdcp_revoked_list = __library
            .get(b"vc_tv_hdmi_set_hdcp_revoked_list\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_hdcp_revoked_list_id = __library
            .get(b"vc_tv_hdmi_set_hdcp_revoked_list_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_spd = __library.get(b"vc_tv_hdmi_set_spd\0").map(|sym| *sym)?;
        let vc_tv_hdmi_set_spd_id = __library.get(b"vc_tv_hdmi_set_spd_id\0").map(|sym| *sym)?;
        let vc_tv_hdmi_set_display_options = __library
            .get(b"vc_tv_hdmi_set_display_options\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_display_options_id = __library
            .get(b"vc_tv_hdmi_set_display_options_id\0")
            .map(|sym| *sym)?;
        let vc_tv_test_mode_start = __library.get(b"vc_tv_test_mode_start\0").map(|sym| *sym)?;
        let vc_tv_test_mode_start_id = __library
            .get(b"vc_tv_test_mode_start_id\0")
            .map(|sym| *sym)?;
        let vc_tv_test_mode_stop = __library.get(b"vc_tv_test_mode_stop\0").map(|sym| *sym)?;
        let vc_tv_test_mode_stop_id = __library
            .get(b"vc_tv_test_mode_stop_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_ddc_read = __library.get(b"vc_tv_hdmi_ddc_read\0").map(|sym| *sym)?;
        let vc_tv_hdmi_ddc_read_id = __library.get(b"vc_tv_hdmi_ddc_read_id\0").map(|sym| *sym)?;
        let vc_tv_hdmi_set_attached = __library
            .get(b"vc_tv_hdmi_set_attached\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_attached_id = __library
            .get(b"vc_tv_hdmi_set_attached_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_property = __library
            .get(b"vc_tv_hdmi_set_property\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_set_property_id = __library
            .get(b"vc_tv_hdmi_set_property_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_property = __library
            .get(b"vc_tv_hdmi_get_property\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_property_id = __library
            .get(b"vc_tv_hdmi_get_property_id\0")
            .map(|sym| *sym)?;
        let vc_tv_notification_name = __library
            .get(b"vc_tv_notification_name\0")
            .map(|sym| *sym)?;
        let vc_tv_notification_name_id = __library
            .get(b"vc_tv_notification_name_id\0")
            .map(|sym| *sym)?;
        let vc_tv_get_device_id = __library.get(b"vc_tv_get_device_id\0").map(|sym| *sym)?;
        let vc_tv_get_device_id_id = __library.get(b"vc_tv_get_device_id_id\0").map(|sym| *sym)?;
        let vc_tv_get_attached_devices = __library
            .get(b"vc_tv_get_attached_devices\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_supported_modes = __library
            .get(b"vc_tv_hdmi_get_supported_modes\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_get_supported_modes_id = __library
            .get(b"vc_tv_hdmi_get_supported_modes_id\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_explicit = __library
            .get(b"vc_tv_hdmi_power_on_explicit\0")
            .map(|sym| *sym)?;
        let vc_tv_hdmi_power_on_explicit_id = __library
            .get(b"vc_tv_hdmi_power_on_explicit_id\0")
            .map(|sym| *sym)?;
        let vc_vchi_cec_init = __library.get(b"vc_vchi_cec_init\0").map(|sym| *sym)?;
        let vc_vchi_cec_stop = __library.get(b"vc_vchi_cec_stop\0").map(|sym| *sym)?;
        let vc_cec_register_callback = __library
            .get(b"vc_cec_register_callback\0")
            .map(|sym| *sym)?;
        let vc_cec_register_command = __library
            .get(b"vc_cec_register_command\0")
            .map(|sym| *sym)?;
        let vc_cec_register_all = __library.get(b"vc_cec_register_all\0").map(|sym| *sym)?;
        let vc_cec_deregister_command = __library
            .get(b"vc_cec_deregister_command\0")
            .map(|sym| *sym)?;
        let vc_cec_deregister_all = __library.get(b"vc_cec_deregister_all\0").map(|sym| *sym)?;
        let vc_cec_send_message = __library.get(b"vc_cec_send_message\0").map(|sym| *sym)?;
        let vc_cec_get_logical_address = __library
            .get(b"vc_cec_get_logical_address\0")
            .map(|sym| *sym)?;
        let vc_cec_alloc_logical_address = __library
            .get(b"vc_cec_alloc_logical_address\0")
            .map(|sym| *sym)?;
        let vc_cec_release_logical_address = __library
            .get(b"vc_cec_release_logical_address\0")
            .map(|sym| *sym)?;
        let vc_cec_get_topology = __library.get(b"vc_cec_get_topology\0").map(|sym| *sym)?;
        let vc_cec_set_vendor_id = __library.get(b"vc_cec_set_vendor_id\0").map(|sym| *sym)?;
        let vc_cec_set_osd_name = __library.get(b"vc_cec_set_osd_name\0").map(|sym| *sym)?;
        let vc_cec_get_physical_address = __library
            .get(b"vc_cec_get_physical_address\0")
            .map(|sym| *sym)?;
        let vc_cec_get_vendor_id = __library.get(b"vc_cec_get_vendor_id\0").map(|sym| *sym)?;
        let vc_cec_device_type = __library.get(b"vc_cec_device_type\0").map(|sym| *sym)?;
        let vc_cec_send_message2 = __library.get(b"vc_cec_send_message2\0").map(|sym| *sym)?;
        let vc_cec_param2message = __library.get(b"vc_cec_param2message\0").map(|sym| *sym)?;
        let vc_cec_poll_address = __library.get(b"vc_cec_poll_address\0").map(|sym| *sym)?;
        let vc_cec_set_logical_address = __library
            .get(b"vc_cec_set_logical_address\0")
            .map(|sym| *sym)?;
        let vc_cec_add_device = __library.get(b"vc_cec_add_device\0").map(|sym| *sym)?;
        let vc_cec_set_passive = __library.get(b"vc_cec_set_passive\0").map(|sym| *sym)?;
        let vc_cec_send_FeatureAbort = __library
            .get(b"vc_cec_send_FeatureAbort\0")
            .map(|sym| *sym)?;
        let vc_cec_send_ActiveSource = __library
            .get(b"vc_cec_send_ActiveSource\0")
            .map(|sym| *sym)?;
        let vc_cec_send_ImageViewOn = __library
            .get(b"vc_cec_send_ImageViewOn\0")
            .map(|sym| *sym)?;
        let vc_cec_send_SetOSDString = __library
            .get(b"vc_cec_send_SetOSDString\0")
            .map(|sym| *sym)?;
        let vc_cec_send_Standby = __library.get(b"vc_cec_send_Standby\0").map(|sym| *sym)?;
        let vc_cec_send_MenuStatus = __library.get(b"vc_cec_send_MenuStatus\0").map(|sym| *sym)?;
        let vc_cec_send_ReportPhysicalAddress = __library
            .get(b"vc_cec_send_ReportPhysicalAddress\0")
            .map(|sym| *sym)?;
        let vc_os_close = __library.get(b"vc_os_close\0").map(|sym| *sym)?;
        let vc_vchi_gencmd_init = __library.get(b"vc_vchi_gencmd_init\0").map(|sym| *sym)?;
        let vc_gencmd_init = __library.get(b"vc_gencmd_init\0").map(|sym| *sym)?;
        let vc_gencmd_stop = __library.get(b"vc_gencmd_stop\0").map(|sym| *sym)?;
        let vc_gencmd_send = __library.get(b"vc_gencmd_send\0").map(|sym| *sym)?;
        let vc_gencmd_read_response = __library
            .get(b"vc_gencmd_read_response\0")
            .map(|sym| *sym)?;
        let vc_gencmd = __library.get(b"vc_gencmd\0").map(|sym| *sym)?;
        let vc_gencmd_string_property = __library
            .get(b"vc_gencmd_string_property\0")
            .map(|sym| *sym)?;
        let vc_gencmd_number_property = __library
            .get(b"vc_gencmd_number_property\0")
            .map(|sym| *sym)?;
        let vc_gencmd_until = __library.get(b"vc_gencmd_until\0").map(|sym| *sym)?;
        let bcm_host_get_model_type = __library
            .get(b"bcm_host_get_model_type\0")
            .map(|sym| *sym)?;
        let bcm_host_is_model_pi4 = __library.get(b"bcm_host_is_model_pi4\0").map(|sym| *sym)?;
        let bcm_host_is_fkms_active = __library
            .get(b"bcm_host_is_fkms_active\0")
            .map(|sym| *sym)?;
        let bcm_host_is_kms_active = __library.get(b"bcm_host_is_kms_active\0").map(|sym| *sym)?;
        let bcm_host_get_processor_id = __library
            .get(b"bcm_host_get_processor_id\0")
            .map(|sym| *sym)?;
        Ok(libbcm_host {
            __library,
            bcm_host_init,
            bcm_host_deinit,
            graphics_get_display_size,
            bcm_host_get_peripheral_address,
            bcm_host_get_peripheral_size,
            bcm_host_get_sdram_address,
            vcos_pthreads_logging_assert,
            vcos_verify_bkpts_enabled,
            vcos_verify_bkpts_enable,
            vcos_abort,
            vcos_backtrace_self,
            vcos_generic_event_flags_create,
            vcos_generic_event_flags_set,
            vcos_generic_event_flags_delete,
            vcos_generic_event_flags_get,
            vcos_generic_blockpool_init,
            vcos_generic_blockpool_create_on_heap,
            vcos_generic_blockpool_extend,
            vcos_generic_blockpool_alloc,
            vcos_generic_blockpool_calloc,
            vcos_generic_blockpool_free,
            vcos_generic_blockpool_available_count,
            vcos_generic_blockpool_used_count,
            vcos_generic_blockpool_delete,
            vcos_generic_blockpool_elem_to_handle,
            vcos_generic_blockpool_elem_from_handle,
            vcos_generic_blockpool_is_valid_elem,
            vcos_generic_mem_alloc,
            vcos_generic_mem_calloc,
            vcos_generic_mem_free,
            vcos_generic_mem_alloc_aligned,
            vcos_pthreads_map_error,
            vcos_pthreads_map_errno,
            vcos_thread_at_exit,
            vcos_dummy_thread_create,
            vcos_getmicrosecs64_internal,
            vcos_pthreads_timer_create,
            vcos_pthreads_timer_set,
            vcos_pthreads_timer_cancel,
            vcos_pthreads_timer_delete,
            vcos_generic_reentrant_mutex_create,
            vcos_generic_reentrant_mutex_delete,
            vcos_generic_reentrant_mutex_lock,
            vcos_generic_reentrant_mutex_unlock,
            vcos_generic_named_semaphore_create,
            vcos_named_semaphore_delete,
            vcos_init,
            vcos_deinit,
            vcos_global_lock,
            vcos_global_unlock,
            vcos_set_args,
            vcos_get_argc,
            vcos_get_argv,
            vcos_platform_init,
            vcos_platform_deinit,
            vcos_have_rtos,
            vcos_thread_create,
            vcos_thread_exit,
            vcos_thread_join,
            vcos_thread_create_classic,
            vcos_thread_get_name,
            vcos_kcalloc,
            vcos_kfree,
            vcos_log_level_to_string,
            vcos_string_to_log_level,
            vcos_log_impl,
            vcos_vlog_impl,
            vcos_set_vlog_impl,
            vcos_vlog_default_impl,
            vcos_logging_init,
            vcos_log_register,
            vcos_log_unregister,
            vcos_log_get_default_category,
            vcos_set_log_options,
            vcos_log_set_level_all,
            vcos_log_dump_mem_impl,
            vcos_cmd_error,
            vcos_cmd_printf,
            vcos_cmd_vprintf,
            vcos_cmd_always_log_output,
            vcos_cmd_usage,
            vcos_cmd_register,
            vcos_cmd_register_multiple,
            vcos_cmd_execute,
            vcos_cmd_shutdown,
            vcos_log_assert_cmd,
            vcos_log_set_cmd,
            vcos_log_status_cmd,
            vcos_log_test_cmd,
            vcos_vsnprintf,
            vcos_snprintf,
            vcos_safe_vsprintf,
            vcos_safe_sprintf,
            vcos_safe_strcpy,
            vcos_safe_strncpy,
            vcos_thread_attr_init,
            vcos_timer_init,
            vcos_once,
            vc_dispman_init,
            vc_dispmanx_stop,
            vc_dispmanx_rect_set,
            vc_dispmanx_resource_create,
            vc_dispmanx_resource_write_data,
            vc_dispmanx_resource_write_data_handle,
            vc_dispmanx_resource_read_data,
            vc_dispmanx_resource_delete,
            vc_dispmanx_display_open,
            vc_dispmanx_display_open_mode,
            vc_dispmanx_display_open_offscreen,
            vc_dispmanx_display_reconfigure,
            vc_dispmanx_display_set_destination,
            vc_dispmanx_display_set_background,
            vc_dispmanx_display_get_info,
            vc_dispmanx_display_close,
            vc_dispmanx_update_start,
            vc_dispmanx_element_add,
            vc_dispmanx_element_change_source,
            vc_dispmanx_element_change_layer,
            vc_dispmanx_element_modified,
            vc_dispmanx_element_remove,
            vc_dispmanx_update_submit,
            vc_dispmanx_update_submit_sync,
            vc_dispmanx_query_image_formats,
            vc_dispmanx_element_change_attributes,
            vc_dispmanx_resource_get_image_handle,
            vc_vchi_dispmanx_init,
            vc_dispmanx_snapshot,
            vc_dispmanx_resource_set_palette,
            vc_dispmanx_vsync_callback,
            vc_vchi_tv_init,
            vc_vchi_tv_stop,
            vc_tv_register_callback,
            vc_tv_unregister_callback,
            vc_tv_unregister_callback_full,
            vc_tv_get_state,
            vc_tv_get_state_id,
            vc_tv_get_display_state,
            vc_tv_get_display_state_id,
            vc_tv_hdmi_power_on_preferred,
            vc_tv_hdmi_power_on_preferred_id,
            vc_tv_hdmi_power_on_preferred_3d,
            vc_tv_hdmi_power_on_preferred_3d_id,
            vc_tv_hdmi_power_on_best,
            vc_tv_hdmi_power_on_best_id,
            vc_tv_hdmi_power_on_best_3d,
            vc_tv_hdmi_power_on_best_3d_id,
            vc_tv_hdmi_power_on_explicit_new,
            vc_tv_hdmi_power_on_explicit_new_id,
            vc_tv_sdtv_power_on,
            vc_tv_sdtv_power_on_id,
            vc_tv_power_off,
            vc_tv_power_off_id,
            vc_tv_hdmi_get_supported_modes_new,
            vc_tv_hdmi_get_supported_modes_new_id,
            vc_tv_hdmi_mode_supported,
            vc_tv_hdmi_mode_supported_id,
            vc_tv_hdmi_audio_supported,
            vc_tv_hdmi_audio_supported_id,
            vc_tv_enable_copyprotect,
            vc_tv_enable_copyprotect_id,
            vc_tv_disable_copyprotect,
            vc_tv_disable_copyprotect_id,
            vc_tv_show_info,
            vc_tv_show_info_id,
            vc_tv_hdmi_get_av_latency,
            vc_tv_hdmi_get_av_latency_id,
            vc_tv_hdmi_set_hdcp_key,
            vc_tv_hdmi_set_hdcp_key_id,
            vc_tv_hdmi_set_hdcp_revoked_list,
            vc_tv_hdmi_set_hdcp_revoked_list_id,
            vc_tv_hdmi_set_spd,
            vc_tv_hdmi_set_spd_id,
            vc_tv_hdmi_set_display_options,
            vc_tv_hdmi_set_display_options_id,
            vc_tv_test_mode_start,
            vc_tv_test_mode_start_id,
            vc_tv_test_mode_stop,
            vc_tv_test_mode_stop_id,
            vc_tv_hdmi_ddc_read,
            vc_tv_hdmi_ddc_read_id,
            vc_tv_hdmi_set_attached,
            vc_tv_hdmi_set_attached_id,
            vc_tv_hdmi_set_property,
            vc_tv_hdmi_set_property_id,
            vc_tv_hdmi_get_property,
            vc_tv_hdmi_get_property_id,
            vc_tv_notification_name,
            vc_tv_notification_name_id,
            vc_tv_get_device_id,
            vc_tv_get_device_id_id,
            vc_tv_get_attached_devices,
            vc_tv_hdmi_get_supported_modes,
            vc_tv_hdmi_get_supported_modes_id,
            vc_tv_hdmi_power_on_explicit,
            vc_tv_hdmi_power_on_explicit_id,
            vc_vchi_cec_init,
            vc_vchi_cec_stop,
            vc_cec_register_callback,
            vc_cec_register_command,
            vc_cec_register_all,
            vc_cec_deregister_command,
            vc_cec_deregister_all,
            vc_cec_send_message,
            vc_cec_get_logical_address,
            vc_cec_alloc_logical_address,
            vc_cec_release_logical_address,
            vc_cec_get_topology,
            vc_cec_set_vendor_id,
            vc_cec_set_osd_name,
            vc_cec_get_physical_address,
            vc_cec_get_vendor_id,
            vc_cec_device_type,
            vc_cec_send_message2,
            vc_cec_param2message,
            vc_cec_poll_address,
            vc_cec_set_logical_address,
            vc_cec_add_device,
            vc_cec_set_passive,
            vc_cec_send_FeatureAbort,
            vc_cec_send_ActiveSource,
            vc_cec_send_ImageViewOn,
            vc_cec_send_SetOSDString,
            vc_cec_send_Standby,
            vc_cec_send_MenuStatus,
            vc_cec_send_ReportPhysicalAddress,
            vc_os_close,
            vc_vchi_gencmd_init,
            vc_gencmd_init,
            vc_gencmd_stop,
            vc_gencmd_send,
            vc_gencmd_read_response,
            vc_gencmd,
            vc_gencmd_string_property,
            vc_gencmd_number_property,
            vc_gencmd_until,
            bcm_host_get_model_type,
            bcm_host_is_model_pi4,
            bcm_host_is_fkms_active,
            bcm_host_is_kms_active,
            bcm_host_get_processor_id,
        })
    }
    pub unsafe fn bcm_host_init(&self) -> () {
        (self.bcm_host_init)()
    }
    pub unsafe fn bcm_host_deinit(&self) -> () {
        (self.bcm_host_deinit)()
    }
    pub unsafe fn graphics_get_display_size(
        &self,
        display_number: u16,
        width: *mut u32,
        height: *mut u32,
    ) -> i32 {
        (self.graphics_get_display_size)(display_number, width, height)
    }
    pub unsafe fn bcm_host_get_peripheral_address(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_peripheral_address)()
    }
    pub unsafe fn bcm_host_get_peripheral_size(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_peripheral_size)()
    }
    pub unsafe fn bcm_host_get_sdram_address(&self) -> ::std::os::raw::c_uint {
        (self.bcm_host_get_sdram_address)()
    }
    pub unsafe fn vcos_verify_bkpts_enabled(&self) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enabled)()
    }
    pub unsafe fn vcos_verify_bkpts_enable(
        &self,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enable)(enable)
    }
    pub unsafe fn vcos_abort(&self) -> () {
        (self.vcos_abort)()
    }
    pub unsafe fn vcos_backtrace_self(&self) -> () {
        (self.vcos_backtrace_self)()
    }
    pub unsafe fn vcos_generic_event_flags_create(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_create)(flags, name)
    }
    pub unsafe fn vcos_generic_event_flags_set(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ) -> () {
        (self.vcos_generic_event_flags_set)(flags, events, op)
    }
    pub unsafe fn vcos_generic_event_flags_delete(&self, arg1: *mut VCOS_EVENT_FLAGS_T) -> () {
        (self.vcos_generic_event_flags_delete)(arg1)
    }
    pub unsafe fn vcos_generic_event_flags_get(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_get)(flags, requested_events, op, suspend, retrieved_events)
    }
    pub unsafe fn vcos_generic_blockpool_init(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_init)(
            pool, num_blocks, block_size, start, pool_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_create_on_heap(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_create_on_heap)(
            pool, num_blocks, block_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_extend(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_extend)(pool, num_extensions, num_blocks)
    }
    pub unsafe fn vcos_generic_blockpool_alloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_alloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_calloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_calloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_free(&self, block: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_blockpool_free)(block)
    }
    pub unsafe fn vcos_generic_blockpool_available_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_available_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_used_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_used_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_delete(&self, pool: *mut VCOS_BLOCKPOOL_T) -> () {
        (self.vcos_generic_blockpool_delete)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_elem_to_handle(
        &self,
        block: *mut ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_elem_to_handle)(block)
    }
    pub unsafe fn vcos_generic_blockpool_elem_from_handle(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        handle: u32,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_elem_from_handle)(pool, handle)
    }
    pub unsafe fn vcos_generic_blockpool_is_valid_elem(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_is_valid_elem)(pool, block)
    }
    pub unsafe fn vcos_generic_mem_alloc(
        &self,
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc)(sz, desc)
    }
    pub unsafe fn vcos_generic_mem_calloc(
        &self,
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_calloc)(count, sz, descr)
    }
    pub unsafe fn vcos_generic_mem_free(&self, ptr: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_mem_free)(ptr)
    }
    pub unsafe fn vcos_generic_mem_alloc_aligned(
        &self,
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc_aligned)(sz, align, desc)
    }
    pub unsafe fn vcos_pthreads_map_error(&self, error: ::std::os::raw::c_int) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_error)(error)
    }
    pub unsafe fn vcos_pthreads_map_errno(&self) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_errno)()
    }
    pub unsafe fn vcos_thread_at_exit(
        &self,
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_at_exit)(pfn, cxt)
    }
    pub unsafe fn vcos_dummy_thread_create(&self) -> *mut VCOS_THREAD_T {
        (self.vcos_dummy_thread_create)()
    }
    pub unsafe fn vcos_getmicrosecs64_internal(&self) -> u64 {
        (self.vcos_getmicrosecs64_internal)()
    }
    pub unsafe fn vcos_pthreads_timer_create(
        &self,
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_pthreads_timer_create)(timer, name, expiration_routine, context)
    }
    pub unsafe fn vcos_pthreads_timer_set(
        &self,
        timer: *mut VCOS_TIMER_T,
        delay_ms: VCOS_UNSIGNED,
    ) -> () {
        (self.vcos_pthreads_timer_set)(timer, delay_ms)
    }
    pub unsafe fn vcos_pthreads_timer_cancel(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_cancel)(timer)
    }
    pub unsafe fn vcos_pthreads_timer_delete(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_delete)(timer)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_create(
        &self,
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_reentrant_mutex_create)(m, name)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_delete(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_delete)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_lock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_lock)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_unlock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_unlock)(m)
    }
    pub unsafe fn vcos_generic_named_semaphore_create(
        &self,
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_named_semaphore_create)(sem, name, count)
    }
    pub unsafe fn vcos_named_semaphore_delete(&self, sem: *mut VCOS_NAMED_SEMAPHORE_T) -> () {
        (self.vcos_named_semaphore_delete)(sem)
    }
    pub unsafe fn vcos_init(&self) -> VCOS_STATUS_T {
        (self.vcos_init)()
    }
    pub unsafe fn vcos_deinit(&self) -> () {
        (self.vcos_deinit)()
    }
    pub unsafe fn vcos_global_lock(&self) -> () {
        (self.vcos_global_lock)()
    }
    pub unsafe fn vcos_global_unlock(&self) -> () {
        (self.vcos_global_unlock)()
    }
    pub unsafe fn vcos_set_args(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> () {
        (self.vcos_set_args)(argc, argv)
    }
    pub unsafe fn vcos_get_argc(&self) -> ::std::os::raw::c_int {
        (self.vcos_get_argc)()
    }
    pub unsafe fn vcos_get_argv(&self) -> *mut *const ::std::os::raw::c_char {
        (self.vcos_get_argv)()
    }
    pub unsafe fn vcos_platform_init(&self) -> VCOS_STATUS_T {
        (self.vcos_platform_init)()
    }
    pub unsafe fn vcos_platform_deinit(&self) -> () {
        (self.vcos_platform_deinit)()
    }
    pub unsafe fn vcos_have_rtos(&self) -> ::std::os::raw::c_int {
        (self.vcos_have_rtos)()
    }
    pub unsafe fn vcos_thread_create(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create)(thread, name, attrs, entry, arg)
    }
    pub unsafe fn vcos_thread_exit(&self, data: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_thread_exit)(data)
    }
    pub unsafe fn vcos_thread_join(
        &self,
        thread: *mut VCOS_THREAD_T,
        pData: *mut *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vcos_thread_join)(thread, pData)
    }
    pub unsafe fn vcos_thread_create_classic(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create_classic)(
            thread, name, entry, arg, stack, stacksz, priaff, timeslice, autostart,
        )
    }
    pub unsafe fn vcos_thread_get_name(
        &self,
        thread: *const VCOS_THREAD_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_thread_get_name)(thread)
    }
    pub unsafe fn vcos_kcalloc(
        &self,
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_kcalloc)(num, size, description)
    }
    pub unsafe fn vcos_kfree(&self, ptr: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_kfree)(ptr)
    }
    pub unsafe fn vcos_log_level_to_string(
        &self,
        level: VCOS_LOG_LEVEL_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_log_level_to_string)(level)
    }
    pub unsafe fn vcos_string_to_log_level(
        &self,
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T {
        (self.vcos_string_to_log_level)(str_, level)
    }
    pub unsafe fn vcos_vlog_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_set_vlog_impl(&self, vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T) -> () {
        (self.vcos_set_vlog_impl)(vlog_impl_func)
    }
    pub unsafe fn vcos_vlog_default_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_default_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_logging_init(&self) -> () {
        (self.vcos_logging_init)()
    }
    pub unsafe fn vcos_log_register(
        &self,
        name: *const ::std::os::raw::c_char,
        category: *mut VCOS_LOG_CAT_T,
    ) -> () {
        (self.vcos_log_register)(name, category)
    }
    pub unsafe fn vcos_log_unregister(&self, category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_log_unregister)(category)
    }
    pub unsafe fn vcos_log_get_default_category(&self) -> *const VCOS_LOG_CAT_T {
        (self.vcos_log_get_default_category)()
    }
    pub unsafe fn vcos_set_log_options(&self, opt: *const ::std::os::raw::c_char) -> () {
        (self.vcos_set_log_options)(opt)
    }
    pub unsafe fn vcos_log_set_level_all(&self, levels: *mut ::std::os::raw::c_char) -> () {
        (self.vcos_log_set_level_all)(levels)
    }
    pub unsafe fn vcos_log_dump_mem_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ) -> () {
        (self.vcos_log_dump_mem_impl)(cat, label, addr, voidMem, numBytes)
    }
    pub unsafe fn vcos_cmd_vprintf(
        &self,
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_cmd_vprintf)(param, fmt, args)
    }
    pub unsafe fn vcos_cmd_always_log_output(&self, log_category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_cmd_always_log_output)(log_category)
    }
    pub unsafe fn vcos_cmd_usage(&self, param: *mut VCOS_CMD_PARAM_T) -> () {
        (self.vcos_cmd_usage)(param)
    }
    pub unsafe fn vcos_cmd_register(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_register_multiple(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register_multiple)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_execute(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_cmd_execute)(argc, argv, result_size, result_buf)
    }
    pub unsafe fn vcos_cmd_shutdown(&self) -> () {
        (self.vcos_cmd_shutdown)()
    }
    pub unsafe fn vcos_log_assert_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_assert_cmd)(param)
    }
    pub unsafe fn vcos_log_set_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_set_cmd)(param)
    }
    pub unsafe fn vcos_log_status_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_status_cmd)(param)
    }
    pub unsafe fn vcos_log_test_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_test_cmd)(param)
    }
    pub unsafe fn vcos_vsnprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int {
        (self.vcos_vsnprintf)(buf, buflen, fmt, ap)
    }
    pub unsafe fn vcos_safe_vsprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t {
        (self.vcos_safe_vsprintf)(buf, buflen, offset, fmt, ap)
    }
    pub unsafe fn vcos_safe_strcpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strcpy)(dst, src, dstlen, offset)
    }
    pub unsafe fn vcos_safe_strncpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strncpy)(dst, src, srclen, dstlen, offset)
    }
    pub unsafe fn vcos_thread_attr_init(&self, attrs: *mut VCOS_THREAD_ATTR_T) -> () {
        (self.vcos_thread_attr_init)(attrs)
    }
    pub unsafe fn vcos_timer_init(&self) -> VCOS_STATUS_T {
        (self.vcos_timer_init)()
    }
    pub unsafe fn vcos_once(
        &self,
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T {
        (self.vcos_once)(once_control, init_routine)
    }
    pub unsafe fn vc_dispman_init(&self) -> ::std::os::raw::c_int {
        (self.vc_dispman_init)()
    }
    pub unsafe fn vc_dispmanx_stop(&self) -> () {
        (self.vc_dispmanx_stop)()
    }
    pub unsafe fn vc_dispmanx_rect_set(
        &self,
        rect: *mut VC_RECT_T,
        x_offset: u32,
        y_offset: u32,
        width: u32,
        height: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_rect_set)(rect, x_offset, y_offset, width, height)
    }
    pub unsafe fn vc_dispmanx_resource_create(
        &self,
        type_: VC_IMAGE_TYPE_T,
        width: u32,
        height: u32,
        native_image_handle: *mut u32,
    ) -> DISPMANX_RESOURCE_HANDLE_T {
        (self.vc_dispmanx_resource_create)(type_, width, height, native_image_handle)
    }
    pub unsafe fn vc_dispmanx_resource_write_data(
        &self,
        res: DISPMANX_RESOURCE_HANDLE_T,
        src_type: VC_IMAGE_TYPE_T,
        src_pitch: ::std::os::raw::c_int,
        src_address: *mut ::std::os::raw::c_void,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_resource_write_data)(res, src_type, src_pitch, src_address, rect)
    }
    pub unsafe fn vc_dispmanx_resource_write_data_handle(
        &self,
        res: DISPMANX_RESOURCE_HANDLE_T,
        src_type: VC_IMAGE_TYPE_T,
        src_pitch: ::std::os::raw::c_int,
        handle: VCHI_MEM_HANDLE_T,
        offset: u32,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_resource_write_data_handle)(
            res, src_type, src_pitch, handle, offset, rect,
        )
    }
    pub unsafe fn vc_dispmanx_resource_read_data(
        &self,
        handle: DISPMANX_RESOURCE_HANDLE_T,
        p_rect: *const VC_RECT_T,
        dst_address: *mut ::std::os::raw::c_void,
        dst_pitch: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_resource_read_data)(handle, p_rect, dst_address, dst_pitch)
    }
    pub unsafe fn vc_dispmanx_resource_delete(
        &self,
        res: DISPMANX_RESOURCE_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_resource_delete)(res)
    }
    pub unsafe fn vc_dispmanx_display_open(&self, device: u32) -> DISPMANX_DISPLAY_HANDLE_T {
        (self.vc_dispmanx_display_open)(device)
    }
    pub unsafe fn vc_dispmanx_display_open_mode(
        &self,
        device: u32,
        mode: u32,
    ) -> DISPMANX_DISPLAY_HANDLE_T {
        (self.vc_dispmanx_display_open_mode)(device, mode)
    }
    pub unsafe fn vc_dispmanx_display_open_offscreen(
        &self,
        dest: DISPMANX_RESOURCE_HANDLE_T,
        orientation: DISPMANX_TRANSFORM_T,
    ) -> DISPMANX_DISPLAY_HANDLE_T {
        (self.vc_dispmanx_display_open_offscreen)(dest, orientation)
    }
    pub unsafe fn vc_dispmanx_display_reconfigure(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
        mode: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_display_reconfigure)(display, mode)
    }
    pub unsafe fn vc_dispmanx_display_set_destination(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
        dest: DISPMANX_RESOURCE_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_display_set_destination)(display, dest)
    }
    pub unsafe fn vc_dispmanx_display_set_background(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        display: DISPMANX_DISPLAY_HANDLE_T,
        red: u8,
        green: u8,
        blue: u8,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_display_set_background)(update, display, red, green, blue)
    }
    pub unsafe fn vc_dispmanx_display_get_info(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
        pinfo: *mut DISPMANX_MODEINFO_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_display_get_info)(display, pinfo)
    }
    pub unsafe fn vc_dispmanx_display_close(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_display_close)(display)
    }
    pub unsafe fn vc_dispmanx_update_start(&self, priority: i32) -> DISPMANX_UPDATE_HANDLE_T {
        (self.vc_dispmanx_update_start)(priority)
    }
    pub unsafe fn vc_dispmanx_element_add(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        display: DISPMANX_DISPLAY_HANDLE_T,
        layer: i32,
        dest_rect: *const VC_RECT_T,
        src: DISPMANX_RESOURCE_HANDLE_T,
        src_rect: *const VC_RECT_T,
        protection: DISPMANX_PROTECTION_T,
        alpha: *mut VC_DISPMANX_ALPHA_T,
        clamp: *mut DISPMANX_CLAMP_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> DISPMANX_ELEMENT_HANDLE_T {
        (self.vc_dispmanx_element_add)(
            update, display, layer, dest_rect, src, src_rect, protection, alpha, clamp, transform,
        )
    }
    pub unsafe fn vc_dispmanx_element_change_source(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        src: DISPMANX_RESOURCE_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_element_change_source)(update, element, src)
    }
    pub unsafe fn vc_dispmanx_element_change_layer(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        layer: i32,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_element_change_layer)(update, element, layer)
    }
    pub unsafe fn vc_dispmanx_element_modified(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        rect: *const VC_RECT_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_element_modified)(update, element, rect)
    }
    pub unsafe fn vc_dispmanx_element_remove(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_element_remove)(update, element)
    }
    pub unsafe fn vc_dispmanx_update_submit(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        cb_func: DISPMANX_CALLBACK_FUNC_T,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_update_submit)(update, cb_func, cb_arg)
    }
    pub unsafe fn vc_dispmanx_update_submit_sync(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_update_submit_sync)(update)
    }
    pub unsafe fn vc_dispmanx_query_image_formats(
        &self,
        supported_formats: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_query_image_formats)(supported_formats)
    }
    pub unsafe fn vc_dispmanx_element_change_attributes(
        &self,
        update: DISPMANX_UPDATE_HANDLE_T,
        element: DISPMANX_ELEMENT_HANDLE_T,
        change_flags: u32,
        layer: i32,
        opacity: u8,
        dest_rect: *const VC_RECT_T,
        src_rect: *const VC_RECT_T,
        mask: DISPMANX_RESOURCE_HANDLE_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_element_change_attributes)(
            update,
            element,
            change_flags,
            layer,
            opacity,
            dest_rect,
            src_rect,
            mask,
            transform,
        )
    }
    pub unsafe fn vc_dispmanx_resource_get_image_handle(
        &self,
        res: DISPMANX_RESOURCE_HANDLE_T,
    ) -> u32 {
        (self.vc_dispmanx_resource_get_image_handle)(res)
    }
    pub unsafe fn vc_vchi_dispmanx_init(
        &self,
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> () {
        (self.vc_vchi_dispmanx_init)(initialise_instance, connections, num_connections)
    }
    pub unsafe fn vc_dispmanx_snapshot(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
        snapshot_resource: DISPMANX_RESOURCE_HANDLE_T,
        transform: DISPMANX_TRANSFORM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_snapshot)(display, snapshot_resource, transform)
    }
    pub unsafe fn vc_dispmanx_resource_set_palette(
        &self,
        handle: DISPMANX_RESOURCE_HANDLE_T,
        src_address: *mut ::std::os::raw::c_void,
        offset: ::std::os::raw::c_int,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_resource_set_palette)(handle, src_address, offset, size)
    }
    pub unsafe fn vc_dispmanx_vsync_callback(
        &self,
        display: DISPMANX_DISPLAY_HANDLE_T,
        cb_func: DISPMANX_CALLBACK_FUNC_T,
        cb_arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int {
        (self.vc_dispmanx_vsync_callback)(display, cb_func, cb_arg)
    }
    pub unsafe fn vc_vchi_tv_init(
        &self,
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_vchi_tv_init)(initialise_instance, connections, num_connections)
    }
    pub unsafe fn vc_vchi_tv_stop(&self) -> () {
        (self.vc_vchi_tv_stop)()
    }
    pub unsafe fn vc_tv_register_callback(
        &self,
        callback: TVSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vc_tv_register_callback)(callback, callback_data)
    }
    pub unsafe fn vc_tv_unregister_callback(&self, callback: TVSERVICE_CALLBACK_T) -> () {
        (self.vc_tv_unregister_callback)(callback)
    }
    pub unsafe fn vc_tv_unregister_callback_full(
        &self,
        callback: TVSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vc_tv_unregister_callback_full)(callback, callback_data)
    }
    pub unsafe fn vc_tv_get_state(
        &self,
        tvstate: *mut TV_GET_STATE_RESP_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_state)(tvstate)
    }
    pub unsafe fn vc_tv_get_state_id(
        &self,
        display_id: u32,
        tvstate: *mut TV_GET_STATE_RESP_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_state_id)(display_id, tvstate)
    }
    pub unsafe fn vc_tv_get_display_state(
        &self,
        tvstate: *mut TV_DISPLAY_STATE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_display_state)(tvstate)
    }
    pub unsafe fn vc_tv_get_display_state_id(
        &self,
        display_id: u32,
        tvstate: *mut TV_DISPLAY_STATE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_display_state_id)(display_id, tvstate)
    }
    pub unsafe fn vc_tv_hdmi_power_on_preferred(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_preferred)()
    }
    pub unsafe fn vc_tv_hdmi_power_on_preferred_id(
        &self,
        display_id: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_preferred_id)(display_id)
    }
    pub unsafe fn vc_tv_hdmi_power_on_preferred_3d(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_preferred_3d)()
    }
    pub unsafe fn vc_tv_hdmi_power_on_preferred_3d_id(
        &self,
        display_id: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_preferred_3d_id)(display_id)
    }
    pub unsafe fn vc_tv_hdmi_power_on_best(
        &self,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_best)(width, height, frame_rate, scan_mode, match_flags)
    }
    pub unsafe fn vc_tv_hdmi_power_on_best_id(
        &self,
        display_id: u32,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_best_id)(
            display_id,
            width,
            height,
            frame_rate,
            scan_mode,
            match_flags,
        )
    }
    pub unsafe fn vc_tv_hdmi_power_on_best_3d(
        &self,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_best_3d)(width, height, frame_rate, scan_mode, match_flags)
    }
    pub unsafe fn vc_tv_hdmi_power_on_best_3d_id(
        &self,
        display_id: u32,
        width: u32,
        height: u32,
        frame_rate: u32,
        scan_mode: HDMI_INTERLACED_T,
        match_flags: EDID_MODE_MATCH_FLAG_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_best_3d_id)(
            display_id,
            width,
            height,
            frame_rate,
            scan_mode,
            match_flags,
        )
    }
    pub unsafe fn vc_tv_hdmi_power_on_explicit_new(
        &self,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_explicit_new)(mode, group, code)
    }
    pub unsafe fn vc_tv_hdmi_power_on_explicit_new_id(
        &self,
        display_id: u32,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_explicit_new_id)(display_id, mode, group, code)
    }
    pub unsafe fn vc_tv_sdtv_power_on(
        &self,
        mode: SDTV_MODE_T,
        options: *mut SDTV_OPTIONS_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_sdtv_power_on)(mode, options)
    }
    pub unsafe fn vc_tv_sdtv_power_on_id(
        &self,
        display_id: u32,
        mode: SDTV_MODE_T,
        options: *mut SDTV_OPTIONS_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_sdtv_power_on_id)(display_id, mode, options)
    }
    pub unsafe fn vc_tv_power_off(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_power_off)()
    }
    pub unsafe fn vc_tv_power_off_id(&self, display_id: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_power_off_id)(display_id)
    }
    pub unsafe fn vc_tv_hdmi_get_supported_modes_new(
        &self,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_NEW_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_supported_modes_new)(
            group,
            supported_modes,
            max_supported_modes,
            preferred_group,
            preferred_mode,
        )
    }
    pub unsafe fn vc_tv_hdmi_get_supported_modes_new_id(
        &self,
        display_id: u32,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_NEW_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_supported_modes_new_id)(
            display_id,
            group,
            supported_modes,
            max_supported_modes,
            preferred_group,
            preferred_mode,
        )
    }
    pub unsafe fn vc_tv_hdmi_mode_supported(
        &self,
        group: HDMI_RES_GROUP_T,
        mode: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_mode_supported)(group, mode)
    }
    pub unsafe fn vc_tv_hdmi_mode_supported_id(
        &self,
        display_d: u32,
        group: HDMI_RES_GROUP_T,
        mode: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_mode_supported_id)(display_d, group, mode)
    }
    pub unsafe fn vc_tv_hdmi_audio_supported(
        &self,
        audio_format: u32,
        num_channels: u32,
        fs: EDID_AudioSampleRate,
        bitrate: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_audio_supported)(audio_format, num_channels, fs, bitrate)
    }
    pub unsafe fn vc_tv_hdmi_audio_supported_id(
        &self,
        display_id: u32,
        audio_format: u32,
        num_channels: u32,
        fs: EDID_AudioSampleRate,
        bitrate: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_audio_supported_id)(display_id, audio_format, num_channels, fs, bitrate)
    }
    pub unsafe fn vc_tv_enable_copyprotect(
        &self,
        cp_mode: u32,
        timeout: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_enable_copyprotect)(cp_mode, timeout)
    }
    pub unsafe fn vc_tv_enable_copyprotect_id(
        &self,
        display_id: u32,
        cp_mode: u32,
        timeout: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_enable_copyprotect_id)(display_id, cp_mode, timeout)
    }
    pub unsafe fn vc_tv_disable_copyprotect(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_disable_copyprotect)()
    }
    pub unsafe fn vc_tv_disable_copyprotect_id(&self, display_id: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_disable_copyprotect_id)(display_id)
    }
    pub unsafe fn vc_tv_show_info(&self, show: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_show_info)(show)
    }
    pub unsafe fn vc_tv_show_info_id(&self, display_id: u32, show: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_show_info_id)(display_id, show)
    }
    pub unsafe fn vc_tv_hdmi_get_av_latency(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_av_latency)()
    }
    pub unsafe fn vc_tv_hdmi_get_av_latency_id(&self, display_id: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_av_latency_id)(display_id)
    }
    pub unsafe fn vc_tv_hdmi_set_hdcp_key(&self, key: *const u8) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_hdcp_key)(key)
    }
    pub unsafe fn vc_tv_hdmi_set_hdcp_key_id(
        &self,
        display_id: u32,
        key: *const u8,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_hdcp_key_id)(display_id, key)
    }
    pub unsafe fn vc_tv_hdmi_set_hdcp_revoked_list(
        &self,
        list: *const u8,
        num_keys: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_hdcp_revoked_list)(list, num_keys)
    }
    pub unsafe fn vc_tv_hdmi_set_hdcp_revoked_list_id(
        &self,
        display_id: u32,
        list: *const u8,
        num_keys: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_hdcp_revoked_list_id)(display_id, list, num_keys)
    }
    pub unsafe fn vc_tv_hdmi_set_spd(
        &self,
        manufacturer: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: HDMI_SPD_TYPE_CODE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_spd)(manufacturer, description, type_)
    }
    pub unsafe fn vc_tv_hdmi_set_spd_id(
        &self,
        display_id: u32,
        manufacturer: *const ::std::os::raw::c_char,
        description: *const ::std::os::raw::c_char,
        type_: HDMI_SPD_TYPE_CODE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_spd_id)(display_id, manufacturer, description, type_)
    }
    pub unsafe fn vc_tv_hdmi_set_display_options(
        &self,
        aspect: HDMI_ASPECT_T,
        left_bar_width: u32,
        right_bar_width: u32,
        top_bar_height: u32,
        bottom_bar_height: u32,
        overscan_flags: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_display_options)(
            aspect,
            left_bar_width,
            right_bar_width,
            top_bar_height,
            bottom_bar_height,
            overscan_flags,
        )
    }
    pub unsafe fn vc_tv_hdmi_set_display_options_id(
        &self,
        display_id: u32,
        aspect: HDMI_ASPECT_T,
        left_bar_width: u32,
        right_bar_width: u32,
        top_bar_height: u32,
        bottom_bar_height: u32,
        overscan_flags: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_display_options_id)(
            display_id,
            aspect,
            left_bar_width,
            right_bar_width,
            top_bar_height,
            bottom_bar_height,
            overscan_flags,
        )
    }
    pub unsafe fn vc_tv_test_mode_start(
        &self,
        colour: u32,
        test_mode: TV_TEST_MODE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_test_mode_start)(colour, test_mode)
    }
    pub unsafe fn vc_tv_test_mode_start_id(
        &self,
        display_id: u32,
        colour: u32,
        test_mode: TV_TEST_MODE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_test_mode_start_id)(display_id, colour, test_mode)
    }
    pub unsafe fn vc_tv_test_mode_stop(&self) -> ::std::os::raw::c_int {
        (self.vc_tv_test_mode_stop)()
    }
    pub unsafe fn vc_tv_test_mode_stop_id(&self, display_id: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_test_mode_stop_id)(display_id)
    }
    pub unsafe fn vc_tv_hdmi_ddc_read(
        &self,
        offset: u32,
        length: u32,
        buffer: *mut u8,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_ddc_read)(offset, length, buffer)
    }
    pub unsafe fn vc_tv_hdmi_ddc_read_id(
        &self,
        display_id: u32,
        offset: u32,
        length: u32,
        buffer: *mut u8,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_ddc_read_id)(display_id, offset, length, buffer)
    }
    pub unsafe fn vc_tv_hdmi_set_attached(&self, attached: u32) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_attached)(attached)
    }
    pub unsafe fn vc_tv_hdmi_set_attached_id(
        &self,
        display_id: u32,
        attached: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_attached_id)(display_id, attached)
    }
    pub unsafe fn vc_tv_hdmi_set_property(
        &self,
        property: *const HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_property)(property)
    }
    pub unsafe fn vc_tv_hdmi_set_property_id(
        &self,
        display_id: u32,
        property: *const HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_set_property_id)(display_id, property)
    }
    pub unsafe fn vc_tv_hdmi_get_property(
        &self,
        property: *mut HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_property)(property)
    }
    pub unsafe fn vc_tv_hdmi_get_property_id(
        &self,
        display_id: u32,
        property: *mut HDMI_PROPERTY_PARAM_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_property_id)(display_id, property)
    }
    pub unsafe fn vc_tv_notification_name(
        &self,
        reason: VC_HDMI_NOTIFY_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vc_tv_notification_name)(reason)
    }
    pub unsafe fn vc_tv_notification_name_id(
        &self,
        display_id: u32,
        reason: VC_HDMI_NOTIFY_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vc_tv_notification_name_id)(display_id, reason)
    }
    pub unsafe fn vc_tv_get_device_id(&self, id: *mut TV_DEVICE_ID_T) -> ::std::os::raw::c_int {
        (self.vc_tv_get_device_id)(id)
    }
    pub unsafe fn vc_tv_get_device_id_id(
        &self,
        display_id: u32,
        id: *mut TV_DEVICE_ID_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_device_id_id)(display_id, id)
    }
    pub unsafe fn vc_tv_get_attached_devices(
        &self,
        devices: *mut TV_ATTACHED_DEVICES_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_get_attached_devices)(devices)
    }
    pub unsafe fn vc_tv_hdmi_get_supported_modes(
        &self,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_supported_modes)(
            group,
            supported_modes,
            max_supported_modes,
            preferred_group,
            preferred_mode,
        )
    }
    pub unsafe fn vc_tv_hdmi_get_supported_modes_id(
        &self,
        display_id: u32,
        group: HDMI_RES_GROUP_T,
        supported_modes: *mut TV_SUPPORTED_MODE_T,
        max_supported_modes: u32,
        preferred_group: *mut HDMI_RES_GROUP_T,
        preferred_mode: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_get_supported_modes_id)(
            display_id,
            group,
            supported_modes,
            max_supported_modes,
            preferred_group,
            preferred_mode,
        )
    }
    pub unsafe fn vc_tv_hdmi_power_on_explicit(
        &self,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_explicit)(mode, group, code)
    }
    pub unsafe fn vc_tv_hdmi_power_on_explicit_id(
        &self,
        display_id: u32,
        mode: HDMI_MODE_T,
        group: HDMI_RES_GROUP_T,
        code: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_tv_hdmi_power_on_explicit_id)(display_id, mode, group, code)
    }
    pub unsafe fn vc_vchi_cec_init(
        &self,
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> () {
        (self.vc_vchi_cec_init)(initialise_instance, connections, num_connections)
    }
    pub unsafe fn vc_vchi_cec_stop(&self) -> () {
        (self.vc_vchi_cec_stop)()
    }
    pub unsafe fn vc_cec_register_callback(
        &self,
        callback: CECSERVICE_CALLBACK_T,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vc_cec_register_callback)(callback, callback_data)
    }
    pub unsafe fn vc_cec_register_command(&self, opcode: CEC_OPCODE_T) -> ::std::os::raw::c_int {
        (self.vc_cec_register_command)(opcode)
    }
    pub unsafe fn vc_cec_register_all(&self) -> ::std::os::raw::c_int {
        (self.vc_cec_register_all)()
    }
    pub unsafe fn vc_cec_deregister_command(&self, opcode: CEC_OPCODE_T) -> ::std::os::raw::c_int {
        (self.vc_cec_deregister_command)(opcode)
    }
    pub unsafe fn vc_cec_deregister_all(&self) -> ::std::os::raw::c_int {
        (self.vc_cec_deregister_all)()
    }
    pub unsafe fn vc_cec_send_message(
        &self,
        follower: u32,
        payload: *const u8,
        length: u32,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_message)(follower, payload, length, is_reply)
    }
    pub unsafe fn vc_cec_get_logical_address(
        &self,
        logical_address: *mut CEC_AllDevices_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_get_logical_address)(logical_address)
    }
    pub unsafe fn vc_cec_alloc_logical_address(&self) -> ::std::os::raw::c_int {
        (self.vc_cec_alloc_logical_address)()
    }
    pub unsafe fn vc_cec_release_logical_address(&self) -> ::std::os::raw::c_int {
        (self.vc_cec_release_logical_address)()
    }
    pub unsafe fn vc_cec_get_topology(
        &self,
        topology: *mut VC_CEC_TOPOLOGY_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_get_topology)(topology)
    }
    pub unsafe fn vc_cec_set_vendor_id(&self, id: u32) -> ::std::os::raw::c_int {
        (self.vc_cec_set_vendor_id)(id)
    }
    pub unsafe fn vc_cec_set_osd_name(
        &self,
        name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_set_osd_name)(name)
    }
    pub unsafe fn vc_cec_get_physical_address(
        &self,
        physical_address: *mut u16,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_get_physical_address)(physical_address)
    }
    pub unsafe fn vc_cec_get_vendor_id(
        &self,
        logical_address: CEC_AllDevices_T,
        vendor_id: *mut u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_get_vendor_id)(logical_address, vendor_id)
    }
    pub unsafe fn vc_cec_device_type(
        &self,
        logical_address: CEC_AllDevices_T,
    ) -> CEC_DEVICE_TYPE_T {
        (self.vc_cec_device_type)(logical_address)
    }
    pub unsafe fn vc_cec_send_message2(
        &self,
        message: *const VC_CEC_MESSAGE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_message2)(message)
    }
    pub unsafe fn vc_cec_param2message(
        &self,
        reason: u32,
        param1: u32,
        param2: u32,
        param3: u32,
        param4: u32,
        message: *mut VC_CEC_MESSAGE_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_param2message)(reason, param1, param2, param3, param4, message)
    }
    pub unsafe fn vc_cec_poll_address(
        &self,
        logical_address: CEC_AllDevices_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_poll_address)(logical_address)
    }
    pub unsafe fn vc_cec_set_logical_address(
        &self,
        logical_address: CEC_AllDevices_T,
        device_type: CEC_DEVICE_TYPE_T,
        vendor_id: u32,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_set_logical_address)(logical_address, device_type, vendor_id)
    }
    pub unsafe fn vc_cec_add_device(
        &self,
        logical_address: CEC_AllDevices_T,
        physical_address: u16,
        device_type: CEC_DEVICE_TYPE_T,
        last_device: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_add_device)(logical_address, physical_address, device_type, last_device)
    }
    pub unsafe fn vc_cec_set_passive(&self, enabled: vcos_bool_t) -> ::std::os::raw::c_int {
        (self.vc_cec_set_passive)(enabled)
    }
    pub unsafe fn vc_cec_send_FeatureAbort(
        &self,
        follower: u32,
        opcode: CEC_OPCODE_T,
        reason: CEC_ABORT_REASON_T,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_FeatureAbort)(follower, opcode, reason)
    }
    pub unsafe fn vc_cec_send_ActiveSource(
        &self,
        physical_address: u16,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_ActiveSource)(physical_address, is_reply)
    }
    pub unsafe fn vc_cec_send_ImageViewOn(
        &self,
        follower: u32,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_ImageViewOn)(follower, is_reply)
    }
    pub unsafe fn vc_cec_send_SetOSDString(
        &self,
        follower: u32,
        disp_ctrl: CEC_DISPLAY_CONTROL_T,
        string: *const ::std::os::raw::c_char,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_SetOSDString)(follower, disp_ctrl, string, is_reply)
    }
    pub unsafe fn vc_cec_send_Standby(
        &self,
        follower: u32,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_Standby)(follower, is_reply)
    }
    pub unsafe fn vc_cec_send_MenuStatus(
        &self,
        follower: u32,
        menu_state: CEC_MENU_STATE_T,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_MenuStatus)(follower, menu_state, is_reply)
    }
    pub unsafe fn vc_cec_send_ReportPhysicalAddress(
        &self,
        physical_address: u16,
        device_type: CEC_DEVICE_TYPE_T,
        is_reply: vcos_bool_t,
    ) -> ::std::os::raw::c_int {
        (self.vc_cec_send_ReportPhysicalAddress)(physical_address, device_type, is_reply)
    }
    pub unsafe fn vc_os_close(&self) -> () {
        (self.vc_os_close)()
    }
    pub unsafe fn vc_vchi_gencmd_init(
        &self,
        initialise_instance: VCHI_INSTANCE_T,
        connections: *mut *mut VCHI_CONNECTION_T,
        num_connections: u32,
    ) -> () {
        (self.vc_vchi_gencmd_init)(initialise_instance, connections, num_connections)
    }
    pub unsafe fn vc_gencmd_init(&self) -> ::std::os::raw::c_int {
        (self.vc_gencmd_init)()
    }
    pub unsafe fn vc_gencmd_stop(&self) -> () {
        (self.vc_gencmd_stop)()
    }
    pub unsafe fn vc_gencmd_read_response(
        &self,
        response: *mut ::std::os::raw::c_char,
        maxlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_read_response)(response, maxlen)
    }
    pub unsafe fn vc_gencmd_string_property(
        &self,
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut *mut ::std::os::raw::c_char,
        length: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_string_property)(text, property, value, length)
    }
    pub unsafe fn vc_gencmd_number_property(
        &self,
        text: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        number: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_number_property)(text, property, number)
    }
    pub unsafe fn vc_gencmd_until(
        &self,
        cmd: *mut ::std::os::raw::c_char,
        property: *const ::std::os::raw::c_char,
        value: *mut ::std::os::raw::c_char,
        error_string: *const ::std::os::raw::c_char,
        timeout: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vc_gencmd_until)(cmd, property, value, error_string, timeout)
    }
    pub unsafe fn bcm_host_get_model_type(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_get_model_type)()
    }
    pub unsafe fn bcm_host_is_model_pi4(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_model_pi4)()
    }
    pub unsafe fn bcm_host_is_fkms_active(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_fkms_active)()
    }
    pub unsafe fn bcm_host_is_kms_active(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_is_kms_active)()
    }
    pub unsafe fn bcm_host_get_processor_id(&self) -> ::std::os::raw::c_int {
        (self.bcm_host_get_processor_id)()
    }
}
