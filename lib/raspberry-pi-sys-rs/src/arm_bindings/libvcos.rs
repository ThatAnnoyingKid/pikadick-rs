/* automatically generated by rust-bindgen 0.59.2 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub type size_t = ::std::os::raw::c_uint;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type VCOS_THREAD_ENTRY_FN_T = ::std::option::Option<
    unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
>;
pub const VCOS_STATUS_T_VCOS_SUCCESS: VCOS_STATUS_T = 0;
pub const VCOS_STATUS_T_VCOS_EAGAIN: VCOS_STATUS_T = 1;
pub const VCOS_STATUS_T_VCOS_ENOENT: VCOS_STATUS_T = 2;
pub const VCOS_STATUS_T_VCOS_ENOSPC: VCOS_STATUS_T = 3;
pub const VCOS_STATUS_T_VCOS_EINVAL: VCOS_STATUS_T = 4;
pub const VCOS_STATUS_T_VCOS_EACCESS: VCOS_STATUS_T = 5;
pub const VCOS_STATUS_T_VCOS_ENOMEM: VCOS_STATUS_T = 6;
pub const VCOS_STATUS_T_VCOS_ENOSYS: VCOS_STATUS_T = 7;
pub const VCOS_STATUS_T_VCOS_EEXIST: VCOS_STATUS_T = 8;
pub const VCOS_STATUS_T_VCOS_ENXIO: VCOS_STATUS_T = 9;
pub const VCOS_STATUS_T_VCOS_EINTR: VCOS_STATUS_T = 10;
pub type VCOS_STATUS_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: __pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__spins as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_mutex_s__bindgen_ty_1>())).__list as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = ::std::os::raw::c_ulong;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union sem_t {
    pub __size: [::std::os::raw::c_char; 16usize],
    pub __align: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_sem_t() {
    assert_eq!(
        ::std::mem::size_of::<sem_t>(),
        16usize,
        concat!("Size of: ", stringify!(sem_t))
    );
    assert_eq!(
        ::std::mem::align_of::<sem_t>(),
        4usize,
        concat!("Alignment of ", stringify!(sem_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sem_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sem_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type VCOS_SEMAPHORE_T = sem_t;
pub type VCOS_UNSIGNED = u32;
pub type VCOS_OPTION = u32;
pub type VCOS_ONCE_T = pthread_once_t;
pub type VCOS_MUTEX_T = pthread_mutex_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_TIMER_T {
    pub thread: pthread_t,
    pub lock: pthread_mutex_t,
    pub settings_changed: pthread_cond_t,
    pub quit: ::std::os::raw::c_int,
    pub expires: timespec,
    pub orig_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_TIMER_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_TIMER_T>(),
        104usize,
        concat!("Size of: ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_TIMER_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_TIMER_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).settings_changed as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(settings_changed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).quit as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(quit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).expires as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(expires)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_expiration_routine as *const _ as usize
        },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_expiration_routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_TIMER_T>())).orig_context as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_TIMER_T),
            "::",
            stringify!(orig_context)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_ATTR_T {
    pub ta_stackaddr: *mut ::std::os::raw::c_void,
    pub ta_stacksz: VCOS_UNSIGNED,
    pub ta_priority: VCOS_UNSIGNED,
    pub ta_affinity: VCOS_UNSIGNED,
    pub ta_timeslice: VCOS_UNSIGNED,
    pub legacy: VCOS_UNSIGNED,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_ATTR_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_ATTR_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_ATTR_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_ATTR_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stackaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stackaddr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_stacksz as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_stacksz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_priority as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_affinity as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_affinity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).ta_timeslice as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(ta_timeslice)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_ATTR_T>())).legacy as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_ATTR_T),
            "::",
            stringify!(legacy)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_THREAD_EXIT_T {
    pub pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub cxt: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_EXIT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_EXIT_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_EXIT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_EXIT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).pfn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(pfn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_EXIT_T>())).cxt as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_EXIT_T),
            "::",
            stringify!(cxt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_THREAD_T {
    pub thread: pthread_t,
    pub entry: VCOS_THREAD_ENTRY_FN_T,
    pub arg: *mut ::std::os::raw::c_void,
    pub suspend: VCOS_SEMAPHORE_T,
    pub task_timer: VCOS_TIMER_T,
    pub task_timer_created: ::std::os::raw::c_int,
    pub orig_task_timer_expiration_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub orig_task_timer_context: *mut ::std::os::raw::c_void,
    pub legacy: VCOS_UNSIGNED,
    pub name: [::std::os::raw::c_char; 16usize],
    pub dummy: VCOS_UNSIGNED,
    pub at_exit: [VCOS_THREAD_EXIT_T; 4usize],
}
#[test]
fn bindgen_test_layout_VCOS_THREAD_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_THREAD_T>(),
        208usize,
        concat!("Size of: ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_THREAD_T>(),
        8usize,
        concat!("Alignment of ", stringify!(VCOS_THREAD_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).thread as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(thread)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).entry as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).suspend as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(suspend)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).task_timer_created as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(task_timer_created)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_expiration_routine as *const _
                as usize
        },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_expiration_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_THREAD_T>())).orig_task_timer_context as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(orig_task_timer_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).legacy as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(legacy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).name as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).dummy as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(dummy)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_THREAD_T>())).at_exit as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_THREAD_T),
            "::",
            stringify!(at_exit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_WAITER_T {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T {
    pub events: VCOS_UNSIGNED,
    pub lock: VCOS_MUTEX_T,
    pub waiters: VCOS_EVENT_FLAGS_T__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_EVENT_FLAGS_T__bindgen_ty_1 {
    pub head: *mut VCOS_EVENT_WAITER_T,
    pub tail: *mut VCOS_EVENT_WAITER_T,
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).head as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(head)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T__bindgen_ty_1>())).tail as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T__bindgen_ty_1),
            "::",
            stringify!(tail)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_EVENT_FLAGS_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_EVENT_FLAGS_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_EVENT_FLAGS_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_EVENT_FLAGS_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).events as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(events)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).lock as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_EVENT_FLAGS_T>())).waiters as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_EVENT_FLAGS_T),
            "::",
            stringify!(waiters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_HEADER_TAG {
    pub owner: VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1 {
    pub next: *mut VCOS_BLOCKPOOL_HEADER_TAG,
    pub subpool: *mut VCOS_BLOCKPOOL_SUBPOOL_TAG,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).next as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1>())).subpool as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG__bindgen_ty_1),
            "::",
            stringify!(subpool)
        )
    );
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_HEADER_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_HEADER_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_HEADER_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_HEADER_TAG>())).owner as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_HEADER_TAG),
            "::",
            stringify!(owner)
        )
    );
}
pub type VCOS_BLOCKPOOL_HEADER_T = VCOS_BLOCKPOOL_HEADER_TAG;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_BLOCKPOOL_SUBPOOL_TAG {
    pub magic: u32,
    pub free_list: *mut VCOS_BLOCKPOOL_HEADER_T,
    pub mem: *mut ::std::os::raw::c_void,
    pub start: *mut ::std::os::raw::c_void,
    pub end: *mut ::std::os::raw::c_void,
    pub num_blocks: VCOS_UNSIGNED,
    pub available_blocks: VCOS_UNSIGNED,
    pub owner: *mut VCOS_BLOCKPOOL_TAG,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_SUBPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_SUBPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).magic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).free_list as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(free_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).mem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(mem)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).start as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(end)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).num_blocks as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(num_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).available_blocks as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(available_blocks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).owner as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_SUBPOOL_TAG>())).flags as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_SUBPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
}
pub type VCOS_BLOCKPOOL_SUBPOOL_T = VCOS_BLOCKPOOL_SUBPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_BLOCKPOOL_TAG {
    pub magic: u32,
    pub mutex: VCOS_MUTEX_T,
    pub align: VCOS_UNSIGNED,
    pub flags: VCOS_UNSIGNED,
    pub block_data_size: size_t,
    pub block_size: size_t,
    pub name: *const ::std::os::raw::c_char,
    pub num_subpools: VCOS_UNSIGNED,
    pub num_extension_blocks: VCOS_UNSIGNED,
    pub subpools: [VCOS_BLOCKPOOL_SUBPOOL_T; 8usize],
}
#[test]
fn bindgen_test_layout_VCOS_BLOCKPOOL_TAG() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_BLOCKPOOL_TAG>(),
        344usize,
        concat!("Size of: ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_BLOCKPOOL_TAG>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_BLOCKPOOL_TAG))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).magic as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).mutex as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).align as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(align)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_data_size as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).block_size as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).name as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_subpools as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_subpools)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).num_extension_blocks as *const _ as usize
        },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(num_extension_blocks)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_BLOCKPOOL_TAG>())).subpools as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_BLOCKPOOL_TAG),
            "::",
            stringify!(subpools)
        )
    );
}
pub type VCOS_BLOCKPOOL_T = VCOS_BLOCKPOOL_TAG;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct VCOS_REENTRANT_MUTEX_T {
    pub mutex: VCOS_MUTEX_T,
    pub owner: *mut VCOS_THREAD_T,
    pub count: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_VCOS_REENTRANT_MUTEX_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_REENTRANT_MUTEX_T>(),
        32usize,
        concat!("Size of: ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_REENTRANT_MUTEX_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_REENTRANT_MUTEX_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).owner as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_REENTRANT_MUTEX_T>())).count as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_REENTRANT_MUTEX_T),
            "::",
            stringify!(count)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_T {
    pub actual: *mut VCOS_NAMED_SEMAPHORE_IMPL_T,
    pub sem: *mut VCOS_SEMAPHORE_T,
}
#[test]
fn bindgen_test_layout_VCOS_NAMED_SEMAPHORE_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_NAMED_SEMAPHORE_T>(),
        8usize,
        concat!("Size of: ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_NAMED_SEMAPHORE_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_NAMED_SEMAPHORE_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).actual as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(actual)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_NAMED_SEMAPHORE_T>())).sem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_NAMED_SEMAPHORE_T),
            "::",
            stringify!(sem)
        )
    );
}
pub type va_list = u32;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_UNINITIALIZED: VCOS_LOG_LEVEL_T = 0;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_NEVER: VCOS_LOG_LEVEL_T = 1;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_ERROR: VCOS_LOG_LEVEL_T = 2;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_WARN: VCOS_LOG_LEVEL_T = 3;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_INFO: VCOS_LOG_LEVEL_T = 4;
pub const VCOS_LOG_LEVEL_T_VCOS_LOG_TRACE: VCOS_LOG_LEVEL_T = 5;
pub type VCOS_LOG_LEVEL_T = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T {
    pub level: VCOS_LOG_LEVEL_T,
    pub name: *const ::std::os::raw::c_char,
    pub next: *mut VCOS_LOG_CAT_T,
    pub flags: VCOS_LOG_CAT_T__bindgen_ty_1,
    pub refcount: ::std::os::raw::c_uint,
    pub platform_data: *mut ::std::os::raw::c_void,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_LOG_CAT_T__bindgen_ty_1 {
    pub _bitfield_align_1: [u8; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize]>,
    pub __bindgen_padding_0: [u8; 3usize],
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T__bindgen_ty_1))
    );
}
impl VCOS_LOG_CAT_T__bindgen_ty_1 {
    #[inline]
    pub fn want_prefix(&self) -> ::std::os::raw::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_want_prefix(&mut self, val: ::std::os::raw::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        want_prefix: ::std::os::raw::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let want_prefix: u32 = unsafe { ::std::mem::transmute(want_prefix) };
            want_prefix as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_VCOS_LOG_CAT_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_LOG_CAT_T>(),
        24usize,
        concat!("Size of: ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_LOG_CAT_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_LOG_CAT_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).level as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(level)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).name as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).refcount as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(refcount)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_LOG_CAT_T>())).platform_data as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_LOG_CAT_T),
            "::",
            stringify!(platform_data)
        )
    );
}
pub type VCOS_VLOG_IMPL_FUNC_T = ::std::option::Option<
    unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
>;
pub type VCOS_CMD_T = VCOS_CMD_S;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_PARAM_T {
    pub argc: ::std::os::raw::c_int,
    pub argv: *mut *mut ::std::os::raw::c_char,
    pub argv_orig: *mut *mut ::std::os::raw::c_char,
    pub cmd_entry: *mut VCOS_CMD_T,
    pub cmd_parent_entry: *mut VCOS_CMD_T,
    pub use_log: ::std::os::raw::c_int,
    pub result_size: size_t,
    pub result_ptr: *mut ::std::os::raw::c_char,
    pub result_buf: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_PARAM_T() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_PARAM_T>(),
        36usize,
        concat!("Size of: ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_PARAM_T>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_PARAM_T))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).argv_orig as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(argv_orig)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_entry)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).cmd_parent_entry as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(cmd_parent_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).use_log as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(use_log)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_ptr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_PARAM_T>())).result_buf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_PARAM_T),
            "::",
            stringify!(result_buf)
        )
    );
}
pub type VCOS_CMD_FUNC_T =
    ::std::option::Option<unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_CMD_S {
    pub name: *const ::std::os::raw::c_char,
    pub args: *const ::std::os::raw::c_char,
    pub cmd_fn: VCOS_CMD_FUNC_T,
    pub sub_cmd_entry: *mut VCOS_CMD_T,
    pub descr: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_VCOS_CMD_S() {
    assert_eq!(
        ::std::mem::size_of::<VCOS_CMD_S>(),
        20usize,
        concat!("Size of: ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        ::std::mem::align_of::<VCOS_CMD_S>(),
        4usize,
        concat!("Alignment of ", stringify!(VCOS_CMD_S))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).args as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).cmd_fn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(cmd_fn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).sub_cmd_entry as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(sub_cmd_entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<VCOS_CMD_S>())).descr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(VCOS_CMD_S),
            "::",
            stringify!(descr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct VCOS_NAMED_SEMAPHORE_IMPL_T {
    pub _address: u8,
}
extern crate libloading;
pub struct libvcos {
    __library: ::libloading::Library,
    pub vcos_pthreads_logging_assert: unsafe extern "C" fn(
        file: *const ::std::os::raw::c_char,
        func: *const ::std::os::raw::c_char,
        line: ::std::os::raw::c_uint,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_verify_bkpts_enabled: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_verify_bkpts_enable:
        unsafe extern "C" fn(enable: ::std::os::raw::c_int) -> ::std::os::raw::c_int,
    pub vcos_abort: unsafe extern "C" fn(),
    pub vcos_backtrace_self: unsafe extern "C" fn(),
    pub vcos_generic_event_flags_create: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_event_flags_set: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ),
    pub vcos_generic_event_flags_delete: unsafe extern "C" fn(arg1: *mut VCOS_EVENT_FLAGS_T),
    pub vcos_generic_event_flags_get: unsafe extern "C" fn(
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_init: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_create_on_heap: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_extend: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_blockpool_alloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_calloc:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_free: unsafe extern "C" fn(block: *mut ::std::os::raw::c_void),
    pub vcos_generic_blockpool_available_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_used_count:
        unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T) -> VCOS_UNSIGNED,
    pub vcos_generic_blockpool_delete: unsafe extern "C" fn(pool: *mut VCOS_BLOCKPOOL_T),
    pub vcos_generic_blockpool_elem_to_handle:
        unsafe extern "C" fn(block: *mut ::std::os::raw::c_void) -> u32,
    pub vcos_generic_blockpool_elem_from_handle:
        unsafe extern "C" fn(
            pool: *mut VCOS_BLOCKPOOL_T,
            handle: u32,
        ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_blockpool_is_valid_elem: unsafe extern "C" fn(
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32,
    pub vcos_generic_mem_alloc: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_calloc: unsafe extern "C" fn(
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_generic_mem_free: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
    pub vcos_generic_mem_alloc_aligned: unsafe extern "C" fn(
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_pthreads_map_error:
        unsafe extern "C" fn(error: ::std::os::raw::c_int) -> VCOS_STATUS_T,
    pub vcos_pthreads_map_errno: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_thread_at_exit: unsafe extern "C" fn(
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_dummy_thread_create: unsafe extern "C" fn() -> *mut VCOS_THREAD_T,
    pub vcos_getmicrosecs64_internal: unsafe extern "C" fn() -> u64,
    pub vcos_pthreads_timer_create: unsafe extern "C" fn(
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_pthreads_timer_set:
        unsafe extern "C" fn(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED),
    pub vcos_pthreads_timer_cancel: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_pthreads_timer_reset:
        unsafe extern "C" fn(timer: *mut VCOS_TIMER_T, delay_ms: VCOS_UNSIGNED),
    pub vcos_pthreads_timer_delete: unsafe extern "C" fn(timer: *mut VCOS_TIMER_T),
    pub vcos_generic_reentrant_mutex_create: unsafe extern "C" fn(
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_generic_reentrant_mutex_delete: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_lock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_reentrant_mutex_unlock: unsafe extern "C" fn(m: *mut VCOS_REENTRANT_MUTEX_T),
    pub vcos_generic_named_semaphore_create: unsafe extern "C" fn(
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_named_semaphore_delete: unsafe extern "C" fn(sem: *mut VCOS_NAMED_SEMAPHORE_T),
    pub vcos_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_deinit: unsafe extern "C" fn(),
    pub vcos_global_lock: unsafe extern "C" fn(),
    pub vcos_global_unlock: unsafe extern "C" fn(),
    pub vcos_set_args:
        unsafe extern "C" fn(argc: ::std::os::raw::c_int, argv: *mut *const ::std::os::raw::c_char),
    pub vcos_get_argc: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_get_argv: unsafe extern "C" fn() -> *mut *const ::std::os::raw::c_char,
    pub vcos_platform_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_platform_deinit: unsafe extern "C" fn(),
    pub vcos_have_rtos: unsafe extern "C" fn() -> ::std::os::raw::c_int,
    pub vcos_thread_create: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_exit: unsafe extern "C" fn(data: *mut ::std::os::raw::c_void),
    pub vcos_thread_join:
        unsafe extern "C" fn(thread: *mut VCOS_THREAD_T, pData: *mut *mut ::std::os::raw::c_void),
    pub vcos_thread_create_classic: unsafe extern "C" fn(
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T,
    pub vcos_thread_get_name:
        unsafe extern "C" fn(thread: *const VCOS_THREAD_T) -> *const ::std::os::raw::c_char,
    pub vcos_kmalloc: unsafe extern "C" fn(
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_kcalloc: unsafe extern "C" fn(
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void,
    pub vcos_kfree: unsafe extern "C" fn(ptr: *mut ::std::os::raw::c_void),
    pub vcos_log_level_to_string:
        unsafe extern "C" fn(level: VCOS_LOG_LEVEL_T) -> *const ::std::os::raw::c_char,
    pub vcos_string_to_log_level: unsafe extern "C" fn(
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T,
    pub vcos_log_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        ...
    ),
    pub vcos_vlog_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_set_vlog_impl: unsafe extern "C" fn(vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T),
    pub vcos_vlog_default_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_logging_init: unsafe extern "C" fn(),
    pub vcos_log_register:
        unsafe extern "C" fn(name: *const ::std::os::raw::c_char, category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_unregister: unsafe extern "C" fn(category: *mut VCOS_LOG_CAT_T),
    pub vcos_log_get_default_category: unsafe extern "C" fn() -> *const VCOS_LOG_CAT_T,
    pub vcos_set_log_options: unsafe extern "C" fn(opt: *const ::std::os::raw::c_char),
    pub vcos_log_set_level_all: unsafe extern "C" fn(levels: *mut ::std::os::raw::c_char),
    pub vcos_log_dump_mem_impl: unsafe extern "C" fn(
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ),
    pub vcos_cmd_error:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_printf:
        unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T, fmt: *const ::std::os::raw::c_char, ...),
    pub vcos_cmd_vprintf: unsafe extern "C" fn(
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ),
    pub vcos_cmd_always_log_output: unsafe extern "C" fn(log_category: *mut VCOS_LOG_CAT_T),
    pub vcos_cmd_usage: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T),
    pub vcos_cmd_register: unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_register_multiple:
        unsafe extern "C" fn(cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T,
    pub vcos_cmd_execute: unsafe extern "C" fn(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T,
    pub vcos_cmd_shutdown: unsafe extern "C" fn(),
    pub vcos_log_assert_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_set_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_status_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_log_test_cmd: unsafe extern "C" fn(param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T,
    pub vcos_vsnprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int,
    pub vcos_snprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int,
    pub vcos_safe_vsprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t,
    pub vcos_safe_sprintf: unsafe extern "C" fn(
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ...
    ) -> size_t,
    pub vcos_safe_strcpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_safe_strncpy: unsafe extern "C" fn(
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t,
    pub vcos_thread_attr_init: unsafe extern "C" fn(attrs: *mut VCOS_THREAD_ATTR_T),
    pub vcos_timer_init: unsafe extern "C" fn() -> VCOS_STATUS_T,
    pub vcos_once: unsafe extern "C" fn(
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T,
}
impl libvcos {
    pub unsafe fn new<P>(path: P) -> Result<Self, ::libloading::Error>
    where
        P: AsRef<::std::ffi::OsStr>,
    {
        let library = ::libloading::Library::new(path)?;
        Self::from_library(library)
    }
    pub unsafe fn from_library<L>(library: L) -> Result<Self, ::libloading::Error>
    where
        L: Into<::libloading::Library>,
    {
        let __library = library.into();
        let vcos_pthreads_logging_assert = __library
            .get(b"vcos_pthreads_logging_assert\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enabled = __library
            .get(b"vcos_verify_bkpts_enabled\0")
            .map(|sym| *sym)?;
        let vcos_verify_bkpts_enable = __library
            .get(b"vcos_verify_bkpts_enable\0")
            .map(|sym| *sym)?;
        let vcos_abort = __library.get(b"vcos_abort\0").map(|sym| *sym)?;
        let vcos_backtrace_self = __library.get(b"vcos_backtrace_self\0").map(|sym| *sym)?;
        let vcos_generic_event_flags_create = __library
            .get(b"vcos_generic_event_flags_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_set = __library
            .get(b"vcos_generic_event_flags_set\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_delete = __library
            .get(b"vcos_generic_event_flags_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_event_flags_get = __library
            .get(b"vcos_generic_event_flags_get\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_init = __library
            .get(b"vcos_generic_blockpool_init\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_create_on_heap = __library
            .get(b"vcos_generic_blockpool_create_on_heap\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_extend = __library
            .get(b"vcos_generic_blockpool_extend\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_alloc = __library
            .get(b"vcos_generic_blockpool_alloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_calloc = __library
            .get(b"vcos_generic_blockpool_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_free = __library
            .get(b"vcos_generic_blockpool_free\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_available_count = __library
            .get(b"vcos_generic_blockpool_available_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_used_count = __library
            .get(b"vcos_generic_blockpool_used_count\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_delete = __library
            .get(b"vcos_generic_blockpool_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_to_handle = __library
            .get(b"vcos_generic_blockpool_elem_to_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_elem_from_handle = __library
            .get(b"vcos_generic_blockpool_elem_from_handle\0")
            .map(|sym| *sym)?;
        let vcos_generic_blockpool_is_valid_elem = __library
            .get(b"vcos_generic_blockpool_is_valid_elem\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_alloc = __library.get(b"vcos_generic_mem_alloc\0").map(|sym| *sym)?;
        let vcos_generic_mem_calloc = __library
            .get(b"vcos_generic_mem_calloc\0")
            .map(|sym| *sym)?;
        let vcos_generic_mem_free = __library.get(b"vcos_generic_mem_free\0").map(|sym| *sym)?;
        let vcos_generic_mem_alloc_aligned = __library
            .get(b"vcos_generic_mem_alloc_aligned\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_error = __library
            .get(b"vcos_pthreads_map_error\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_map_errno = __library
            .get(b"vcos_pthreads_map_errno\0")
            .map(|sym| *sym)?;
        let vcos_thread_at_exit = __library.get(b"vcos_thread_at_exit\0").map(|sym| *sym)?;
        let vcos_dummy_thread_create = __library
            .get(b"vcos_dummy_thread_create\0")
            .map(|sym| *sym)?;
        let vcos_getmicrosecs64_internal = __library
            .get(b"vcos_getmicrosecs64_internal\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_create = __library
            .get(b"vcos_pthreads_timer_create\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_set = __library
            .get(b"vcos_pthreads_timer_set\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_cancel = __library
            .get(b"vcos_pthreads_timer_cancel\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_reset = __library
            .get(b"vcos_pthreads_timer_reset\0")
            .map(|sym| *sym)?;
        let vcos_pthreads_timer_delete = __library
            .get(b"vcos_pthreads_timer_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_create = __library
            .get(b"vcos_generic_reentrant_mutex_create\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_delete = __library
            .get(b"vcos_generic_reentrant_mutex_delete\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_lock = __library
            .get(b"vcos_generic_reentrant_mutex_lock\0")
            .map(|sym| *sym)?;
        let vcos_generic_reentrant_mutex_unlock = __library
            .get(b"vcos_generic_reentrant_mutex_unlock\0")
            .map(|sym| *sym)?;
        let vcos_generic_named_semaphore_create = __library
            .get(b"vcos_generic_named_semaphore_create\0")
            .map(|sym| *sym)?;
        let vcos_named_semaphore_delete = __library
            .get(b"vcos_named_semaphore_delete\0")
            .map(|sym| *sym)?;
        let vcos_init = __library.get(b"vcos_init\0").map(|sym| *sym)?;
        let vcos_deinit = __library.get(b"vcos_deinit\0").map(|sym| *sym)?;
        let vcos_global_lock = __library.get(b"vcos_global_lock\0").map(|sym| *sym)?;
        let vcos_global_unlock = __library.get(b"vcos_global_unlock\0").map(|sym| *sym)?;
        let vcos_set_args = __library.get(b"vcos_set_args\0").map(|sym| *sym)?;
        let vcos_get_argc = __library.get(b"vcos_get_argc\0").map(|sym| *sym)?;
        let vcos_get_argv = __library.get(b"vcos_get_argv\0").map(|sym| *sym)?;
        let vcos_platform_init = __library.get(b"vcos_platform_init\0").map(|sym| *sym)?;
        let vcos_platform_deinit = __library.get(b"vcos_platform_deinit\0").map(|sym| *sym)?;
        let vcos_have_rtos = __library.get(b"vcos_have_rtos\0").map(|sym| *sym)?;
        let vcos_thread_create = __library.get(b"vcos_thread_create\0").map(|sym| *sym)?;
        let vcos_thread_exit = __library.get(b"vcos_thread_exit\0").map(|sym| *sym)?;
        let vcos_thread_join = __library.get(b"vcos_thread_join\0").map(|sym| *sym)?;
        let vcos_thread_create_classic = __library
            .get(b"vcos_thread_create_classic\0")
            .map(|sym| *sym)?;
        let vcos_thread_get_name = __library.get(b"vcos_thread_get_name\0").map(|sym| *sym)?;
        let vcos_kmalloc = __library.get(b"vcos_kmalloc\0").map(|sym| *sym)?;
        let vcos_kcalloc = __library.get(b"vcos_kcalloc\0").map(|sym| *sym)?;
        let vcos_kfree = __library.get(b"vcos_kfree\0").map(|sym| *sym)?;
        let vcos_log_level_to_string = __library
            .get(b"vcos_log_level_to_string\0")
            .map(|sym| *sym)?;
        let vcos_string_to_log_level = __library
            .get(b"vcos_string_to_log_level\0")
            .map(|sym| *sym)?;
        let vcos_log_impl = __library.get(b"vcos_log_impl\0").map(|sym| *sym)?;
        let vcos_vlog_impl = __library.get(b"vcos_vlog_impl\0").map(|sym| *sym)?;
        let vcos_set_vlog_impl = __library.get(b"vcos_set_vlog_impl\0").map(|sym| *sym)?;
        let vcos_vlog_default_impl = __library.get(b"vcos_vlog_default_impl\0").map(|sym| *sym)?;
        let vcos_logging_init = __library.get(b"vcos_logging_init\0").map(|sym| *sym)?;
        let vcos_log_register = __library.get(b"vcos_log_register\0").map(|sym| *sym)?;
        let vcos_log_unregister = __library.get(b"vcos_log_unregister\0").map(|sym| *sym)?;
        let vcos_log_get_default_category = __library
            .get(b"vcos_log_get_default_category\0")
            .map(|sym| *sym)?;
        let vcos_set_log_options = __library.get(b"vcos_set_log_options\0").map(|sym| *sym)?;
        let vcos_log_set_level_all = __library.get(b"vcos_log_set_level_all\0").map(|sym| *sym)?;
        let vcos_log_dump_mem_impl = __library.get(b"vcos_log_dump_mem_impl\0").map(|sym| *sym)?;
        let vcos_cmd_error = __library.get(b"vcos_cmd_error\0").map(|sym| *sym)?;
        let vcos_cmd_printf = __library.get(b"vcos_cmd_printf\0").map(|sym| *sym)?;
        let vcos_cmd_vprintf = __library.get(b"vcos_cmd_vprintf\0").map(|sym| *sym)?;
        let vcos_cmd_always_log_output = __library
            .get(b"vcos_cmd_always_log_output\0")
            .map(|sym| *sym)?;
        let vcos_cmd_usage = __library.get(b"vcos_cmd_usage\0").map(|sym| *sym)?;
        let vcos_cmd_register = __library.get(b"vcos_cmd_register\0").map(|sym| *sym)?;
        let vcos_cmd_register_multiple = __library
            .get(b"vcos_cmd_register_multiple\0")
            .map(|sym| *sym)?;
        let vcos_cmd_execute = __library.get(b"vcos_cmd_execute\0").map(|sym| *sym)?;
        let vcos_cmd_shutdown = __library.get(b"vcos_cmd_shutdown\0").map(|sym| *sym)?;
        let vcos_log_assert_cmd = __library.get(b"vcos_log_assert_cmd\0").map(|sym| *sym)?;
        let vcos_log_set_cmd = __library.get(b"vcos_log_set_cmd\0").map(|sym| *sym)?;
        let vcos_log_status_cmd = __library.get(b"vcos_log_status_cmd\0").map(|sym| *sym)?;
        let vcos_log_test_cmd = __library.get(b"vcos_log_test_cmd\0").map(|sym| *sym)?;
        let vcos_vsnprintf = __library.get(b"vcos_vsnprintf\0").map(|sym| *sym)?;
        let vcos_snprintf = __library.get(b"vcos_snprintf\0").map(|sym| *sym)?;
        let vcos_safe_vsprintf = __library.get(b"vcos_safe_vsprintf\0").map(|sym| *sym)?;
        let vcos_safe_sprintf = __library.get(b"vcos_safe_sprintf\0").map(|sym| *sym)?;
        let vcos_safe_strcpy = __library.get(b"vcos_safe_strcpy\0").map(|sym| *sym)?;
        let vcos_safe_strncpy = __library.get(b"vcos_safe_strncpy\0").map(|sym| *sym)?;
        let vcos_thread_attr_init = __library.get(b"vcos_thread_attr_init\0").map(|sym| *sym)?;
        let vcos_timer_init = __library.get(b"vcos_timer_init\0").map(|sym| *sym)?;
        let vcos_once = __library.get(b"vcos_once\0").map(|sym| *sym)?;
        Ok(libvcos {
            __library,
            vcos_pthreads_logging_assert,
            vcos_verify_bkpts_enabled,
            vcos_verify_bkpts_enable,
            vcos_abort,
            vcos_backtrace_self,
            vcos_generic_event_flags_create,
            vcos_generic_event_flags_set,
            vcos_generic_event_flags_delete,
            vcos_generic_event_flags_get,
            vcos_generic_blockpool_init,
            vcos_generic_blockpool_create_on_heap,
            vcos_generic_blockpool_extend,
            vcos_generic_blockpool_alloc,
            vcos_generic_blockpool_calloc,
            vcos_generic_blockpool_free,
            vcos_generic_blockpool_available_count,
            vcos_generic_blockpool_used_count,
            vcos_generic_blockpool_delete,
            vcos_generic_blockpool_elem_to_handle,
            vcos_generic_blockpool_elem_from_handle,
            vcos_generic_blockpool_is_valid_elem,
            vcos_generic_mem_alloc,
            vcos_generic_mem_calloc,
            vcos_generic_mem_free,
            vcos_generic_mem_alloc_aligned,
            vcos_pthreads_map_error,
            vcos_pthreads_map_errno,
            vcos_thread_at_exit,
            vcos_dummy_thread_create,
            vcos_getmicrosecs64_internal,
            vcos_pthreads_timer_create,
            vcos_pthreads_timer_set,
            vcos_pthreads_timer_cancel,
            vcos_pthreads_timer_reset,
            vcos_pthreads_timer_delete,
            vcos_generic_reentrant_mutex_create,
            vcos_generic_reentrant_mutex_delete,
            vcos_generic_reentrant_mutex_lock,
            vcos_generic_reentrant_mutex_unlock,
            vcos_generic_named_semaphore_create,
            vcos_named_semaphore_delete,
            vcos_init,
            vcos_deinit,
            vcos_global_lock,
            vcos_global_unlock,
            vcos_set_args,
            vcos_get_argc,
            vcos_get_argv,
            vcos_platform_init,
            vcos_platform_deinit,
            vcos_have_rtos,
            vcos_thread_create,
            vcos_thread_exit,
            vcos_thread_join,
            vcos_thread_create_classic,
            vcos_thread_get_name,
            vcos_kmalloc,
            vcos_kcalloc,
            vcos_kfree,
            vcos_log_level_to_string,
            vcos_string_to_log_level,
            vcos_log_impl,
            vcos_vlog_impl,
            vcos_set_vlog_impl,
            vcos_vlog_default_impl,
            vcos_logging_init,
            vcos_log_register,
            vcos_log_unregister,
            vcos_log_get_default_category,
            vcos_set_log_options,
            vcos_log_set_level_all,
            vcos_log_dump_mem_impl,
            vcos_cmd_error,
            vcos_cmd_printf,
            vcos_cmd_vprintf,
            vcos_cmd_always_log_output,
            vcos_cmd_usage,
            vcos_cmd_register,
            vcos_cmd_register_multiple,
            vcos_cmd_execute,
            vcos_cmd_shutdown,
            vcos_log_assert_cmd,
            vcos_log_set_cmd,
            vcos_log_status_cmd,
            vcos_log_test_cmd,
            vcos_vsnprintf,
            vcos_snprintf,
            vcos_safe_vsprintf,
            vcos_safe_sprintf,
            vcos_safe_strcpy,
            vcos_safe_strncpy,
            vcos_thread_attr_init,
            vcos_timer_init,
            vcos_once,
        })
    }
    pub unsafe fn vcos_verify_bkpts_enabled(&self) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enabled)()
    }
    pub unsafe fn vcos_verify_bkpts_enable(
        &self,
        enable: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int {
        (self.vcos_verify_bkpts_enable)(enable)
    }
    pub unsafe fn vcos_abort(&self) -> () {
        (self.vcos_abort)()
    }
    pub unsafe fn vcos_backtrace_self(&self) -> () {
        (self.vcos_backtrace_self)()
    }
    pub unsafe fn vcos_generic_event_flags_create(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_create)(flags, name)
    }
    pub unsafe fn vcos_generic_event_flags_set(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
    ) -> () {
        (self.vcos_generic_event_flags_set)(flags, events, op)
    }
    pub unsafe fn vcos_generic_event_flags_delete(&self, arg1: *mut VCOS_EVENT_FLAGS_T) -> () {
        (self.vcos_generic_event_flags_delete)(arg1)
    }
    pub unsafe fn vcos_generic_event_flags_get(
        &self,
        flags: *mut VCOS_EVENT_FLAGS_T,
        requested_events: VCOS_UNSIGNED,
        op: VCOS_OPTION,
        suspend: VCOS_UNSIGNED,
        retrieved_events: *mut VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_event_flags_get)(flags, requested_events, op, suspend, retrieved_events)
    }
    pub unsafe fn vcos_generic_blockpool_init(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        start: *mut ::std::os::raw::c_void,
        pool_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_init)(
            pool, num_blocks, block_size, start, pool_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_create_on_heap(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_blocks: VCOS_UNSIGNED,
        block_size: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        flags: VCOS_UNSIGNED,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_create_on_heap)(
            pool, num_blocks, block_size, align, flags, name,
        )
    }
    pub unsafe fn vcos_generic_blockpool_extend(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        num_extensions: VCOS_UNSIGNED,
        num_blocks: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_blockpool_extend)(pool, num_extensions, num_blocks)
    }
    pub unsafe fn vcos_generic_blockpool_alloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_alloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_calloc(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_calloc)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_free(&self, block: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_blockpool_free)(block)
    }
    pub unsafe fn vcos_generic_blockpool_available_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_available_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_used_count(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
    ) -> VCOS_UNSIGNED {
        (self.vcos_generic_blockpool_used_count)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_delete(&self, pool: *mut VCOS_BLOCKPOOL_T) -> () {
        (self.vcos_generic_blockpool_delete)(pool)
    }
    pub unsafe fn vcos_generic_blockpool_elem_to_handle(
        &self,
        block: *mut ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_elem_to_handle)(block)
    }
    pub unsafe fn vcos_generic_blockpool_elem_from_handle(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        handle: u32,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_blockpool_elem_from_handle)(pool, handle)
    }
    pub unsafe fn vcos_generic_blockpool_is_valid_elem(
        &self,
        pool: *mut VCOS_BLOCKPOOL_T,
        block: *const ::std::os::raw::c_void,
    ) -> u32 {
        (self.vcos_generic_blockpool_is_valid_elem)(pool, block)
    }
    pub unsafe fn vcos_generic_mem_alloc(
        &self,
        sz: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc)(sz, desc)
    }
    pub unsafe fn vcos_generic_mem_calloc(
        &self,
        count: VCOS_UNSIGNED,
        sz: VCOS_UNSIGNED,
        descr: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_calloc)(count, sz, descr)
    }
    pub unsafe fn vcos_generic_mem_free(&self, ptr: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_generic_mem_free)(ptr)
    }
    pub unsafe fn vcos_generic_mem_alloc_aligned(
        &self,
        sz: VCOS_UNSIGNED,
        align: VCOS_UNSIGNED,
        desc: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_generic_mem_alloc_aligned)(sz, align, desc)
    }
    pub unsafe fn vcos_pthreads_map_error(&self, error: ::std::os::raw::c_int) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_error)(error)
    }
    pub unsafe fn vcos_pthreads_map_errno(&self) -> VCOS_STATUS_T {
        (self.vcos_pthreads_map_errno)()
    }
    pub unsafe fn vcos_thread_at_exit(
        &self,
        pfn: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        cxt: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_at_exit)(pfn, cxt)
    }
    pub unsafe fn vcos_dummy_thread_create(&self) -> *mut VCOS_THREAD_T {
        (self.vcos_dummy_thread_create)()
    }
    pub unsafe fn vcos_getmicrosecs64_internal(&self) -> u64 {
        (self.vcos_getmicrosecs64_internal)()
    }
    pub unsafe fn vcos_pthreads_timer_create(
        &self,
        timer: *mut VCOS_TIMER_T,
        name: *const ::std::os::raw::c_char,
        expiration_routine: ::std::option::Option<
            unsafe extern "C" fn(context: *mut ::std::os::raw::c_void),
        >,
        context: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_pthreads_timer_create)(timer, name, expiration_routine, context)
    }
    pub unsafe fn vcos_pthreads_timer_set(
        &self,
        timer: *mut VCOS_TIMER_T,
        delay_ms: VCOS_UNSIGNED,
    ) -> () {
        (self.vcos_pthreads_timer_set)(timer, delay_ms)
    }
    pub unsafe fn vcos_pthreads_timer_cancel(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_cancel)(timer)
    }
    pub unsafe fn vcos_pthreads_timer_reset(
        &self,
        timer: *mut VCOS_TIMER_T,
        delay_ms: VCOS_UNSIGNED,
    ) -> () {
        (self.vcos_pthreads_timer_reset)(timer, delay_ms)
    }
    pub unsafe fn vcos_pthreads_timer_delete(&self, timer: *mut VCOS_TIMER_T) -> () {
        (self.vcos_pthreads_timer_delete)(timer)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_create(
        &self,
        m: *mut VCOS_REENTRANT_MUTEX_T,
        name: *const ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_reentrant_mutex_create)(m, name)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_delete(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_delete)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_lock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_lock)(m)
    }
    pub unsafe fn vcos_generic_reentrant_mutex_unlock(&self, m: *mut VCOS_REENTRANT_MUTEX_T) -> () {
        (self.vcos_generic_reentrant_mutex_unlock)(m)
    }
    pub unsafe fn vcos_generic_named_semaphore_create(
        &self,
        sem: *mut VCOS_NAMED_SEMAPHORE_T,
        name: *const ::std::os::raw::c_char,
        count: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_generic_named_semaphore_create)(sem, name, count)
    }
    pub unsafe fn vcos_named_semaphore_delete(&self, sem: *mut VCOS_NAMED_SEMAPHORE_T) -> () {
        (self.vcos_named_semaphore_delete)(sem)
    }
    pub unsafe fn vcos_init(&self) -> VCOS_STATUS_T {
        (self.vcos_init)()
    }
    pub unsafe fn vcos_deinit(&self) -> () {
        (self.vcos_deinit)()
    }
    pub unsafe fn vcos_global_lock(&self) -> () {
        (self.vcos_global_lock)()
    }
    pub unsafe fn vcos_global_unlock(&self) -> () {
        (self.vcos_global_unlock)()
    }
    pub unsafe fn vcos_set_args(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> () {
        (self.vcos_set_args)(argc, argv)
    }
    pub unsafe fn vcos_get_argc(&self) -> ::std::os::raw::c_int {
        (self.vcos_get_argc)()
    }
    pub unsafe fn vcos_get_argv(&self) -> *mut *const ::std::os::raw::c_char {
        (self.vcos_get_argv)()
    }
    pub unsafe fn vcos_platform_init(&self) -> VCOS_STATUS_T {
        (self.vcos_platform_init)()
    }
    pub unsafe fn vcos_platform_deinit(&self) -> () {
        (self.vcos_platform_deinit)()
    }
    pub unsafe fn vcos_have_rtos(&self) -> ::std::os::raw::c_int {
        (self.vcos_have_rtos)()
    }
    pub unsafe fn vcos_thread_create(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        attrs: *mut VCOS_THREAD_ATTR_T,
        entry: VCOS_THREAD_ENTRY_FN_T,
        arg: *mut ::std::os::raw::c_void,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create)(thread, name, attrs, entry, arg)
    }
    pub unsafe fn vcos_thread_exit(&self, data: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_thread_exit)(data)
    }
    pub unsafe fn vcos_thread_join(
        &self,
        thread: *mut VCOS_THREAD_T,
        pData: *mut *mut ::std::os::raw::c_void,
    ) -> () {
        (self.vcos_thread_join)(thread, pData)
    }
    pub unsafe fn vcos_thread_create_classic(
        &self,
        thread: *mut VCOS_THREAD_T,
        name: *const ::std::os::raw::c_char,
        entry: ::std::option::Option<
            unsafe extern "C" fn(arg: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        stack: *mut ::std::os::raw::c_void,
        stacksz: VCOS_UNSIGNED,
        priaff: VCOS_UNSIGNED,
        timeslice: VCOS_UNSIGNED,
        autostart: VCOS_UNSIGNED,
    ) -> VCOS_STATUS_T {
        (self.vcos_thread_create_classic)(
            thread, name, entry, arg, stack, stacksz, priaff, timeslice, autostart,
        )
    }
    pub unsafe fn vcos_thread_get_name(
        &self,
        thread: *const VCOS_THREAD_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_thread_get_name)(thread)
    }
    pub unsafe fn vcos_kmalloc(
        &self,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_kmalloc)(size, description)
    }
    pub unsafe fn vcos_kcalloc(
        &self,
        num: VCOS_UNSIGNED,
        size: VCOS_UNSIGNED,
        description: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_void {
        (self.vcos_kcalloc)(num, size, description)
    }
    pub unsafe fn vcos_kfree(&self, ptr: *mut ::std::os::raw::c_void) -> () {
        (self.vcos_kfree)(ptr)
    }
    pub unsafe fn vcos_log_level_to_string(
        &self,
        level: VCOS_LOG_LEVEL_T,
    ) -> *const ::std::os::raw::c_char {
        (self.vcos_log_level_to_string)(level)
    }
    pub unsafe fn vcos_string_to_log_level(
        &self,
        str_: *const ::std::os::raw::c_char,
        level: *mut VCOS_LOG_LEVEL_T,
    ) -> VCOS_STATUS_T {
        (self.vcos_string_to_log_level)(str_, level)
    }
    pub unsafe fn vcos_vlog_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_set_vlog_impl(&self, vlog_impl_func: VCOS_VLOG_IMPL_FUNC_T) -> () {
        (self.vcos_set_vlog_impl)(vlog_impl_func)
    }
    pub unsafe fn vcos_vlog_default_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        _level: VCOS_LOG_LEVEL_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_vlog_default_impl)(cat, _level, fmt, args)
    }
    pub unsafe fn vcos_logging_init(&self) -> () {
        (self.vcos_logging_init)()
    }
    pub unsafe fn vcos_log_register(
        &self,
        name: *const ::std::os::raw::c_char,
        category: *mut VCOS_LOG_CAT_T,
    ) -> () {
        (self.vcos_log_register)(name, category)
    }
    pub unsafe fn vcos_log_unregister(&self, category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_log_unregister)(category)
    }
    pub unsafe fn vcos_log_get_default_category(&self) -> *const VCOS_LOG_CAT_T {
        (self.vcos_log_get_default_category)()
    }
    pub unsafe fn vcos_set_log_options(&self, opt: *const ::std::os::raw::c_char) -> () {
        (self.vcos_set_log_options)(opt)
    }
    pub unsafe fn vcos_log_set_level_all(&self, levels: *mut ::std::os::raw::c_char) -> () {
        (self.vcos_log_set_level_all)(levels)
    }
    pub unsafe fn vcos_log_dump_mem_impl(
        &self,
        cat: *const VCOS_LOG_CAT_T,
        label: *const ::std::os::raw::c_char,
        addr: u32,
        voidMem: *const ::std::os::raw::c_void,
        numBytes: size_t,
    ) -> () {
        (self.vcos_log_dump_mem_impl)(cat, label, addr, voidMem, numBytes)
    }
    pub unsafe fn vcos_cmd_vprintf(
        &self,
        param: *mut VCOS_CMD_PARAM_T,
        fmt: *const ::std::os::raw::c_char,
        args: va_list,
    ) -> () {
        (self.vcos_cmd_vprintf)(param, fmt, args)
    }
    pub unsafe fn vcos_cmd_always_log_output(&self, log_category: *mut VCOS_LOG_CAT_T) -> () {
        (self.vcos_cmd_always_log_output)(log_category)
    }
    pub unsafe fn vcos_cmd_usage(&self, param: *mut VCOS_CMD_PARAM_T) -> () {
        (self.vcos_cmd_usage)(param)
    }
    pub unsafe fn vcos_cmd_register(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_register_multiple(&self, cmd_entry: *mut VCOS_CMD_T) -> VCOS_STATUS_T {
        (self.vcos_cmd_register_multiple)(cmd_entry)
    }
    pub unsafe fn vcos_cmd_execute(
        &self,
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        result_size: size_t,
        result_buf: *mut ::std::os::raw::c_char,
    ) -> VCOS_STATUS_T {
        (self.vcos_cmd_execute)(argc, argv, result_size, result_buf)
    }
    pub unsafe fn vcos_cmd_shutdown(&self) -> () {
        (self.vcos_cmd_shutdown)()
    }
    pub unsafe fn vcos_log_assert_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_assert_cmd)(param)
    }
    pub unsafe fn vcos_log_set_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_set_cmd)(param)
    }
    pub unsafe fn vcos_log_status_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_status_cmd)(param)
    }
    pub unsafe fn vcos_log_test_cmd(&self, param: *mut VCOS_CMD_PARAM_T) -> VCOS_STATUS_T {
        (self.vcos_log_test_cmd)(param)
    }
    pub unsafe fn vcos_vsnprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int {
        (self.vcos_vsnprintf)(buf, buflen, fmt, ap)
    }
    pub unsafe fn vcos_safe_vsprintf(
        &self,
        buf: *mut ::std::os::raw::c_char,
        buflen: size_t,
        offset: size_t,
        fmt: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> size_t {
        (self.vcos_safe_vsprintf)(buf, buflen, offset, fmt, ap)
    }
    pub unsafe fn vcos_safe_strcpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strcpy)(dst, src, dstlen, offset)
    }
    pub unsafe fn vcos_safe_strncpy(
        &self,
        dst: *mut ::std::os::raw::c_char,
        src: *const ::std::os::raw::c_char,
        srclen: size_t,
        dstlen: size_t,
        offset: size_t,
    ) -> size_t {
        (self.vcos_safe_strncpy)(dst, src, srclen, dstlen, offset)
    }
    pub unsafe fn vcos_thread_attr_init(&self, attrs: *mut VCOS_THREAD_ATTR_T) -> () {
        (self.vcos_thread_attr_init)(attrs)
    }
    pub unsafe fn vcos_timer_init(&self) -> VCOS_STATUS_T {
        (self.vcos_timer_init)()
    }
    pub unsafe fn vcos_once(
        &self,
        once_control: *mut VCOS_ONCE_T,
        init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> VCOS_STATUS_T {
        (self.vcos_once)(once_control, init_routine)
    }
}
